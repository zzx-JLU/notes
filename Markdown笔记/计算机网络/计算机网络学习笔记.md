---
title: 计算机网络
chrome:
    format: "A4"
    headerTemplate: '<div></div>'
    footerTemplate: '<div style="width:100%; text-align:center; border-top: 1pt solid #eeeeee; margin: 10px 10px 20px; font-size: 8pt;">
    <span class=pageNumber></span> / <span class=totalPages></span></div>'
    displayHeaderFooter: true
    margin:
        top: '40px'
        bottom: '80px'
        left: '60px'
        right: '60px'
---

<h1>计算机网络</h1>

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1 计算机网络概述](#1-计算机网络概述)
  - [1.1 计算机网络的发展阶段](#11-计算机网络的发展阶段)
  - [1.2 计算机网络的功能](#12-计算机网络的功能)
  - [1.3 计算机网络的组成](#13-计算机网络的组成)
  - [1.4 计算机网络的拓扑结构](#14-计算机网络的拓扑结构)
    - [1.4.1 网状拓扑](#141-网状拓扑)
    - [1.4.2 星状拓扑](#142-星状拓扑)
    - [1.4.3 树状拓扑](#143-树状拓扑)
    - [1.4.4 总线型拓扑](#144-总线型拓扑)
    - [1.4.5 环状拓扑](#145-环状拓扑)
    - [1.4.6 混合型拓扑](#146-混合型拓扑)
  - [1.5 计算机网络的分类](#15-计算机网络的分类)
  - [1.6 计算机网络体系结构](#16-计算机网络体系结构)
    - [1.6.1 网络协议和分层](#161-网络协议和分层)
    - [1.6.2 ISO OSI参考模型](#162-iso-osi参考模型)
  - [1.7 TCP/IP网络体系结构](#17-tcpip网络体系结构)
    - [1.7.1 TCP/IP协议栈](#171-tcpip协议栈)
    - [1.7.2 TCP/IP的物理层和数据链路层](#172-tcpip的物理层和数据链路层)
    - [1.7.3 TCP/IP的网络层](#173-tcpip的网络层)
      - [1.7.3.1 网络层功能与协议](#1731-网络层功能与协议)
      - [1.7.3.2 IP地址](#1732-ip地址)
    - [1.7.4 TCP/IP的传输层](#174-tcpip的传输层)
    - [1.7.5 TCP/IP的应用层](#175-tcpip的应用层)
  - [1.8 实体间通信与服务](#18-实体间通信与服务)
    - [1.8.1 层间通信与对等层间通信](#181-层间通信与对等层间通信)
    - [1.8.2 服务和数据单元](#182-服务和数据单元)
    - [1.8.3 服务原语](#183-服务原语)
    - [1.8.4 协议与服务](#184-协议与服务)
    - [1.8.5 面向连接和面向无连接的服务](#185-面向连接和面向无连接的服务)
      - [1.8.5.1 面向连接的服务](#1851-面向连接的服务)
      - [1.8.5.1 面向无连接的服务](#1851-面向无连接的服务)
  - [1.9 计算机网络的性能](#19-计算机网络的性能)
- [2 数据通信基础](#2-数据通信基础)
  - [2.1 数据通信系统](#21-数据通信系统)
    - [2.1.1 数据通信系统的组成](#211-数据通信系统的组成)
    - [2.1.2 数据通信系统应解决的主要问题](#212-数据通信系统应解决的主要问题)
    - [2.1.3 数据通信的主要技术指标](#213-数据通信的主要技术指标)
  - [2.2 信号和数据编码](#22-信号和数据编码)
    - [2.2.1 模拟信号和数字信号](#221-模拟信号和数字信号)
      - [2.2.1.1 模拟信号](#2211-模拟信号)
      - [2.2.1.2 数字信号](#2212-数字信号)
    - [2.2.2 奈奎斯特准则](#222-奈奎斯特准则)
    - [2.2.3 香农定理](#223-香农定理)
    - [2.2.4 数字-数字编码](#224-数字-数字编码)
      - [2.2.4.1 单极性编码](#2241-单极性编码)
      - [2.2.4.2 极化编码](#2242-极化编码)
      - [2.2.4.3 双极性编码](#2243-双极性编码)
    - [2.2.5 数字-模拟编码](#225-数字-模拟编码)
      - [2.2.5.1 幅移键控（ASK）](#2251-幅移键控ask)
      - [2.2.5.2 频移键控（FSK）](#2252-频移键控fsk)
      - [2.2.5.3 相移键控（PSK）](#2253-相移键控psk)
      - [2.2.5.4 正交调幅（QAM）](#2254-正交调幅qam)
  - [2.3 线路配置](#23-线路配置)
  - [2.4 传输模式](#24-传输模式)
    - [2.4.1 单工、半双工和全双工通信模式](#241-单工半双工和全双工通信模式)
    - [2.4.2 串行和并行传输模式](#242-串行和并行传输模式)
  - [2.5 多路复用技术](#25-多路复用技术)
    - [2.5.1 频分多路复用](#251-频分多路复用)
    - [2.5.2 时分多路复用](#252-时分多路复用)
      - [2.5.2.1 同步时分多路复用](#2521-同步时分多路复用)
      - [2.5.2.2 异步时分多路复用](#2522-异步时分多路复用)
    - [2.5.3 波分多路复用](#253-波分多路复用)
    - [2.5.4 码分多路复用](#254-码分多路复用)
  - [2.6 传统数据交换技术](#26-传统数据交换技术)
    - [2.6.1 电路交换](#261-电路交换)
    - [2.6.2 报文交换](#262-报文交换)
    - [2.6.3 分组交换](#263-分组交换)
      - [2.6.3.1 数据报](#2631-数据报)
      - [2.6.3.2 虚电路](#2632-虚电路)
  - [2.7 错误检测编码](#27-错误检测编码)
    - [2.7.1 奇偶校验码](#271-奇偶校验码)
      - [2.7.1.1 垂直（纵向）奇偶校验](#2711-垂直纵向奇偶校验)
      - [2.7.1.2 水平（横向）奇偶校验](#2712-水平横向奇偶校验)
      - [2.7.1.3 水平垂直（纵横）奇偶校验](#2713-水平垂直纵横奇偶校验)
    - [2.7.2 循环冗余校验码（CRC）](#272-循环冗余校验码crc)
    - [2.7.3 检查和](#273-检查和)
- [3 物理层](#3-物理层)
  - [3.1 物理层功能](#31-物理层功能)
  - [3.2 物理层接口](#32-物理层接口)
  - [3.3 传输介质](#33-传输介质)
    - [3.3.1 双绞线](#331-双绞线)
    - [3.3.2 同轴电缆](#332-同轴电缆)
    - [3.3.3 光缆](#333-光缆)
    - [3.3.4 无线传输介质](#334-无线传输介质)
  - [3.4 物理层互连设备](#34-物理层互连设备)
- [4 数据链路层](#4-数据链路层)
  - [4.1 线路规程](#41-线路规程)
    - [4.1.1 询问/应答模式](#411-询问应答模式)
    - [4.1.2 轮询/选择模式](#412-轮询选择模式)
  - [4.2 流量控制与差错控制](#42-流量控制与差错控制)
    - [4.2.1 停止等待协议](#421-停止等待协议)
      - [4.2.1.1 停止等待协议中的流量控制](#4211-停止等待协议中的流量控制)
      - [4.2.1.2 停止等待协议的差错控制](#4212-停止等待协议的差错控制)
      - [4.2.1.3 停止等待协议的效率](#4213-停止等待协议的效率)
    - [4.2.2 滑动窗口协议](#422-滑动窗口协议)
      - [4.2.2.1 滑动窗口协议中的流量控制](#4221-滑动窗口协议中的流量控制)
      - [4.2.2.2 滑动窗口协议中的差错控制](#4222-滑动窗口协议中的差错控制)
      - [4.2.2.3 回退n自动重复请求](#4223-回退n自动重复请求)
      - [4.2.2.4 选择拒绝自动重复请求](#4224-选择拒绝自动重复请求)
      - [4.2.2.5 滑动窗口协议的效率](#4225-滑动窗口协议的效率)
      - [4.2.2.6 窗口大小的选择](#4226-窗口大小的选择)
  - [4.3 HDLC通信协议](#43-hdlc通信协议)
    - [4.3.1 HDLC支持的站点类型、链路配置和通信方式](#431-hdlc支持的站点类型链路配置和通信方式)
      - [4.3.1.1 站点类型](#4311-站点类型)
      - [4.3.1.2 链路配置](#4312-链路配置)
      - [4.3.1.3 通信方式](#4313-通信方式)
    - [4.3.2 HDLC帧格式](#432-hdlc帧格式)
      - [4.3.2.1 标志域](#4321-标志域)
      - [4.3.2.2 地址域](#4322-地址域)
      - [4.3.2.3 控制域](#4323-控制域)
      - [4.3.2.4 信息域](#4324-信息域)
      - [4.3.2.5 帧校验序列域](#4325-帧校验序列域)
    - [4.3.3 S-帧的使用方式](#433-s-帧的使用方式)
      - [4.3.3.1 接收就绪帧](#4331-接收就绪帧)
      - [4.3.3.2 接收未就绪帧](#4332-接收未就绪帧)
      - [4.3.3.3 拒绝帧](#4333-拒绝帧)
      - [4.3.3.4 选择拒绝帧](#4334-选择拒绝帧)
    - [4.3.4 U-帧的种类](#434-u-帧的种类)
    - [4.3.5 HDLC协议通信实例](#435-hdlc协议通信实例)
  - [4.4 数据链路层网络互连](#44-数据链路层网络互连)
    - [4.4.1 网桥](#441-网桥)
      - [4.4.1.1 网桥的路由功能](#4411-网桥的路由功能)
      - [4.4.1.2 网桥的错误检测和帧格式转换功能](#4412-网桥的错误检测和帧格式转换功能)
      - [4.4.1.3 网桥的隔离通信功能](#4413-网桥的隔离通信功能)
      - [4.4.1.4 桥连不同类型的局域网带来的问题](#4414-桥连不同类型的局域网带来的问题)
    - [4.4.2 网桥路由算法](#442-网桥路由算法)
      - [4.4.2.1 固定路由网桥](#4421-固定路由网桥)
      - [4.4.2.2 透明网桥](#4422-透明网桥)
      - [4.4.2.3 源路由网桥](#4423-源路由网桥)
    - [4.4.3 二层交换机](#443-二层交换机)
  - [4.5 IEEE局域网通信协议](#45-ieee局域网通信协议)
    - [4.5.1 IEEE局域网参考模型](#451-ieee局域网参考模型)
    - [4.5.2 逻辑链路控制](#452-逻辑链路控制)
      - [4.5.2.1 LLC与相邻层的协议数据单元之间的关系](#4521-llc与相邻层的协议数据单元之间的关系)
      - [4.5.2.2 LLC地址与MAC地址](#4522-llc地址与mac地址)
      - [4.5.2.3 LLC层提供的服务](#4523-llc层提供的服务)
  - [4.6 以太网](#46-以太网)
    - [4.6.1 以太网访问模式：CSMA/CD](#461-以太网访问模式csmacd)
      - [4.6.1.1 多路访问（MA）](#4611-多路访问ma)
      - [4.6.1.2 载波监听多路访问（CSMA）](#4612-载波监听多路访问csma)
      - [4.6.1.3 带冲突检测的载波监听多路访问（CSMA/CD）](#4613-带冲突检测的载波监听多路访问csmacd)
    - [4.6.2 以太网MAC帧格式](#462-以太网mac帧格式)
    - [4.6.3 以太网种类](#463-以太网种类)
  - [4.7 无线局域网](#47-无线局域网)
    - [4.7.1 无线局域网标准](#471-无线局域网标准)
    - [4.7.2 CSMA/CA协议](#472-csmaca协议)
  - [4.8 其他局域网技术](#48-其他局域网技术)
    - [4.8.1 令牌环网](#481-令牌环网)
      - [4.8.1.1 令牌环网访问模式：令牌传递](#4811-令牌环网访问模式令牌传递)
      - [4.8.1.2 令牌环网的MAC帧格式](#4812-令牌环网的mac帧格式)
    - [4.8.2 令牌总线网](#482-令牌总线网)
    - [4.8.3 FDDI](#483-fddi)
- [5 网络层](#5-网络层)
  - [5.1 网络层的功能和服务](#51-网络层的功能和服务)
    - [5.1.1 网络层的功能](#511-网络层的功能)
    - [5.1.2 面向连接的网络服务](#512-面向连接的网络服务)
    - [5.1.3 无连接的网络服务](#513-无连接的网络服务)
  - [5.2 网络层互连设备](#52-网络层互连设备)
    - [5.2.1 路由器](#521-路由器)
    - [5.2.2 三层交换机](#522-三层交换机)
    - [5.2.3 网关](#523-网关)
  - [5.3 路由选择原理](#53-路由选择原理)
    - [5.3.1 距离向量路由算法](#531-距离向量路由算法)
    - [5.3.2 链路状态路由算法](#532-链路状态路由算法)
      - [5.3.2.1 链路状态信息共享](#5321-链路状态信息共享)
      - [5.3.2.2 使用Dijkstra算法计算路由表](#5322-使用dijkstra算法计算路由表)
  - [5.4 Internet路由问题](#54-internet路由问题)
  - [5.5 虚电路中数据包的传输](#55-虚电路中数据包的传输)
  - [5.6 拥塞控制和流量控制](#56-拥塞控制和流量控制)
    - [5.6.1 拥塞控制](#561-拥塞控制)
    - [5.6.2 流量控制](#562-流量控制)
      - [5.6.2.1 主机和源节点间的流量控制](#5621-主机和源节点间的流量控制)
      - [5.6.2.2 源节点和目的节点之间的流量控制](#5622-源节点和目的节点之间的流量控制)
  - [5.7 IP协议](#57-ip协议)
    - [5.7.1 IP地址](#571-ip地址)
    - [5.7.2 子网编址与子网掩码](#572-子网编址与子网掩码)
    - [5.7.3 IPv4报文格式](#573-ipv4报文格式)
    - [5.7.4 IP路由选择](#574-ip路由选择)
    - [5.7.5 IPv6](#575-ipv6)
      - [5.7.5.1 IPv6基本报头](#5751-ipv6基本报头)
      - [5.7.5.2 IPv6扩展报头](#5752-ipv6扩展报头)
      - [5.7.5.3 IPv6地址](#5753-ipv6地址)
      - [5.7.5.4 IPv6地址类型](#5754-ipv6地址类型)
  - [5.8 ARP：地址解析协议](#58-arp地址解析协议)
    - [5.8.1 ARP工作过程](#581-arp工作过程)
    - [5.8.2 ARP缓存](#582-arp缓存)
    - [5.8.3 ARP报文格式](#583-arp报文格式)
    - [5.8.4 ARP代理](#584-arp代理)
  - [5.9 ICMP：Internet控制报文协议](#59-icmpinternet控制报文协议)
  - [5.10 IGMP：Internet组管理协议](#510-igmpinternet组管理协议)
    - [5.10.1 多播的基本概念](#5101-多播的基本概念)
    - [5.10.2 多播组地址](#5102-多播组地址)
    - [5.10.3 IGMP报文格式](#5103-igmp报文格式)
    - [5.10.4 IGMP协议功能](#5104-igmp协议功能)
  - [5.11 DHCP协议](#511-dhcp协议)
- [6 传输层](#6-传输层)
  - [6.1 传输层服务](#61-传输层服务)
    - [6.1.1 传输层功能与服务概述](#611-传输层功能与服务概述)
    - [6.1.2 传输层寻址](#612-传输层寻址)
    - [6.1.3 传输层复用](#613-传输层复用)
    - [6.1.4 可靠传输](#614-可靠传输)
      - [6.1.4.1 差错控制](#6141-差错控制)
      - [6.1.4.2 次序控制](#6142-次序控制)
      - [6.1.4.3 丢失控制](#6143-丢失控制)
      - [6.1.4.4 重复控制](#6144-重复控制)
    - [6.1.5 传输层流量控制](#615-传输层流量控制)
    - [6.1.6 传输连接](#616-传输连接)
      - [6.1.6.1 连接建立](#6161-连接建立)
      - [6.1.6.2 连接终止](#6162-连接终止)
  - [6.2 UDP：用户数据报协议](#62-udp用户数据报协议)
    - [6.2.1 UDP报文格式](#621-udp报文格式)
    - [6.2.2 UDP检查和](#622-udp检查和)
  - [6.3 TCP：传输控制协议](#63-tcp传输控制协议)
    - [6.3.1 TCP提供的服务](#631-tcp提供的服务)
    - [6.3.2 TCP的报文格式](#632-tcp的报文格式)
    - [6.3.3 TCP连接的建立和释放](#633-tcp连接的建立和释放)
      - [6.3.3.1 TCP连接的建立](#6331-tcp连接的建立)
      - [6.3.3.2 TCP连接的释放](#6332-tcp连接的释放)
    - [6.3.4 传输层拥塞控制](#634-传输层拥塞控制)
      - [6.3.4.1 慢启动和拥塞避免](#6341-慢启动和拥塞避免)
      - [6.3.4.2 快速重传/快速恢复](#6342-快速重传快速恢复)
- [7 应用层](#7-应用层)
  - [7.1 域名服务](#71-域名服务)
    - [7.1.1 DNS的工作原理](#711-dns的工作原理)
      - [7.1.1.1 域名空间](#7111-域名空间)
      - [7.1.1.2 代理技术](#7112-代理技术)
      - [7.1.1.3 名字服务器](#7113-名字服务器)
      - [7.1.1.4 解释过程](#7114-解释过程)
    - [7.1.2 DNS与ARP的比较](#712-dns与arp的比较)
  - [7.2 电子邮件服务](#72-电子邮件服务)
    - [7.2.1 电子邮件系统的组成](#721-电子邮件系统的组成)
    - [7.2.2 简单邮件传输协议（SMTP）](#722-简单邮件传输协议smtp)
    - [7.2.3 邮件读取协议](#723-邮件读取协议)
      - [7.2.3.1 邮局协议（POP）](#7231-邮局协议pop)
      - [7.2.3.2 Internet邮件访问协议（IMAP）](#7232-internet邮件访问协议imap)
    - [7.2.4 多用途Internet邮件扩充（MIME）](#724-多用途internet邮件扩充mime)
      - [7.2.4.1 内容传送编码](#7241-内容传送编码)
      - [7.2.4.2 内容类型](#7242-内容类型)
  - [7.3 文件传输服务](#73-文件传输服务)
  - [7.4 万维网服务](#74-万维网服务)
    - [7.4.1 超文本](#741-超文本)
    - [7.4.2 超文本传输协议（HTTP）](#742-超文本传输协议http)
    - [7.4.3 Web浏览器的结构](#743-web浏览器的结构)
    - [7.4.4 Web服务器的结构](#744-web服务器的结构)

<!-- /code_chunk_output -->

# 1 计算机网络概述

## 1.1 计算机网络的发展阶段

1. 具有通信功能的联机系统，即“终端-通信线路-计算机”模式。
2. 具有通信功能的分时系统，即“（多）终端-集中器-通信线路-计算机”模式。
3. 计算机网络，即多计算机互连模式。
4. 国际标准化网络，即具有统一的网络体系结构、遵循国际标准化协议的网络。

## 1.2 计算机网络的功能

1. 数据通信。
2. 资源共享。
3. 并行和分布式处理。
4. 提高可靠性。
5. 好的可扩充性。

## 1.3 计算机网络的组成

计算机网络是由多台独立的计算机通过通信线路和通信设备互连起来的系统。连接到网络上的计算机称为主机（host）。

计算机网络从结构上可以分为两部分：负责数据处理的计算机和终端；负责数据通信的通信控制处理机（Communication Control Processor，CCP）和通信线路。

计算机网络从逻辑功能上可以分为两个子网：资源子网、通信子网。

资源子网由计算机系统、网络终端、外部设备（如打印机等）、各种软件资源与数据资源组成。资源子网负责全网的数据处理业务，向网络用户提供各种网络资源与网络服务。

通信子网由网络通信控制处理机（如存储转发处理机、集中器、网络协议变换器、报文分组装配/拆卸设备等）、通信线路及其他通信设备组成。通信子网完成数据传输、转发等通信处理工作。

## 1.4 计算机网络的拓扑结构

网络的拓扑结构是指网络中各节点间的互连模式，也就是网络链路与节点的几何布局。它定义了各节点间的物理与逻辑位置。

### 1.4.1 网状拓扑

在网状拓扑（Mesh Topology）下，每个设备与其他任何一个设备都有一条专线连接。网状拓扑如图 1.1 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图1.1-网状拓扑.1v4ipiuhekm8.png" alt="网状拓扑">
    <br>
    图1.1 网状拓扑
</div>

优点：

1. 设备之间的数据负载有专门的连接承担，避免了共享链路中的拥塞问题。
2. 具有很好的健壮性。当一条链路不可用时，不会使整个网络瘫痪。
3. 具有私有性和安全性。当每个消息都经由专用线路传输时，只有预期的接收者才能收到信息。
4. 点到点的连接使故障检测和故障隔离十分容易。

缺点：所需要的电缆数量和设备上的输入/输出端口的数量过大，费用昂贵，而且安装和重新配置十分困难。

### 1.4.2 星状拓扑

在星状拓扑（Star Topology）中，每个设备只与中央控制器相连接。如果一个设备要向另一个设备发送数据，它先将数据发送到中央控制器，再由中央控制器把数据转发给对应的设备。星状拓扑如图 1.2 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图1.2-星状拓扑.7dpeeqas7nc0.png" alt="星状拓扑">
    <br>
    图1.2 星状拓扑
</div>

优点：

1. 拓扑结构简单。
2. 具有较好的健壮性。如果一条链路失效，只有连到该链路的设备受到影响，其他设备不受影响。
3. 便于管理，故障检测和故障隔离变得容易。可以通过中央控制器监视链路状态和旁路失效的链路。

缺点：

1. 中央控制器是整个网络可靠性的瓶颈。中央控制器出现故障会造成整个网络的瘫痪。
2. 中央控制器是整个网络性能的瓶颈。

### 1.4.3 树状拓扑

树状拓扑（Tree Topology）可以看成是星状拓扑的扩展。绝大多数设备首先连接到一个次级控制器上，再由次级控制器连接到中央控制器。树状拓扑如图 1.3 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图1.3-树状拓扑.6xbw9jztvww0.png" alt="树状拓扑">
    <br>
    图1.3 树状拓扑
</div>

树状拓扑的优缺点与星状拓扑基本相似，但次级控制器的引入带来了另外两个优势：

1. 允许更多的设备相连，增加了信号在设备间的传输距离，扩展了网络距离。
2. 允许网络隔离不同计算机的通信，为不同计算机设定通信的优先级。

### 1.4.4 总线型拓扑

总线型拓扑（Bus Topology）由一条长电缆组成的主干和连接在上面的网络设备组成。网络节点通过引出线和分接头连接到总线电缆上。总线型拓扑如图 1.4 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图1.4-总线型拓扑.3bwvhyu9caw0.png" alt="总线型拓扑">
    <br>
    图1.4 总线型拓扑
</div>

优点：

1. 信息传输不存在路由和转发的问题。
2. 容易安装。

缺点：

1. 故障隔离和重新配置困难。在总线上出现的故障或断裂会终止所有的传输，加入新设备可能需要改动或更新主干。
2. 由于信号的衰减，总线的长度和连接的设备数受到限制。

### 1.4.5 环状拓扑

环状拓扑（Ring Topology）是网络中各设备通过一条首尾相连的通信链路连接起来的一个闭合环状结构网。每个设备只与其两侧的两个设备之间有专有的链路连接。信号在环中单向传输，直到到达目的地为止。环状拓扑如图 1.5 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图1.5-环状拓扑.kcs9nbuwk1s.jpg" alt="环状拓扑">
    <br>
    图1.5 环状拓扑
</div>

优点：

1. 比较容易安装和重新配置。加入和删除一个设备只需改动两条连接线即可。
2. 故障隔离比较简单。如果一个设备在一段特定的时间后没有收到信号，它可以发出一个警告，这个警告提示了故障的存在和位置。

缺点：

1. 如果网络规模较大，会有较大的传输延迟。所以对环的最大长度和设备的数量要有所限制。
2. 在简单环中，由于单向传输，环中的一个故障就能使整个网络瘫痪。

### 1.4.6 混合型拓扑

通常一个网络会将几个不同拓扑结构的子网连接在一起，组成一个更大的网络，整个网络连接成一个混合型拓扑（Hybrid Topology）结构。混合型拓扑如图 1.6 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图1.6-混合型拓扑.77e8rylya7k0.png" alt="混合型拓扑">
    <br>
    图1.6 混合型拓扑
</div>

## 1.5 计算机网络的分类

按作用范围分类：

1. 局域网（Local Area Network，LAN）
2. 城域网（Metropolitan Area Network，MAN）
3. 广域网（Wide Area Network，WAN）

按通信介质分类：

1. 有线网络：同轴电缆、双绞线、光纤
2. 无线网络：卫星、微波

按传播方式分类：点到点、广播

按使用范围分类：公用网、专用网

按通信速率分类：

1. 低速：kbps—1.4 Mbps
2. 中速：1.4 Mbps—45 Mbps
3. 高速：50 Mbps—1000 Mbps

按网络控制方式分类：集中式、分布式

## 1.6 计算机网络体系结构

### 1.6.1 网络协议和分层

网络协议是在主机与主机之间、主机与通信子网之间或通信子网中各通信节点之间的通信中使用的，是通信双方必须遵守的，事先约定好的规则、标准或约定。

网络协议的三要素：

1. 语法：数据与控制信息的结构或格式，如数据格式、信号电平等规定。
2. 语义：控制信息的功能和动作。
3. 时序：事件实现顺序的详细说明，包括速度匹配和顺序。

分层的好处：

1. 各层之间相互独立。
2. 灵活性好。
3. 结构上可分隔开。
4. 易于实现和维护。
5. 有利于标准化工作。

计算机网络的各个层次及其相关协议的集合称为网络体系结构。换言之，网络体系结构是计算机网络所应完成的功能的精确定义。网络体系结构是抽象的，是对功能的精确描述；而实现是具体的，是真正运行的硬件和软件。

分层应遵循以下主要原则：

1. 功能相近的分在一层。
2. 每层的功能应当是十分明确的。
3. 适当选择层与层的边界，使通过这些边界的信息量尽量少。
4. 层次的数量应适当。

### 1.6.2 ISO OSI参考模型

国际标准化组织（International Organization for Standardization，ISO）与1984年制订了开放系统互连参考模型（Open System Interconnect Reference Model，OSI/RM）。OSI 参考模型的结构如图 1.7 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图1.7-OSI参考模型.5il6wwkanho0.png" alt="OSI参考模型">
    <br>
    图1.7 OSI参考模型
</div>

物理层规定在一个节点内如何把计算机连接到通信介质上，规定了机械的、电气的、功能的、规程的特性。物理层负责建立、保持和拆除物理链路；规定如何在此链路上传送原始比特流；规定比特如何编码，使用的电平和极性，连接插头插座的插脚如何分配等。物理层数据传输的单位是**比特**（bit）。

数据链路层把相邻两个节点间不可靠的物理链路变成可靠、无差错的逻辑链路。数据链路层传输数据的单位是**帧**（frame），每帧包括一定数量的数据和一些必要的控制信息，控制信息包括同步信息、地址信息、差错控制信息、流量控制信息等。数据链路层负责建立、维护和释放数据链路。

网络层连接网络中任何两个计算节点，从一个节点上接收数据并正确地传送到另一个节点。网络层数据传输的单位是**分组**或**数据包**（packet）。网络层的主要任务是选择合适的路由和交换节点，透明地向目的站交付发送站所发的分组，这里的 “透明” 表示收发两端看起来是直接连通的。

传输层真正实现了端到端通信，把数据可靠地从一方的用户进程或程序送到另一方的用户进程或程序。从这一层开始的以上各层全部是针对通信的最终 “源端—目的端” 计算机进程的。传输层向上一层提供一个可靠的端到端服务，使上层看不见下边几层的通信细节。传输层的控制通常由通信两端的计算机完成，中间节点一般不提供该层的服务，该层的通信与通信子网无关。传输层及以上各层次的功能通常在主机中实现，而物理层、数据链路层以及网络层的功能均在网络通信处理机中实现。传输层数据传输的单位是**报文**（message）。

会话层允许两台计算机上的用户进程建立会话连接，双方相互确认身份，协商会话连接的细节。会话层可管理会话是双向同时进行，还是任何时刻只能一个方向进行。会话层还提供同步点机制，在数据流中插入同步点，每次网络出现故障后可以仅重传最近一个同步点以后的数据，而不必从头开始。

表示层主要解决用户信息的语法问题，对传送的用户数据进行翻译或解释、编码和变换，使得不同类型的机器对数据信息的不同表示方法可以相互理解。另外，表示层的功能还有数据加密、解密、信息压缩等。

应用层确定进程之间通信的性质，以满足用户的需要。应用层由用户程序组成，处理用户的数据和信息，完成用户所希望的实际任务。

物理层、数据链路层、网络层构成通信子网，用户计算机连接到通信子网上。通信子网负责把一个计算机上的数据可靠地传送到另一台计算机，但并未实现两台主机上进程之间的通信。通信子网的主要功能是面向通信的。

传输层和会话层为两台计算机上的用户进程或程序之间提供了正确传送数据的手段。

## 1.7 TCP/IP网络体系结构

传输控制协议/因特网互联协议（Transmission Control Protocol/Internet Protocol，TCP/IP）是 Internet 运行的基础，是目前应用最广泛的网络通信协议。

### 1.7.1 TCP/IP协议栈

TCP/IP 是一个协议栈，可支撑多种软件平台。它包含多成员协议，从而构成实际的 TCP/IP 协议栈。

TCP/IP 由 5 层构成：物理层、数据链路层、网络层、传输层、应用层。TCP/IP 中的应用层大致可以等同于 OSI 的会话层、表示层和应用层的结合。图 1.8 描述了 TCP/IP 和 OSI 模型的对应关系。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图1.8-TCP-IP网络体系结构.cohttaav6fk.png" alt="TCP-IP网络体系结构">
    <br>
    图1.8 TCP-IP网络体系结构
</div>

### 1.7.2 TCP/IP的物理层和数据链路层

TCP/IP 的物理层和数据链路层负责把 TCP/IP 数据包发送到网络传输介质上，以及从网络传输介质上接收 TCP/IP 数据包。

TCP/IP 没有为物理层和数据链路层定义任何协议，它仅定义了如何与不同的网络进行接口。TCP/IP 的物理层和数据链路层有时又称为网络接口层。

### 1.7.3 TCP/IP的网络层

#### 1.7.3.1 网络层功能与协议

TCP/IP 协议的网络层的主要功能是寻址、数据打包和路由选择。IP 协议是网络层的核心协议。

IP 协议是一个无连接的协议，负责将数据分组从源节点转发到目的节点。IP 协议的主要功能有 IP 寻址、路由选择、分段和合段。

由于 IP 协议是无连接的，所以任何数据开始传送之前不需要建立一条从源节点到目的节点的通路或路径，每个分组可以采用不同的路径转发到目的节点。

IP 协议不保证传输的可靠性，也不保证分组会按发送的顺序到达目的节点。

TCP/IP 协议族中网络层的主要协议还有：地址解析协议（Address Resolution Protocol，ARP）、反向地址解析协议（Reverse Address Resolution Protocol，RARP）、Internet 控制报文协议（Internet Control Message Protocol，ICMP）、Internet 组管理协议（Internet Group Management Protocol，IGMP）等。

#### 1.7.3.2 IP地址

网络中每个独立主机的每个网络接口，以及路由器的每个端口必须有一个唯一的 Internet 地址，也称为 IP 地址。

对于网络中的一些专用设备，如路由器，它有多个接口，其中每个接口都对应一个独立的 IP 地址。

互联网信息中心（Internet Network Information Center，InterNIC）是一个用来分配 IP 地址的管理机构，它只分配网络号，主机号的分配由本地网络管理员负责。InterNIC 由 3 个部门组成：注册服务部门（rs.internic.net）、目录与数据服务部门（ds.internic.net）、信息服务部门（is.internic.net）。

按照通信方式分类，IP 地址分为 3 类：单播地址（目的地址为单个主机）、广播地址（目的地址为指定网络上的所有主机）、多播地址（目的地址为同一组中的所有主机）。

在 TCP/IP 环境中，域名系统（DNS）是一个分布式数据库系统，通过它来提供 IP 地址和主机名之间的映射。

### 1.7.4 TCP/IP的传输层

TCP/IP 协议族提供了两个传输层协议：传输控制协议（TCP）和用户数据报协议（User Datagram Protocol，UDP）。

TCP 是一个可靠的面向连接的传输层协议。由于 IP 协议提供的是面向无连接的不可靠的服务，所以在 TCP/IP 协议族中面向连接的可靠的传输服务由传输层提供。

TCP 将源主机的数据以字节流的形式无差错地传送到目的主机，发送方的 TCP 将上层用户的数据划分成独立的报文并提交给网络层进行发送，而接收方的 TCP 将接收的报文重新装配并提交给上层用户。TCP 还需要进行流量控制，以防止接收方来不及处理发送方发来的数据而造成缓冲区的溢出。

UDP 是一个不可靠的面向无连接的传输层协议，UDP 将可靠性问题交给应用程序解决。UDP 协议主要面向请求/应答式服务，这种应用往往只有一来一往两次报文交换。UDP 协议也应用于对可靠性要求不高但要求网络延迟较小的场合如语音和视频数据的传送。

TCP/IP 网络体系结构中，应用层协议是在应用程序中实现的。应用程序之间的通信是在两个传输服务访问点（TSAP）之间进行的。为了保证从传输服务访问点到传输服务访问点的正确传送，需要传输层的地址。传输层的地址就是传输服务访问点的地址，在 TCP/IP 协议中，一个传输服务访问点称为一个 socket，一个 socket 地址包括 <IP 地址，端口号> 两部分。当一个应用程序想同一个远程应用程序通信时，它必须建立一个 TCP socket 或一个 UDP socket，并将该 socket 与一个 socket 地址绑定。

### 1.7.5 TCP/IP的应用层

应用层为应用程序提供访问低层服务的能力，并定义应用程序用于交换数据的协议。TCP/IP 中常用的应用层协议有：

1. 文件传输协议（FTP）：用于交互式的文件传输。
2. 虚拟终端协议（Telnet）：用于登录到远程主机。
3. 网络新闻传输协议（NNTP）：用于传送网络新闻消息。
4. 简单邮件传输协议（SMTP）：用于邮件服务器之间的邮件传送。
5. 超文本传输协议（HTTP）：用于传输组成 Web 页面的文件。
6. 邮局协议（POP）：用于从邮件服务器上取回邮件。
7. 域名系统（DNS）：用于将域名解析成 IP 地址。
8. 简单网络管理协议（SNMP）：用于在网络管理控制台和网络设备（路由器、网桥、集线器等）之间选择和交换网络管理信息。

## 1.8 实体间通信与服务

计算机网络中，每层的功能是由该层的实体来实现的。下层实体向上层实体提供服务，上层实体调用下层实体所提供的服务完成自己的功能。

### 1.8.1 层间通信与对等层间通信

同一个网络节点上相邻层次中实体之间的通信称为**层间通信**。

网络中不同主机内相对应的层次称为**对等层**，对等层之间两个通信的实体称为**对等层实体**。不同的网络节点上对等层实体间的通信称为**对等层间通信**。

除物理层之外，对等层之间的通信叫做**虚通信**。层间通信以及物理层之间的通信叫做**实通信**。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图1.9-层间通信与对等层间通信.5c2nffmoz2o0.png" alt="层间通信与对等层间通信">
    <br>
    图1.9 层间通信与对等层间通信
</div>

### 1.8.2 服务和数据单元

数据在网络中各节点内是沿层次传送的，每层为其上面各层提供专门的通信服务，每层完成的功能是其上各层工作的基础。

设物理层为第 1 层，应用层为第 7 层，在 N 层和 N+1 层的接口处，由 N 层向 N+1 层提供服务。N 层是服务的提供者，N+1 层是服务用户。

层间接口处提供服务的地方称为**服务访问点**（Service Access Point，SAP），每个服务访问点都有一个唯一的地址标识。

相邻层在提供服务的过程中要传递信息，这些信息称为**服务数据单元**（Service Data Unit，SDU）。在 N+1 和 N 层之间传递的数据单元记为 (N)SDU。

对等层间交换的信息单位称为**协议数据单元**（Protocol Data Unit，PDU）。N 层的 PDU 由该层的 SDU 加上该层的**协议控制信息**（Protocol Control Information，PCI）构成，如图 1.10 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图1.10-数据单元.7ejfjkyg5gk0.png" alt="数据单元">
    <br>
    图1.10 数据单元
</div>

有时可以将多个 (N+1)PDU 拼成一个 (N)SDU，称为**拼接**（concatenation）。如果发送方进行了拼接，在接收方的对等层就要进行**分割**（separation）。

如果一个 (N)SDU 太大，可以分成若干段，分别加上 PCI，构成多个 (N)PDU，这在发送方称为**分段**（segmenting）。如果发送方进行了分段，在接收方的对等层就要进行**合段**（reassembling）。

### 1.8.3 服务原语

服务用户和服务提供者之间要进行交互，交互的信息称为**服务原语**。

服务原语是引用服务的工具。 N+1 层实体通过 N 层的服务原语向 N 层实体请求服务。

服务原语的类型：

1. 请求（request）：一个实体请求得到某种服务。由 N+1 层向 N 层发出，要求 N 层提供服务。
2. 指示（indication）：把关于某一事件的消息告诉某一实体。由 N 层向 N+1 层发出，表示服务开始。
3. 响应（response）：一个实体愿意响应某一事件。由 N+1 层向 N层发出，表示对指示的响应。
4. 证实（confirm）：确认一个实体的服务请求。由 N 层向 N+1 层发出，表示请求已完成。

根据使用的服务原语的不同，可以将服务分为证实型服务和非证实型服务。

证实型服务如图 1.11 所示：

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图1.11-证实型服务.7835l4kc20s0.png" alt="证实型服务">
    <br>
    图1.11 证实型服务
</div>

非证实型服务如图 1.12 所示：

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图1.12-非证实型服务.4tr500f1q0e0.png" alt="非证实型服务">
    <br>
    图1.12 非证实型服务
</div>

服务原语的组成：原语名字、原语类型、原语参数。

### 1.8.4 协议与服务

本层的服务用户只能看见服务，而无法看见下层的协议。下层的协议对上层的服务用户是透明的。

协议是 “水平的”，控制对等实体之间的通信规则；服务是 “垂直的”，由下层向上层通过层间接口提供。

### 1.8.5 面向连接和面向无连接的服务

在 OSI 参考模型中，下层能向上层提供两种不同形式的服务：面向连接的服务和面向无连接的服务。

#### 1.8.5.1 面向连接的服务

所谓连接，就是两个对等实体为进行数据通信而进行的一种结合。面向连接的服务在进行数据交换前先建立连接，当数据传输结束后释放这个连接。采用面向连接的服务进行数据传输要经历以下 3 个阶段：

1. 建立连接阶段。在有关的服务原语和协议数据单元中，必须给出源用户和目的用户的完整地址。
2. 数据交换阶段。在这个阶段，每个报文中不必包含源用户和目的用户的完整地址，而是使用一个连接标识符来代替，使控制信息在报文中所占的比重相对减小，减小系统的额外开销，提高信道的利用率。报文的发送和接收是按固定顺序的，发送方先发送的报文，在接收方先收到。
3. 释放连接阶段。

连接就像一个管道，发送者在其一端依次发送报文，接收者在其另一端按同样的顺序依次接收报文。这种连接又称虚拟电路，它可以避免报文的丢失、重复和乱序。

#### 1.8.5.1 面向无连接的服务

在无连接服务的情况下，两个实体间的通信不必事先建立连接。相对于面向连接的服务，无连接服务灵活方便且快速，但它不能防止报文的丢失、重复和乱序。由于它的每个报文必须包括完整的源地址和目的地址，因此开销较大。

面向无连接的服务主要有 3 种类型：

1. 数据报。它的特点是发完报文就结束，而对方不做任何响应。数据报的服务简单、额外开销少，但可靠性差，比较适合于数据具有很大冗余度以及实时性要求较高的通信场合。
2. 证实交付。又称可靠的数据报。这种服务对每个报文产生一个证实发送给对方，不过这种证实不是来自对应方用户，而是来自提供服务的层。这种证实只能保证报文已经发给目的站，而不能保证对应方用户正确地收到报文。
3. 请求回答。这种类型的服务是接收端用户每收到一个报文，就向发送端用户发送一个应答报文。如果接收端发现报文有错误，则回送一个表示有错误的报文。但是双方发送的报文都有可能丢失。

## 1.9 计算机网络的性能

吞吐量：表示在单位时间内通过某个网络（或信道、接口）的数据量。

信道利用率：除去全部控制信息后的数据量与信道吞吐量之比，或发送数据的时间和信道被占用时间之比。

延迟时间：

1. 排队时间：在发送队列中的等待时间。
2. 访问延时：等待信道空闲的时间。
3. 发送延时：从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。

$$
发送延时=\frac{数据块长度(比特)}{信道带宽(比特/秒)}
$$

4. 传输延时：电磁波在信道中传播而花费的时间。

$$
传输延时=\frac{信道长度}{信号在信道上的传播速率}
$$

总时延 = 排队时间 + 访问延时 + 发送延时 + 传输延时。

# 2 数据通信基础

## 2.1 数据通信系统

### 2.1.1 数据通信系统的组成

数据通信系统由 5 部分组成：

1. 信源：产生要发送数据的设备。
2. 发送设备：将数据信息进行编码，将数据信息变换成可在传输系统中传送的信号并将信号送给传输系统。
3. 传输系统。
4. 接收设备：接收信号，将信号变换成信宿可处理的数据信息。
5. 信宿：从接收设备接收数据信息。

其中信源和发送设备组成**源系统**，信宿和接收设备组成**目的系统**，如图 2.1 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.1-数据通信系统.3oyjqkbsomm0.png" alt="数据通信系统">
    <br>
    图2.1 数据通信系统
</div>

### 2.1.2 数据通信系统应解决的主要问题

1. 提高传输系统的利用率。提高传输系统的利用率可以提高系统吞吐量。
2. 接口、编码和同步。
3. 交换管理。如果通信双方需要交换信息，信息是双向传送的，这时需要通信双方的合作。
4. 检错和纠错。
5. 流量控制。流量控制用于确保发送方发送数据的速率不会太快，使得接收方能够来得及接收和处理，而不会造成接收方瘫痪。
6. 寻址和路由。
7. 恢复。
8. 报文格式。
9. 网络管理。网络管理用于系统的配置、状态的监控、对差错和超载的反应等。

### 2.1.3 数据通信的主要技术指标

承载信息量的基本信号单位叫做**码元**。在数字通信中，一个数字脉冲就是一个码元。码元携带的信息量由码元的离散值个数决定，当码元有 $M$ 个离散状态时，每个码元承载的信息量为 $\log_2M$ 个比特，此时的码元称为 $M$ 进制码元。

每秒钟传送码元的数目叫做**码元速率**，也叫做**波特率**，单位为 Baud（波特）。码元速率用 $B$ 表示。

**数据传输率**又叫做**信息速率**，指每秒传送的信息量，单位是 bps（比特/秒）。数据传输率用 $C$ 表示。对于 $M$ 进制的码元，信息速率与码元速率的关系为：$C=B\times\log_2M$。

**误码率**：指错误接收的报文码元数在传输报文总码元数中占的比例。

**误比特率**：指错误接收的比特数在传输报文总比特数中占的比例。

## 2.2 信号和数据编码

### 2.2.1 模拟信号和数字信号

#### 2.2.1.1 模拟信号

模拟信号是随时间变化而连续变化的连续电磁波形式。

模拟信号可以分为简单信号和复合信号。

简单信号即正弦波信号，它的数学表达式为：
$$
x(t)=A\sin(2\pi ft+\varPhi)
$$

其中，$x(t)$ 表示 $t$ 时刻的信号，$A$ 表示信号的最大振幅，$f$ 表示信号的频率，$\varPhi$ 表示信号的相位。

复杂信号可以被分解为多个正弦波的叠加。复合信号的频谱是该信号所包含的所有正弦波分量的频率的集合，带宽是频谱中最高频率与最低频率之间的差值。

#### 2.2.1.2 数字信号

数字信号是离散的，它只可以包含有限数目的几个预定值。数字信号从一个值到另一个值的转换是瞬时发生的。

大多数数字信号是非周期性的，不能用振幅、频率和相位来描述。常用比特间隙和比特率来描述数字信号。**比特间隙**是发送一比特需要的时间。**比特率**是一秒钟内的比特间隙个数，也就是每秒发送的比特数，单位为 bps（比特/秒）。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.2-比特间隙和比特率.4gcv1f1s00o0.png" alt="比特间隙和比特率">
    <br>
    图2.2 比特间隙和比特率
</div>

数字信号由多个频率的信号叠加而成，如果只传输那些具有重要振幅的分量，接收端仍然能够以合理的精度恢复信号。数字信号频谱中的这一部分称为**有效频谱**，有效频谱的带宽称为**有效带宽**。

某种传输介质只能传输某些频率范围内的信号，这个频率范围就是该介质的**介质带宽**。信号的有效带宽必须在介质带宽的范围之内，否则信号就可能产生失真，造成在接收端无法识别。

有效带宽随着比特率的增加而增加。这意味着当比特率增加时，必须有更宽的有效带宽，从而就需要具有更大带宽的介质。所以，传输介质限制了比特率的增加。一种传输介质可以传输的最大比特率称为介质的**信道容量**。

### 2.2.2 奈奎斯特准则

**奈奎斯特准则**也称为**奈氏定理**，它给出了有限带宽无噪声信道的极限波特率。若信道带宽为 $W$（单位为赫兹），则在无噪声情况下，信道的最大波特率为：
$$
B=2\times W
$$

### 2.2.3 香农定理

香农定理给出了信道信息传送速率的上限和信道信噪比及带宽的关系。在有随机热噪声的信道上传输数据信号时，信道容量 $R_\text{max}$ 与信道带宽 $W$、信噪比 $S/N$ 的关系为：
$$
R_\text{max}=W\times\log_2(1+S/N)
$$

其中，$S$ 是平均信号功率，$N$ 是平均噪声功率，$S/N$ 即为信噪比。信噪比通常用分贝（dB）表示，分贝数的计算公式为：
$$
分贝数=10\times\log_{10}(S/N)
$$

从香农定理可以得知：

1. 信道容量由带宽和信噪比决定，增大带宽、提高信噪比可以增大信道容量。
2. 在要求的信道容量一定的条件下，提高信噪比可以降低带宽的要求，增加带宽可以降低信噪比的要求。
3. 香农定理给出了信道容量的极限，实际无线制式中单信道容量不可能超过该极限。

### 2.2.4 数字-数字编码

数字-数字编码是用数字信号来表示数字信息。在这种编码形式下，由计算机产生的 0、1 比特序列被转换成一串可以在导线上传输的脉冲电压。

数字通信中最有用的数字-数字编码有三大类：单极性编码、极化编码、双极性编码。

#### 2.2.4.1 单极性编码

单极性编码是最简单最基本的一种数字信息—数字信号的编码形式。“单极性”指的是电压只有一极，高电平表示 1，低电平表示 0。如图 2.3 所示：

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.3-单极性编码.6i0lgt31xs80.png" alt="单极性编码">
    <br>
    图2.3 单极性编码
</div>

单极性编码存在的问题：

1. 直流分量的问题。由于单极性编码信号的平均振幅不等于 0，所以存在一个直流分量。某些传输介质没有处理直流分量的能力，如微波。
2. 同步的问题。当数据流中有一长串连续的 0 或 1 时，接收端无法准确知道每个比特的开始和结束，只能依赖时间因素。如果收发两端的时钟频率有差异，接收端就会产生读入错误。解决同步问题的一个方案是利用一条独立并行的线路来传输时钟脉冲，但这将增加传输线路，增加了开销。

#### 2.2.4.2 极化编码

极化编码采用两个电压：一个正电压，一个负电压。通过使用两个电压，减轻了单极性编码中的直流分量问题。

极化编码最常见的有 3 种：非归零编码（NRZ）、归零编码（RZ）、双相位码。

在非归零编码中，信号的电压值或正或负，线路空闲意味着没有传输任何信号。非归零编码有两种：非归零电平编码（NRZ-L）和非归零反相编码（NRZ-I）。在 NRZ-L 编码方式中，正电压代表 1，负电压代表 0。在 NRZ-I 方式中，信号电平的一次翻转代表 1，没有电平的变化代表 0。如图 2.4 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.4-非归零编码.512mmmpfaz40.png" alt="非归零编码">
    <br>
    图2.4 非归零编码
</div>

双相位编码中，信号在比特间隙的中间转为相反的一极。双相位编码有两种方式：曼彻斯特编码、差分曼彻斯特编码。曼彻斯特编码在每个比特间隙中间引入跳变来表示不同的比特和同步信息，负电平到正电平的跳变代表比特 1，正电平到负电平的跳变代表比特 0。在差分曼彻斯特编码中，比特间隙中间的跳变用于携带同步信息，每个比特间隙的开始位置有跳变代表比特 0，没有跳变则代表比特 1。如图 2.5 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.5-双相位码.1o5tw4bciskg.png" alt="双相位码">
    <br>
    图2.5 双相位码
</div>

#### 2.2.4.3 双极性编码

在双极性编码中，零电平代表比特 0，正负电平交替代表比特 1。如果第一个比特 1 由正电平代表，则第二个比特 1 由负电平代表，第三个比特 1 由正电平代表，以此类推。

有 3 种双极性编码：信号交替反转码（AMI）、8 零替换编码（B8ZS）、高密度双极性 3 零编码（HDB3）。

信号交替反转码是双极性编码中最简单的一种。0 电平代表二进制 0，二进制 1 由交替的正负电平代表。如图 2.6 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.6-信号交替反转码.10ibagrs0gy8.jfif" alt="信号交替反转码">
    <br>
    图2.6 信号交替反转码
</div>

AMI 实现了两个目标：直流分量为零、一长串的比特 1 可以进行同步。但是对于一长串的比特 0 没有保持同步机制。B8ZS 和 HDB3 解决了长串比特 0 的同步问题。

### 2.2.5 数字-模拟编码

数字-模拟编码是用模拟信号来代表数字信息的编码技术。

在模拟传输中，发送设备产生一个高频信号作为基波来承载信息信号，这个基波就是**载波信号**，其频率称为载波频率。发送方通过改变载波信号的一个或多个特性（频率、振幅和相位）将数字信息调制到载波信号上，载波信号的这种改变称为**调制**，带有信息的载波信号称为**调制信号**。

最常用的数字-模拟编码机制有 4 种：幅移键控、频移键控、相移键控、正交调幅。

#### 2.2.5.1 幅移键控（ASK）

在幅移键控技术中，通过改变载波信号的强度（即振幅）来代表二进制 0、1，而相位和频率保持不变。如图 2.7 所示。

ASK 的缺点是受噪声影响很大，抗干扰能力很差。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.7-幅移键控.3de56mj4iqy0.png" alt="幅移键控">
    <br>
    图2.7 幅移键控
</div>

#### 2.2.5.2 频移键控（FSK）

在频移键控技术中，通过改变载波信号的频率来代表二进制 0、1，而相位和振幅保持不变。如图 2.8 所示。

FSK 避免了 ASK 中的噪声问题，抗干扰能力比 ASK 好。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.8-频移键控.77zt2epzb1g0.png" alt="频移键控">
    <br>
    图2.8 频移键控
</div>

#### 2.2.5.3 相移键控（PSK）

在相移键控技术中，通过改变载波信号的相位来代表二进制 0、1，而频率和振幅保持不变。

在 PSK 中，可以用两种不同相位的正弦信号分别表示 0 或 1，信号之间的相位差为 180°，这种 PSK 技术称为二相位 PSK，或 2-PSK。如图 2.9 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.9-2-PSK.5xhx3gv1aio0.png" alt="2-PSK">
    <br>
    图2.9 2-PSK
</div>

也可以用 4 种不同相位的正弦信号表示 2 位二进制信息，信号之间的相位差为 90°，这种 PSK 技术称为四相位 PSK，或 4-PSK，或 Q-PSK。

类似地，也可以采用 8-PSK 技术，每种相位的正弦信号可以表示 3 位二进制信息，信号之间的相位差为 45°。

对于 PSK 技术，可以采用星座图来描述相位值和比特值之间的对应关系。图 2.10 分别给出了 2-PSK、4-PSK 和 8-PSK 的星座图。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.10-PSK星座图.34fdn6f77uw0.png" alt="PSK星座图">
    <br>
    图2.10 PSK星座图
</div>

#### 2.2.5.4 正交调幅（QAM）

正交调幅是将 ASK 和 PSK 结合起来的编码方法。设在相位上有 $x$ 种变化，在振幅上有 $y$ 种变化，则总共有 $x\cdot y$ 种可能的变化用来编码。图 2.11 表示一个 2 振幅、4 相位的正交调幅。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.11-正交调幅.1heixf0y5k2o.png" alt="正交调幅">
    <br>
    图2.11 正交调幅
</div>

正交调幅也可以用星座图来描述。图 2.12 描述了两种 16-QAM 星座图。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.12-16-QAM星座图.3768iyqy7jw0.png" alt="QAM星座图">
    <br>
    图2.12 QAM星座图
</div>

## 2.3 线路配置

线路配置是指两个或两个以上的设备连接到链路的方式。

有两种线路配置方式：点到点连接、多点连接。

点到点连接提供了两个设备之间的专用链路，整个信道的容量都被用于这两个设备之间的传输。如图 2.13 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.13-点到点连接.1b3gu99ttsxs.png" alt="点到点连接">
    <br>
    图2.13 点到点连接
</div>

多点连接是两个以上的设备共享一条链路的线路配置方式，如图 2.14 所示。在多点连接的环境中，信道的容量是通过某种途径共享的，实现信道容量共享的技术称为复用技术。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.14-多点连接.2t76msrf19k0.png" alt="多点连接">
    <br>
    图2.14 多点连接
</div>

## 2.4 传输模式

传输模式定义了比特流从一个设备传到另一个设备的方式。

### 2.4.1 单工、半双工和全双工通信模式

在单工模式中，通信是单向进行的，一条链路中的两个站点中只有一个可以进行发送，另一个只能接收。如图 2.15 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.15-单工通信模式.5s7705pg7r00.png" alt="单工通信模式">
    <br>
    图2.15 单工通信模式
</div>

在半双工通信模式中，每个站点都可以发送和接收，但是不能同时发送和接收。当其中一个设备在发送时，另一个只能接收。在半双工模式中，无论哪一方开始传输，都使用信道的整个带宽。如图 2.16 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.16-半双工通信模式.7ayu5rs8ovc0.png" alt="半双工通信模式">
    <br>
    图2.16 半双工通信模式
</div>

在全双工通信模式（或称双工模式）中，两个站点可以同时进行发送和接收，两个方向的信号共享链路带宽，如图 2.17 所示。这种共享可以通过两种方式进行：其一，链路具有两条物理上独立的传输路径，一条发送，一条接收；其二，将信道带宽一分为二，同时传输两个方向的信号。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.17-全双工通信模式.74z79aoa07k0.png" alt="全双工通信模式">
    <br>
    图2.17 全双工通信模式
</div>

### 2.4.2 串行和并行传输模式

在并行传输模式中，每个时钟脉冲到来时，同时发送多个比特，每个比特使用单独的一条线路。在串行传输中，每个时钟脉冲只发送一个比特，它只使用一条线路逐个传送每个比特。图 2.18 展示了串行传输和并行传输的区别。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.18-串行传输和并行传输.206drzpmf09s.png" alt="串行传输和并行传输">
    <br>
    图2.18 串行传输和并行传输
</div>

并行传输通常用于近距离传输，如计算机和外部设备之间的通信。并行传输不适合于长距离通信，原因是：

1. 在长距离上使用多条线路要比使用一条线路昂贵。
2. 长距离传输要求使用较粗的导线来降低信号的衰减，这时要把它们捆到一条单独的电缆里相当困难。
3. 长距离时，导线上的电阻会阻碍比特的传输，从而使其到达速度不一致，给接收端同步带来麻烦。

串行传输模式每次只能发送一个比特，所以其速度比较慢，但是这种方式比较便宜。计算机网络中使用串行传输。

有两种串行通信模式：异步传输、同步传输。

异步传输指比特被划分成多个小组独立传送，发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达。每次异步传输都以一个开始位开头，用一个停止位表示一次传输的终止。在异步传输中，空闲的线路常用来表示二进制 1 的信号，开始位使信号变成 0，其他的比特位使信号随比特值而变化，停止位使信号重新变为 1，该信号一直保持到下一个开始位到达。如图 2.19 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.19-异步传输.6danb2jr20g0.png" alt="异步传输">
    <br>
    图2.19 异步传输
</div>

异步传输常用于低速设备，如键盘和某些打印机。异步传输的开销比较大，传输有限个比特就需要传输一个开始位和一个停止位。

同步传输成块地传输字符或比特流，字符之间不加开始位和停止位。这些成块的字符或比特流被组合成数据帧，或称为帧。数据帧的具体组织形式随协议而定。

同步传输中，同步分为两级实施：

1. 二进制位的同步。可以有两种方法，一种是在接收端和发送端之间单设一条线传送时钟脉冲；另一种是采用自同步编码，如曼彻斯特编码等。
2. 数据帧的同步。在数据帧前后加上起始和结束标志，使得接收端能够了解数据帧的起始和结束。

数据帧的具体组织形式随协议而定，不同的协议有不同的组织形式，但数据帧有许多公共的特征。图 2.20 显示了一个数据帧的一般组织形式，方向从右向左。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.20-同步传输.6hjuv7v7tjc0.png" alt="同步传输">
    <br>
    图2.20 同步传输
</div>

数据帧的第一部分是同步字符（syn），或者是一个特定的比特组合，用于通知接收方一个数据帧已经到达。

数据帧的第二部分是控制域，可能包含下列元素：

- 源地址。
- 目的地址。
- 数据的实际字节数。
- 序列号。在传送多帧的情况下，数据帧可能无法按顺序到达目的地，接收方按照序列号对数据帧进行重新排序或判断帧的丢失。
- 帧类型。

数据帧的第三部分是数据域，也就是要发送的信息。

第四部分是错误检查域，用来检测和校正传输错误。

第五部分是帧结束标记，用于表示该帧已经结束。

## 2.5 多路复用技术

多路复用技术是利用一条链路同时传输多路信号的技术。使用多路复用技术可以最大程度地利用系统所具有的传输能力。多路复用技术的基本形式如图 2.21 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.21-多路复用技术的基本形式.jts51kk719s.png" alt="多路复用技术的基本形式">
    <br>
    图2.21 多路复用技术的基本形式
</div>

最基本的多路复用技术有：频分多路复用（Frequency-Division Multiplexing，FDM）、时分多路复用（Time-Division Multiplexing，TDM）、波分多路复用（Wavelength-Division Multiplexing，WDM）、码分多路复用（Code-Division Multiplexing，CDM）。

### 2.5.1 频分多路复用

频分多路复用是一种模拟技术，适用于模拟信号，在链路带宽大于要传输的所有信号带宽之和时使用。

频分多路复用通过分割通信线路的带宽，从而将共享的通信线路分隔成几个独立的通信信道，通道之间必须有警戒频带分隔以防止信号交叉。如图 2.22 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.22-频分多路复用.6mputa2enpo0.png" alt="频分多路复用">
    <br>
    图2.22 频分多路复用
</div>

### 2.5.2 时分多路复用

时分多路复用通过分割时间来划分信道。在传输时把时间分割成小的时间片，每个时间片有一个复用的信号占用。复用的各路信号在时间上互不重叠，各路复用信号由警戒时间间隔分开。如图 2.23 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.23-时分多路复用.49mqm100nyi0.png" alt="时分多路复用">
    <br>
    图2.23 时分多路复用
</div>

时分多路复用是一种数字过程，当传输媒介的数据速率大于发送和接收设备所需的数据速率时就可以采用它。时分多路复用适用于数字信号。

时分多路复用可以用两种方式实现：同步时分多路复用、异步时分多路复用。

#### 2.5.2.1 同步时分多路复用

在同步时分多路复用技术中，同步是指复用器在一段时间内为每个设备分配完全一样的时间片，不管该设备有没有数据要传输。每当设备所分配的时间片到来时，它就可以发送一部分数据。如果此时设备不能发送数据或是没有要发送的数据，该时间片就是空的。

在时分多路复用技术中，每个发送设备在复用器中有一个缓冲区，发送设备将自己要发送的数据单元存放在复用器中对应的缓冲区中。复用器扫描每个缓冲区，从每个缓冲区中取出一个数据单元放入一个帧中，然后把这个帧发送出去。一个帧是由时间片的一个完整循环组成，分配给某一设备的时间片在一帧中的位置是固定的。图 2.24 表示了同步时分多路复用技术的工作原理。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.24-同步时分多路复用.34bqhmrpkl20.png" alt="同步时分多路复用">
    <br>
    图2.24 同步时分多路复用
</div>

同步时分多路复用的信道效率差。因为分配给某个设备的时间片只能被该设备使用，如果该设备没有要发送的信息，则分配的时间片就被浪费了。

同步时分多路复用的帧是固定大小的，控制简单。

#### 2.5.2.2 异步时分多路复用

异步时分多路复用也称为统计复用。在异步时分多路复用系统中，时间片的数目是根据在给定时刻可能进行发送的输入线路数目的统计结果决定的。每个时间片都可以被所连接的任何一个有数据发送的输入线路使用。图 2.25 表示了异步时分多路复用技术的工作原理，帧中每个数据单元附带的数字表示了该数据单元的地址。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.25-异步时分多路复用.kkkasbkcvow.png" alt="异步时分多路复用">
    <br>
    图2.25 异步时分多路复用
</div>

与同步时分多路复用相比，异步时分多路复用能提高系统的利用率。但是，异步时分多路复用需要一些额外的代价：

1. 信息单元需附带地址信息。
2. 复用器必须有一定的存储容量。
3. 节点必须有管理队列的能力。

### 2.5.3 波分多路复用

波分多路复用是一种光纤传送技术，它在一定的带宽上将输入的光信号调制在特定的频率上，然后将调制后的信号复用在一根光纤上。复用后的信号经过传送后到达连接的远端，再经过分离或解复用得到不同的波长，然后由不同的检测器将各自的光信号转换成电信号，或者直接获取各自的波长信号并将它们连接到其他 WDM 线路上。图 2.26 显示了波分多路复用的工作原理。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.26-波分多路复用.3cn2e1z0yes0.jfif" alt="波分多路复用">
    <br>
    图2.26 波分多路复用
</div>

### 2.5.4 码分多路复用

码分多路复用（CDM）就是根据码型结构的不同来实现信号分割的多路复用，也称为码分多址复用（CDMA）。在 CDMA 系统中所有用户使用同一频率，占用相同的带宽，各用户可以同时发送和接收信号，且各用户的不同信号用各自不同的地址码序列来区分，或者说靠信号的不同波形来区分。CDMA 具有抗干扰能力强、保密性好、灵活性好等特点。

在 CDMA 中，每比特时间被分成 $m$ 个短的时间段，称为**码片**（chip）。每个站点被指定一个唯一的 $m$ 位码片序列。当发送比特 1 时，站点就发送其码片序列；当发送比特 0 时，站点就发送其码片序列的反码。

## 2.6 传统数据交换技术

**交换**是在两个或多个设备之间建立临时连接，将多条物理链路连接在一起，在两个设备之间形成一条临时通信路径，使得没有物理链路直接连接的两个或多个设备之间能够通信。

一个交换网络由一系列称为**交换机**的结点相互连接而成。交换机具有在连接到其上的两个或多个设备之间建立临时连接的能力。

传统的交换方式有 3 种：电路交换、报文交换、分组交换。

### 2.6.1 电路交换

电路交换是在两个设备之间创建一条临时的物理连接，可以把电路交换机看做一个多路开关，如图 2.27 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.27-电路交换.6u28cds8ogg0.png" alt="电路交换">
    <br>
    图2.27 电路交换
</div>

电路交换的特点是在通信开始之前，要在两个通信设备之间建立起一条完全被通信双方占用的物理通路。其过程包括以下 3 个步骤：

1. 电路建立。从源站点出发，逐段寻找可以占用的链路，一直到把目的站点连通为止。
2. 数据传输。
3. 电路拆除。

### 2.6.2 报文交换

报文交换又称为存储转发、消息交换。它的基本原理是在报文的传输过程中，由网络的中间节点将报文暂时存储起来，检查它的正确性和完整性，然后再发往下一个节点。

缺点：在报文交换中，整个报文是作为一个整体来处理的。由于报文较长，一般用外存储器来暂存报文。由于报文交换要在每个中间节点对整个报文进行差错校验，因此必须等到整个报文到达后才可能被转发。如果再考虑到负载较重时的排队时间和外存储器中的存储时间，报文传输的延迟相当大。

由于以上缺点，报文交换技术已逐渐被淘汰。

### 2.6.3 分组交换

分组交换又称包交换。在分组交换中，较长的报文被分为较短的数据单元，然后每个数据单元被加上一些通信控制信息等内容，形成一个通信包。通信时以包为单位发送、存储和转发。信息包包含数据和包头，包头由通信控制信息（如地址和优先级）、差错控制信息等组成。

信息包长度比报文短得多，因此可以在中间节点的主存队列中存储，而不必访问外存。而且只要整个信息包到达后就可以转发，而不必等待很长的报文全部到达。这样就大大缩短了信息传输过程中的延迟时间。

分组交换与电路交换相比，有如下优点：

1. 传输链路的使用效率较高。两个节点之间的链路可以被许多站点频繁地交替使用，即多个通信可以共享一条通信链路。
2. 由于信息可在中途存储，因此分组交换在开始通信前可以不要求接收端做好准备，也不占用两端的全部链路。
3. 当网络通信负载很重时，电路交换网会发生阻塞现象；而分组交换网络只会使延迟变长，在良好的流量和拥塞控制下不会发生阻塞。
4. 采用分组交换的网络可工作于广播和多点播送的方式，一个站点发送的信息能被许多站点接收，而电路交换网络无此能力。
5. 在分组交换网络中由于中间节点具有存储功能，中间节点就可以对所传输的信息进行校验，同时可提供速率转换、码制转换和格式转换等服务。因此分组交换网络具有提供多种通信设备互连的灵活性。

分组交换方法有两种：数据报、虚电路。

#### 2.6.3.1 数据报

在分组交换的数据报方法中，包称为数据报，在传输中每个包都将独立于其他包进行处理。即使每个包仅是一次多包传输中的一个，该包也被当做是独立的包进行处理。

图 2.28 显示了数据报方法是如何将 4 个数据报从站点 A 传送到站点 F 的。在这个例子中，所有 4 个数据报属于同一个通信，但是可能通过不同的路径到达它们的目的地。这种方法会导致属于同一次传输的数据报次序颠倒地到达目的地，给数据报进行重新排序的任务可以由网络层的上层（即传输层）来完成。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.28-数据报方法.14y0stwlsvy8.png" alt="数据报方法">
    <br>
    图2.28 数据报方法
</div>

在使用数据报技术的网络中，任何一条链路可以同时为多对设备之间的通信服务。

#### 2.6.3.2 虚电路

在分组交换的虚电路方法中，虚电路是由分组交换通信所提供的面向连接的通信服务。在两个节点或应用进程之间建立起一个逻辑上的连接或虚电路后，就可以在两个节点之间依次传送每个分组，接收端收到分组的顺序必然与发送端的发送顺序一致，因此接收端无须负责在接收分组后重新进行排序。发送者和接收者之间的路径在数据传输之前就被选定，当数据传输开始时，所有属于这次传输的包将一个接一个地沿这条路径传送。

电路交换和虚电路之间的区别是，电路交换在端用户层上使用了复用，但在交换机上并没有使用任何复用，因此电路交换是独占的；而虚电路方法中则可以在交换机中使用复用，所以任何一条链路可以同时为多对设备之间的通信服务。

目前，虚电路以两种形式实现：交换型虚电路（SVC）、永久性虚电路（PVC）。

在交换型虚电路中，每条虚电路在需要时被创建，而且仅仅在这次通信交换的过程中存在。图 2.29 描述了交换型虚电路的特点。主机 H1 和主机 H4 要交换信息，于是，主机 H1 发起一个虚呼叫，即发送一个特定格式的包到主机 H4，要求进行通信，同时寻找一个合适的路由。若主机 H4 同意进行通信，就给主机 H1 肯定的应答，然后就可以开始传输数据了。假设找到的路径为 H1 → A → B → D → H4，则这条路径就是所建立的虚电路 VC~1~，以后要进行的数据传输都沿这条虚电路进行。数据传输完毕后，还要把虚电路拆除。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.29-交换型虚电路.6pi6v7fxba00.png" alt="交换型虚电路">
    <br>
    图2.29 交换型虚电路
</div>

一对设备之间的两次通信所建立的虚电路可以是相同的，也可以根据网络状况的不同而建立不同的虚电路。

在采用虚电路的情况下，仅在建立虚电路时需要目的地址，进行数据传送时每个包不需要携带完整的目的地址，而仅需要一个虚电路的号码标识。这就减少了包的控制信息，减少了额外开销。

永久性虚电路类似于租用线路。在这种方法中，两个用户之间存在一条相同的虚电路，该电路是专门提供给特定用户的，这条虚电路总是建立好的，因此它的使用不需要连接建立和连接终止过程。两个 PVC 用户请求连接时总是获得相同的路径。

## 2.7 错误检测编码

数据传输中的错误可分为 3 种类型：单比特错误、多比特错误、突发错误。单比特错误是指在数据单元中只有一个比特发生了改变，多比特错误是指数据单元中两个或两个以上的不连续比特发生了改变，突发错误是指数据单元中两个或两个以上连续的比特发生了改变。

只能检测出错误，而不知道哪些比特发生了错误的冗余码称为检测码。常用的检错码有：奇偶校验码、循环冗余校验码、检查和。

既能检测出错误，又能知道哪些比特发生了改变，进而能纠正错误的冗余码称为纠错码。常用的纠错码是海明码。

编码效率（或称为传信率）是指数据信息在整个发送信息中的比重。

### 2.7.1 奇偶校验码

奇偶校验计算数据单元中为 1 的比特数，再增加一个附加比特位，使得 1 的个数为偶数（偶校验）或奇数（奇校验）。该附加的比特位叫做奇偶位。

设 $m$ 位数据单元 $b_1b_2\cdots b_{m-1}b_m$，$r$ 为奇偶位。采用偶校验时有
$$
r=b_1\oplus b_2\oplus\cdots\oplus b_{m-1}\oplus b_m
$$

采用奇校验时有
$$
r=b_1\oplus b_2\oplus\cdots\oplus b_{m-1}\oplus b_m\oplus 1
$$

奇偶校验码可分为 3 种：垂直（纵向）奇偶校验、水平（横向）奇偶校验、水平垂直（纵横）奇偶校验。

#### 2.7.1.1 垂直（纵向）奇偶校验

在垂直（纵向）奇偶校验中，将整个待发送的信息块分成大小相等的若干信息单元，在每个信息单元上都增加一个校验位。如图 2.30 所示，要发送的数据块为 28 比特，每 7 比特是一个数据单元，对每个数据单元加一位偶校验位。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.30-垂直（纵向）奇偶校验.1gx3ik93tb28.png" alt="垂直（纵向）奇偶校验">
    <br>
    图2.30 垂直（纵向）奇偶校验
</div>

垂直（纵向）奇偶校验可以检测数据单元中所有的单比特错误。只有当发生错误的位数是奇数个比特时，它才能检测出多比特错误和突发错误。

#### 2.7.1.2 水平（横向）奇偶校验

在水平（横向）奇偶校验中，将整个要发送的信息块分成大小相等的若干信息单元，对所有信息单元的对应位（所有第一位、所有第二位等）分别进行奇偶校验，所有的校验位又组成了一个新的信息单元，并附加在信息块的最后。如图 2.31 所示，所要发送的 4 个信息单元的对应位作偶校验，所有的校验位又组成了一个新的信息单元（图中阴影部分），并附加在 4 个信息单元之后。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.31-水平（横向）奇偶校验.6t2s90m681c0.png" alt="水平（横向）奇偶校验">
    <br>
    图2.31 水平（横向）奇偶校验
</div>

水平（横向）奇偶校验不但可以检测到数据块内各数据单元同一位上的奇数个错误，还可以检测到单个数据单元内的所有突发错误。

#### 2.7.1.3 水平垂直（纵横）奇偶校验

同时进行水平奇偶校验和垂直奇偶校验就构成了水平垂直奇偶校验。如图 2.32 所示，对所传送的 4 个信息单元先做垂直奇偶校验，然后对 4 个单元的对应位做水平奇偶校验。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.32-水平垂直（纵横）奇偶校验.2wm9ihhk5qg0.png" alt="水平垂直（纵横）奇偶校验">
    <br>
    图2.32 水平垂直（纵横）奇偶校验
</div>

水平垂直奇偶校验不仅能发现所有一位、二位和三位的错误，还能发现某一数据单元内的奇数个错误或该数据块内所有数据单元相同位上的奇数个错误。除了数据块中偶数个数据单元中偶数个相同位发生错误不能被检测外，其他错误都能被检测。

### 2.7.2 循环冗余校验码（CRC）

如果把一个二进制码字的各位看做是一个多项式的系数，那么一个 $n$ 位码字 $U=U_{n-1}U_{n-2}\cdots U_1U_0$ 可以表示成一个多项式 $U(x)=U_{n-1}x^{n-1}+U_{n-2}x^{n-2}+\cdots+U_1x+U_0$，$U(x)$ 称为 $U$ 的多项式。

产生一个循环冗余码需要以下几个步骤：

1. 约定一个生成多项式 $G(x)$，设其最高阶次为 $m$。
2. 设待发送的信息单元为 $n$ 位的 $U$，其对应的多项式为 $U(x)$，用 $U(x)\cdot x^m$ 除以生成多项式 $G(x)$（注意：除法按模 2 运算法则），得到一个余式 $R(x)$。
3. 设余式 $R(x)$ 对应的 $m$ 位二进制码为 $R$，将 $R$ 放在 $U$ 之后就构成了循环冗余校验码。

例如，约定的生成多项式为 $G(x)=x^4+x^3+1$，其最高阶次为 4。要发送的信息单元为 $U=1101011$，其对应的多项式 $U(x)=x^6+x^5+x^3+x+1$，$U(x)\cdot x^4=x^{10}+x^9+x^7+x^5+x^4$。$U(x)\cdot x^4/G(x)$ 所得的余式为 $R(x)=x^3+x$，$R(x)$ 所对应的 4 位二进制码 $R=1010$。将 $R$ 放在 $U$ 之后就构成了循环冗余校验码 11010111010。

循环冗余校验码也可用对应的二进制数除法获得，对应的步骤为：

1. 得到生成多项式 $G(x)$ 对应的二进制码为 $G$，其位数为 $m+1$。
2. 在要发送的信息码 $U$ 后面补 $m$ 个 0，形成码字 $U'$，用 $U'$ 除以 $G$，得余数 $R$。这里的除法采用模 2 法则，即 $0-0=0$、$0-1=1$、$1-0=0$、$1-1=0$，无借位。
3. 将 $R$ 放在 $U$ 之后就构成了循环冗余校验码。

例如，上面的例子中，生成多项式为 $G(x)=x^4+x^3+1$，$m=4$，$G=11001$，要发送的信息单元为 $U=1101011$，补 4 个 0 后 $U'=11010110000$。余数可以用图 2.33 所示的二进制除法获得。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.33-二进制除法.4xhjirunnz80.png" alt="二进制除法">
    <br>
    图2.33 二进制除法
</div>

接收方将收到的数据块除以生成多项式所对应的二进制码 $G$，如果所得到的余数为 0，则是正确的；如果所得到的余数不为 0，则是错误的。这里的除法也必须采用模 2 法则，收发两端采用相同的生成多项式。

常见的生成多项式有：

1. CRC-12：$x^{12}+x^{11}+x^3+x+1$。
2. CRC-16：$x^{16}+x^{15}+x^2+1$。
3. CRC-ITU：$x^{16}+x^{12}+x^5+1$。
4. CRC-32：$x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^8+x^7+x^5+x^4+x^2+x+1$。

如果仔细选择生成多项式 $G(x)$，使得 $x$ 是它的因子而 $x+1$ 不是，并且该生成多项式的最高阶次为 $r$，循环冗余校验码可以检测以下错误：

1. 所有奇数位的突发性错误。
2. 所有长度小于 $r$ 的突发性错误。
3. 以 $\dfrac{2^{r-1}-1}{2^{r-1}}$ 的概率检测出所有长度为 $r+1$ 的突发性错误。
4. 以 $\dfrac{2^r-1}{2^r}$ 的概率检测出所有长度大于 $r+1$ 的突发性错误。

### 2.7.3 检查和

在发送方将要发送的整个数据单元分成大小都为 n 比特的若干段，然后将这些分段采用反码加法算法加在一起，得到一个 n 比特长的结果。该结果取反后得到一个 n 比特长的检查和，将检查和当做冗余位加在原始数据单元的末尾，随原始数据单元一起发送给接收方。

接收方按照发送方的方法将整个数据块分成大小为 n 的若干段，其中最后一段为检查和，然后将这些分段采用反码加法算法加在一起，得到一个 n 比特长的结果。如果结果为 n 个 1 则传输正确，反之则是错误的。

图 2.34 表示了 4 个 7 位分段的检查和如何生成以及如何校验的过程。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图2.34-检查和.7bf31bdtog80.png" alt="检查和">
    <br>
    图2.34 检查和
</div>

# 3 物理层

物理层包含那些在物理媒介上传输比特流所必须具备的功能，它监管比特流转换为电磁信号并通过媒体传输的过程。

物理层要解决以下问题：

1. 线路配置。
2. 数据通信模式。
3. 拓扑结构。
4. 信号。即在信息传输中使用什么样的信号，如电信号、光信号或微波信号等。
5. 编码。即在可用的信号系统中如何表示 0、1 比特。
6. 接口。即使用什么样的接口部件。
7. 媒体。即数据传输的物理环境是什么。

## 3.1 物理层功能

物理层是 OSI 参考模型的第一层，是整个开放系统的基础。

物理层为设备之间的数据通信提供传输媒体及互连设备，尽可能地屏蔽物理设备、传输媒体和通信手段的不同，使数据链路层感觉不到这些差异，为数据传输提供可靠的环境。

物理层的主要功能是为数据端设备提供传送数据的通路，数据通路可以是一个物理媒体，也可以是多个物理媒体连接而成。它定义了物理连接的机械特性、电气特性、功能特性和规程特性。

1. 机械特性指明接口所用接线器的形状和尺寸、引脚数目和排列、连接器位置、电缆长度、导线数目、固定和锁定装置等。
2. 电气特性指明在接口电缆各条线上出现的电压的范围，接收器和发送器的电路特性，最大数据传输率等。
3. 功能特性指明某条线上出现的某一电平的电压表示何种意义。
4. 规程特性指明对于不同功能的各种可能事件的出现顺序。

## 3.2 物理层接口

在数据通信中涉及 4 个基本功能单元，通信网络两端各有一个数据终端设备（Data Terminal Equipment，DTE）和一个数据电路终接设备（Data Circuit-terminating Equipment，DCE）。DTE-DCE 接口就是物理层接口。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图3.1-DTE-DCE接口.6719h9s41ys0.png" alt="DTE-DCE接口">
    <br>
    图3.1 DTE-DCE接口
</div>

数据终端设备（DTE）是具有数据处理能力及发送和接收数据信息能力的设备，可以是一台终端、计算机、打印机、传真机和处理数据的设备。

数据电路终接设备（DCE）是能够通过网络发送和接收模拟或数字信号数据的设备。常用的数据电路终接设备是调制解调器。

DTE 一般不直接连接网络，它通过一台 DCE 进行通信。DTE 和 DCE 的连接称为 DTE-DCE 接口。在任何一个网络中，一个 DTE 产生数字数据并把它传送给 DCE，DCE 将这些数据转化成可以在传输媒体上传输的格式，并将转化后的信号发送给网络上的另一个 DCE。第二个 DCE 从线路上接收信号，将信号转化为与它相连的 DTE 可用的格式，然后将信息转发给与它相连的 DTE。

DTE-DCE 接口的标准就是物理层协议。物理层的接口有 4 个方面的特性要反映在物理层协议中，即机械特性、电气特性、功能特性和规程特性。

## 3.3 传输介质

信息最终要转变成信号才能传输。用于传输信号的介质分为有线介质和无线介质。有线介质包括双绞线、同轴电缆和光纤等。无线介质包括地面微波、卫星微波、红外线等。

### 3.3.1 双绞线

双绞线（Twisted Pair，TP）由扭在一起的两根绝缘铜线组成。双绞线通常用于传输平衡信号，也就是说，每根导线都有电流，但信号的相位差为 180°。外界电磁干扰给两个信号带来的影响将相互抵消，从而使信号不会迅速衰退。螺旋状的结构有助于抵消电流流经导线过程中有可能增大的电容。

双绞线电缆有两种类型：非屏蔽双绞线电缆、屏蔽双绞线电缆。

非屏蔽双绞线（Unshielded Twisted Pair，UTP）电缆是由塑料外皮包起来的一对或多对双绞线组成。EIA 按照电气性能将非屏蔽双绞线划分为 8 种类型：1 类、2 类、3 类、4 类、5 类、超 5 类、6 类及超 6 类。类型数字越大版本越新，技术更先进，带宽也更大。

UTP 通常以 UTP 连接器连接到网络设备。UTP 连接器分为阴性的（插座）或是阳性的（插头）。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图3.2-双绞线.2dvvu1wx8p7o.png" alt="双绞线">
    <br>
    图3.2 双绞线
</div>

屏蔽双绞线（Shielded Twisted Pair，STP）电缆是在每一对双绞线外都有一层金属箔膜或是金属网格包装，这层包装使电磁噪声不能穿越进来。将每一对双绞线屏蔽起来能消除大多数的串线干扰。

STP 使用和 UTP 一样的连接器，但屏蔽层必须接地。STP 比 UTP 成本高，但是对噪声有更好的屏蔽作用。

### 3.3.2 同轴电缆

同轴电缆（Coaxial Cable）分为 4 层。第一层在最里层，是一根铜质或铝质的裸线；第二层是绝缘体，它包围着最里层的裸线，同时隔离最里层和第三层；第三层（屏蔽层）是金属箔膜或是金属网格，可以起到屏蔽作用，保护裸线免受电磁干扰；第四层是起保护作用的塑料外皮。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图3.3-同轴电缆.4mrka4ircb60.jfif" alt="同轴电缆">
    <br>
    图3.3 同轴电缆
</div>

各种同轴电缆根据其无线电波管制（Radio Government，RG）级别来归类。每一种无线电波管制编号表示了一组特定的物理特性，包括内层导体的线路规格、内层绝缘体的厚度和类型、屏蔽层的组成以及外层包装的规格和类型。

### 3.3.3 光缆

光缆（optical fiber cable）由玻璃或塑料制成，以光波形式传播信号。

光缆的核心是光导纤维（简称光纤），它是一种能传播光波的介质。它由三层构成，最里层是纤芯（由芯材和填充材料构成），由玻璃或塑料制成；中间是包层，最外面是保护层。光信号只能在纤芯中传播。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图3.4-光缆.2oxvj1kjvh80.png" alt="光缆">
    <br>
    图3.4 光缆
</div>

光纤相对于双绞线和同轴电缆来说具有更高的带宽，由于采用的是光信号，能很好地屏蔽电磁信号的干扰。

光缆信道有两种传播光的形式：多模传播和单模传播。多模传播又可进一步分成两种类型：阶跃模式和渐变模式。与此对应，光纤的种类有多模阶跃光纤、多模渐变光纤和单模光纤。

在多模传播模式中，多束光线在芯材中通过不同路径传播。这样的光纤称为多模光纤。

在多模阶跃光纤中，芯材的密度从中心到边缘是一致的，光线在芯材中是直线传播的。在边界上，由于填充材料的密度突然降低，光线反射回芯材中。阶跃就是指这种密度的突然降低。图 3.5 显示了多模阶跃传播形式，不同入射角度的光线沿着不同的路径传播，到达终点的距离就不同，所需的时间也不同。为了不使后一脉冲产生的光波追上前一脉冲产生的光波，光线的长度和数据速率都要受到限制。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图3.5-多模阶跃传播.5kv43vv3g040.jfif" alt="多模阶跃传播">
    <br>
    图3.5 多模阶跃传播
</div>

在多模渐变光纤中，芯材的中心密度最大，并向外逐渐变小，到边界时最小。光信号在芯材的中心输入。只有水平光纤在通过恒定密度的中心时保持直线传播，其他角度的光线通过密度不断改变的介质，每一次密度改变都使得光线逐渐变弯成一条曲线。图 3.6 显示了多模渐变传播方式。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图3.6-多模渐变传播.2op41t7r36y0.jfif" alt="多模渐变传播">
    <br>
    图3.6 多模渐变传播
</div>

单模光纤采用阶跃材质和高度集中的光源，使得发出的光线限制在非常接近水平的很小的范围内。采用极低的折射率，使得全反射角接近 90°，从而使得传播的光线基本是水平的。在这种情况下，不同入射角度的光线几乎同时到达目的地。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图3.7-单模传播.2oz5lyqvioo0.jfif" alt="单模传播">
    <br>
    图3.7 单模传播
</div>

为实现数据的传输，收发双方要安装光纤收发器。连接方式如图 3.8 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图3.8-光纤收发器的连接.e3aw8mki34w.png" alt="光纤收发器的连接">
    <br>
    图3.8 光纤收发器的连接
</div>

光纤收发器的光源可以是一个发光二极管（LED）或是注入型激光二极管。LED 便宜一些，但它只能发射发散的光线，所以 LED 只适用于短距离传输。激光具有高度的集中性，入射角的范围很小，所以适合于长距离传输。

### 3.3.4 无线传输介质

大气和外界空间是提供电磁信号传播的无线型介质，它们不为信号提供导向，这种传输形式称为无线传输。

无线传输有两种基本方法：定向的和全向的。一般来说，信号频率越高，越有可能将其聚焦成定向的电磁波束；使用较低频率传输的信号是全向的。

无线传播的电磁信号主要有地面微波、卫星微波和红外线。

卫星信道的特性：

1. 由于长距离传输，在两个收发的地面站之间会有大约 1/4 s 的传输延迟。
2. 卫星微波具有广播性质，很多地面站能把信号传给卫星，来自卫星的传输信号也能被很多地面站接收到。

红外线不能贯穿墙壁，而微波信号可以贯穿墙壁。

## 3.4 物理层互连设备

网络互连设备又称为中继系统。如果某个中继系统在进行信息转发时与其他系统共享第 n 层协议，但是不共享第 n+1 层协议，那么这个中继系统就称为第 n 层中继系统。

网络互连设备分为 4 大类：中继器、网桥、路由器、网关。每一种设备分别与 OSI 模型中不同层的协议交互作用。

物理层的网络互连设备是**中继器**（repeater）。中继器仅作用在信号的电气部分上，因而仅运行在 OSI 模型的物理层上。中继器的作用是在物理层中实现透明二进制比特复制，以补偿信号的衰减。

中继器仅允许扩展网络的物理层，它不以任何方式改变网络的功能。在图 3.9 中，通过中继器（重发器）连接在一起的两个网段实际上是一个网络。如果站点 A 发送一帧到站点 B，所有站点（包括 C 和 D）都将接收到这个帧，就像中继器不存在一样。所不同的是，网络覆盖的范围更大了。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图3.9-使用中继器对物理层进行扩展.30o37xmjbms0.png" alt="使用中继器对物理层进行扩展">
    <br>
    图3.9 使用中继器对物理层进行扩展
</div>

中继器是一个再生器，而不是增幅器。它不放大信号，而是重新生成信号。如图 3.10 所示，中继器将受损的信号重新还原成原始的形式。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图3.10-使用中继器使信号再生.17fq0y6yvy0w.png" alt="使用中继器使信号再生">
    <br>
    图3.10 使用中继器使信号再生
</div>

集线器（hub）属于数据通信网络中的基础设备，它和双绞线等传输介质一样，是一种不需要任何软件支持或只需要很少软件管理的硬件设备，广泛应用于各种场合。集线器工作在局域网（LAN）环境，应用于 OSI 模型的物理层，因此又被称为物理层设备。集线器内部采用了电器互连，当维护 LAN 的环境是逻辑总线或环装结构时，可以用集线器建立一个物理上的星状或树状网络结构。在这方面，集线器所起的作用相当于多端口的中继器。实际上集线器就是中继器的一种，其区别仅在于集线器能够提供更多的端口服务，所以集线器又叫多口中继器。

无线接入点（wireless access point）就是传统有线网络中的集线器，是组建小型无线局域网时最常用的设备。接入点相当于一个连接有线网和无线网的桥梁，其主要作用是将各无线网络客户端连接到一起，然后将无线网络接入以太网。

# 4 数据链路层

数据链路层的任务是提供两个相邻的网络节点或主机及其相连的网络节点之间的可靠通信。

数据链路层的信息传送单位是**帧**。数据链路层负责将数据单元无差错地从一个站点送达下一个相邻站点。它从网络层接收数据，并加上有意义的比特位形成头部和尾部来携带地址和其他控制信息，一个含有这些附加信息的数据单元称为帧。

数据链路层提供的主要服务功能是线路规程、差错控制和流量控制。

1. 线路规程解决 “现在该谁发送” 的问题，在通信双方之间进行一些协调工作。
2. 差错控制负责纠正错误。
3. 流量控制负责调整在某时间段内可以发送多少数据。目的是防止因发送端的发送速度超过接收端的处理速度而造成数据丢失和信道拥挤。

数据链路的建立、维持和释放称为链路管理。

## 4.1 线路规程

数据链路层的线路规程监视链路的建立，并在给定时刻分配一个具体设备进行数据传送。

线路规程可以用两种模式实现：询问/应答模式、轮询/选择模式。

### 4.1.1 询问/应答模式

当两个设备之间存在一条专用链路时，采用询问/应答（ENQ/ACK）模式。只要一条链路两头的设备级别相同，任意一个设备都可以启动一个会话过程。

询问/应答模式的工作方式为：启动方首先发送一个询问帧（ENQ）询问接收方是否可以接收数据。如果接收方已经准备好接收，必须回答一个应答帧（ACK）；如果没有准备好，必须回答一个否定应答帧（NAK）。

发送方发送一个询问帧后，有 3 种可能的情况：

1. 没有回应。如果在一定的时间期限内既没有收到应答帧也没有收到否定应答帧，启动方就假定询问帧在传输中丢失了，断开连接并重新发送一个副本。启动方通常会进行三次这样的尝试，如果三次尝试均失败，则放弃努力，断开连接。
2. 回应是否定的。如果对 ENQ 帧的回应是否定的，并且三次尝试都失败了，启动方就断开连接并在另一个时刻重新开始整个过程。
3. 回应是肯定的。如果回应是肯定的，启动方就可以随时发送数据了。一旦将所有数据发送完毕，发送系统以一个传输结束帧（EOT）结束传输。该过程如图 4.1 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.1-询问-应答线路规程.512x9gkwzl40.png" alt="询问-应答线路规程">
    <br>
    图4.1 询问-应答线路规程
</div>

### 4.1.2 轮询/选择模式

轮询/选择模式是在一个设备作为主设备，而其他设备作为从设备的拓扑结构中采用的。

一个多点连接由使用同一条传输线路的一个主设备和若干个从设备构成，所有的信息交换都必须通过主设备进行。主设备控制链路，从设备遵从其指令。必须由主设备决定在给定时刻哪一个设备有权使用信道，因此主设备是会话的发起者。如果主设备希望接收数据，它将逐个询问从设备是否有数据发送，这个功能称为轮询。如果主设备希望发送数据，它告知目标从设备准备好接收数据，这个功能称为选择。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.2-多点连接.3p8hr3zjspw0.png" alt="多点连接">
    <br>
    图4.2 多点连接
</div>

在多点连接中，链路上每个设备都有一个名字或地址用于自身标识。轮询/选择协议对每一帧都有一个地址进行标识，指明它是从一个从设备而来，或是到一个从设备去。在任何一次传输中，这个地址会在每一帧的特定部分出现，这一部分叫做地址域。

多点拓扑在多个设备间共用一条链路，所以链路上的任何一帧都可以被链路上的任何一个设备接收。当帧沿着链路传输时，每个设备都检验其中的地址域，只有当一个设备发现该地址是自身时才打开该帧并读取数据。

每当主设备有数据发送时就采用选择模式。主设备产生并发送一个选择帧（SEL），并在帧的地址域中填入接收数据的从设备的地址。如果从设备是激活的并且正在运行，其地址和选择帧地址域中的地址相同，它向主设备返回一个应答帧，然后主设备就向该从设备发送一个或多个数据帧。图 4.3 展示了选择过程。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.3-多点选择.2m7idaxei440.png" alt="多点选择">
    <br>
    图4.3 多点选择
</div>

轮询功能是主设备请求从设备进行传输。在没有接到请求前，从设备不允许发送数据。当主设备准备好接收数据时，它必须依次询问从设备是否有数据发送。被询问的设备如果有数据发送则发送数据帧，如果没有要发送的数据则返回否定应答帧。如果主设备收到的回应是否定应答帧，主设备就轮询下一个从设备，直到它发现一个要发送的设备为止；当回应是数据帧，主设备读入该帧并向从设备返回一个应答帧来确认已经接收。

有两种终止信息交互的方法：

1. 从设备将所有数据发送完毕，并以一个传输结束帧结束传输。
2. 主设备发出“时间到”信息，根据协议的不同和消息长度的不同采用不同的终止方法。

一旦完成了传输，主设备就可以对其他从设备进行轮询。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.4-多点轮询.42b1w6wiv4u0.png" alt="多点轮询">
    <br>
    图4.4 多点轮询
</div>

## 4.2 流量控制与差错控制

流量控制是一组过程，这组过程用来告诉发送方在等待接收方的应答信号之前最多可以传送多少数据。流量控制有两个要点：

1. 数据流不能使接收方过载。每个接收设备都有一块存储器，叫做缓冲区，用于存放没来得及处理的数据帧。如果缓冲区将满，接收方必须能够通知发送方暂停传输，直到接收方又能接收数据。
2. 应答。随着数据帧的到来，接收方对它们进行应答。如果一个帧到达时已经被破坏，接收方发送一个否定应答帧。

在数据链路层，差错控制主要指错误检测和重传方法。在一个帧中出现任何一个错误，接收方就返回一个否定应答帧，出错的帧就被发送方重新传送，这个过程称为自动重复请求（ARQ）。数据被重传的情况有三种：帧破坏、帧丢失和应答帧丢失。

流量控制和差错控制是结合在一起实现的，共有两种实现流量控制和差错控制的协议：停止等待协议、滑动窗口协议。

### 4.2.1 停止等待协议

#### 4.2.1.1 停止等待协议中的流量控制

在停止等待协议中，发送方每发送一帧后就等待一个应答帧，只有当接收到应答帧之后，发送方才发送下一帧。这种发送和等待交替的过程不断重复，直到发送方发送一个传输结束帧。如图 4.5 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.5-停止等待协议.62upmkr1o280.png" alt="停止等待协议">
    <br>
    图4.5 停止等待协议
</div>

停止等待协议的优点在于简单，在下一帧发送之前每一帧都校验并进行应答。缺点是效率低，在线路上总是只有一帧，如果设备之间的距离很长，在每帧之间等待应答帧所花费的时间很长。

#### 4.2.1.2 停止等待协议的差错控制

为了实现差错控制，停止等待协议还必须具备以下要求：

1. 发送设备在收到最近帧的应答消息前必须保留该帧的备份。保留备份使得发送方可以重新发送丢失或损坏的帧，直到被正确接收为止。
2. 为识别各帧，数据帧和应答帧都必须交替标识为 0 和 1。一个标号为 1 的数据帧被一个标号为 0 的应答帧所确认，说明当前接收方已经接收了数据帧 1，期望接收数据帧 0。如果接收方收到了两个相邻的数据帧且标号相同，说明接收方收到了一个重复帧，应当丢弃一个重复帧。
3. 如果在数据帧中发现一个错误，接收方就返回一个否定应答帧，通知发送方重新发送最近的一帧。否定应答帧不编号。
4. 发送设备安装一个定时器。如果在规定时间内不能收到预期的应答信息，发送方就假定最近一帧数据在传输中丢失，并再次发送它。

图 4.6 展示了停止等待自动重复请求（ARQ）处理 3 种错误的情况。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.6-停止等待自动重复请求.4sgd9kmh62g0.png" alt="停止等待自动重复请求">
    <br>
    图4.6 停止等待自动重复请求
</div>

图 4.6(a) 是帧破坏的情况。如果数据在传输过程中出现了差错，B 站点通过循环冗余校验发现错误，于是 B 站点向 A 站点发送否定应答帧。站点 A 收到否定应答帧后，就知道刚才发送的帧出了错，于是重发此帧，直到收到 B 站点发来的确认帧为止。如果线路质量太差，则 A 在重发若干次后即不再重发，并向上级报告。

图 4.6(b) 是帧丢失的情况。这时 B 站点不会向 A 站点发送任何应答帧，如果 A 站点要等待 B 站点的应答帧，将永远等待。为此可在 A 站点上设置一个定时器，若超时时间到时仍收不到 B 的任何应答帧，则站点 A 就重传这一帧。

图 4.6(c) 是应答帧丢失的情况。应答帧丢失时，A 站点不会收到应答帧，等待超时后重发数据帧。此时会出现重复帧的问题，为此必须使每个数据帧带上一个编号，若连续收到编号相同的帧就表明出现了重复帧，这时必须丢弃重复帧。另一方面，B 还应向 A 发送确认帧，这时 B 知道上次发送的确认帧丢失了。

#### 4.2.1.3 停止等待协议的效率

在无差错的情况下完成一帧的发送所需的最短时间 $W_\text{T}$ 为：
$$
W_\text{T}=t_\text{I}+2t_\text{P}+2t_\text{Proc}+t_\text{S}
$$

其中，$t_\text{I}$ 是发送一个数据帧的时间，$t_\text{S}$ 是发送一个应答帧的时间，$t_\text{P}$ 是电信号在物理链路上的传播延迟，$t_\text{Proc}$ 是收到一帧的处理时间和一个帧的形成时间，如图 4.7 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.7-停止等待协议完成一帧发送所需的最短时间.2ijrjzstbog0.png" alt="停止等待协议完成一帧发送所需的最短时间">
    <br>
    图4.7 停止等待协议完成一帧发送所需的最短时间
</div>

信道的利用率是信道被占用的时间与总时间之比。无差错时信道的利用率为：
$$
F=\frac{t_\text{I}}{W_\text{T}}
$$

有效数据传送速率是单位时间内可传送的有效数据位数。

无差错时，发送一帧的最小时间间隔为 $W_{\text{T}}$，记为 $t_\text{W}$。有差错时，假设出现差错的概率为 $p$，正确发送一帧的平均时间间隔为 $t_\text{V}$ 。为了简化分析，假定应答帧不出错，允许发送端重发的次数不受限制。在上述条件下，正确发送一帧的平均时间间隔 $t_\text{V}$ 为：
$$
\begin{equation*}
\begin{split}
    t_\text{V}
    &=(1-p)t_\text{W}+p(1-p)\cdot 2t_\text{W}+p^2(1-p)\cdot 3t_\text{W}+\cdots +p^{n-1}(1-p)\cdot nt_\text{W}+\cdots\\
    &=(1-p)t_\text{W}\sum_{n=1}^\infty np^{n-1}\\
    &=(1-p)t_\text{W}\frac{1}{(1-p)^2}\\
    &=\frac{t_\text{W}}{1-p}
\end{split}
\end{equation*}
$$

当传输差错率 $p$ 增大时，$t_\text{V}$ 也随之增大。当无差错时，$p=0$，$t_\text{V}=t_\text{W}$。

令 $\lambda_\text{max}$ 为系统最大吞吐量（即每秒成功发送的最大帧数），则
$$
\lambda_\text{max}=\frac{1}{t_\text{V}}=\frac{1-p}{t_\text{W}}
$$

令 $a=t_\text{W}/t_\text{I}>1$，则有
$$
\lambda_\text{max}=\frac{1-p}{t_\text{W}}=\frac{1-p}{at_\text{I}}
$$

由之前的分析可知，$t_\text{W}=W_\text{T}=t_\text{I}+2t_\text{P}+2t_\text{Proc}+t_\text{S}$。为简化分析，将处理时间 $t_\text{Proc}$ 并入传播延迟 $t_\text{P}$（$t_\text{Proc}\ll t_\text{P}$），同时忽略应答的发送时间，则 $t_\text{W}\approx t_\text{I}+2t_\text{P}$。所以，正确传送一帧的最短时间主要取决于帧的大小及发送方和接收方之间的距离。

理想情况下，即在不考虑流量控制和差错控制的情况下，系统发送一帧的时间为 $t_\text{I}$。在此情况下的系统的吞吐量称为系统的极限吞吐量。将系统的极限吞吐量记为 $M$，则
$$
M=\frac{1}{t_\text{I}}
$$

把系统的最大吞吐量与极限吞吐量之比称为系统的传输效率。记系统的传输效率为 $\rho$，则
$$
\rho=\frac{\lambda_\text{max}}{M}=\frac{(1-p)/at_\text{I}}{1/t_\text{I}}=\frac{1-p}{a}
$$

当 $a$ 越大，系统的传输效率越低。也就是说，当传播延迟 $t_\text{P}$ 越大时，使用停止等待协议的系统效率就越低。反之，当 $a$ 越小，系统的传输效率越高。也就是说，当传播延迟 $t_\text{P}$ 越小时，使用停止等待协议的系统效率就越高。

### 4.2.2 滑动窗口协议

#### 4.2.2.1 滑动窗口协议中的流量控制

在滑动窗口协议中，发送方在收到应答消息前可以发送若干帧，这意味着链路上可能同时存在多个数据帧，从而充分利用链路的传输能力。接收方使用一个应答帧来对多个数据帧的接收进行确认。

窗口是发送方和接收方存放数据帧的缓冲区。发送方窗口用于存放已经发送但未收到应答的数据帧和在收到应答帧之前可以发送的数据帧，只要发送方窗口未填满就可以在未收到应答帧的情况下继续发送数据帧。接收方窗口用于存放已被接收但未给应答的数据帧，只要接收方窗口未填满就可以在未发送应答帧的情况下继续接收数据帧。

在滑动窗口协议中，数据帧以模 n 编号，即编号从 0 到 n-1。窗口的大小是 n-1。接收方发送的应答帧编号是接收方希望收到的下一帧的编号。

发送窗口分为两部分，左边是已发送但还未收到应答信息的数据帧，右边是还未发送但可以发送的数据帧。每发送一帧，左右两部分的分界就向右移动一帧；每收到一个应答帧，整个发送窗口就向右移动若干帧，移动的距离是最后一次应答帧编号和现在收到的应答帧编号的差值（模 n）。

图 4.8 显示了一个大小为 7 的发送方滑动窗口。开始时，未发送任何数据帧，窗口是空的，窗口中的号码是可以发送的帧的编号（如图 4.8(a) 所示）。当发送方发送了 4 帧后，窗口中只剩下 3 个空位置（如图 4.8(b) 所示）。收到编号为 3 的应答帧后，说明 3 号数据帧之前的所有帧都已被正确接收，整个窗口右移 3 个帧的位置，这样被应答的帧被移出窗口，窗口增加了 3 个帧的空位置用于发送（如图 4.8(c) 所示）。最后发送方又发送了 5 个数据帧（如图 4.8(d) 所示）。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.8-发送方发送窗口.la2dlz4v7i8.png" alt="发送方发送窗口">
    <br>
    图4.8 发送方发送窗口
</div>

接收方窗口也分为两部分，左边是已经接收但还未发送应答信息的数据帧，右边是可被接收的数据帧。只有编号处于窗口内的帧才是可以被接收的帧。每接收一帧，左右两部分的分界就向右移动一帧；每发送一个应答帧，整个接收窗口就向右移动若干帧，移动的距离是最后一次应答帧编号和现在发送的应答帧编号的差值（模 n）。

图 4.9 显示了一个大小为 7 的接收方滑动窗口。开始时，未接收任何数据帧，窗口是空的，窗口中的号码是可以接收的帧的编号（如图 4.9(a) 所示）。当接收了 4 帧后，窗口中只剩下 3 个空位置（如图 4.9(b) 所示）。发送了编号为 3 的应答帧后，说明 3 号数据帧之前的所有帧都被校验位正确的，整个窗口右移 3 个帧的位置，这样被应答的帧被移出窗口，窗口增加了 3 个帧的空位置用于接收（如图 4.9(c) 所示）。最后接收方又接收了 5 个数据帧（如图 4.9(d) 所示）。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.9-接收方接收窗口.39qhwxelkxa0.png" alt="接收方接收窗口">
    <br>
    图4.9 接收方接收窗口
</div>

#### 4.2.2.2 滑动窗口协议中的差错控制

滑动窗口协议中有两种实现自动重复请求的技术：回退 n 自动重复请求、选择拒绝自动重复请求。

为解决帧丢失和损坏帧的重发问题，需要在基本的滑动窗口流量控制上增加 3 个特性：

1. 在发送出去的帧被应答信息确认前保持它们所有的备份。
2. 除应答帧外，接收方还可以发送否定应答帧以通知发送方重新发送一个损坏的帧。应答帧和否定应答帧都必须带有编号以便识别，应答帧带有期望收到的数据帧的编号，而否定应答帧带有被损坏帧的编号。在两种情况下，都是接收方期望接收的数据帧的编号。
3. 发送设备具有一个定时器来使发送方能够处理帧丢失的情况。

#### 4.2.2.3 回退n自动重复请求

在滑动窗口的回退 n 自动重复请求协议中，如果一帧丢失或损坏，从最近一次得到应答的数据帧开始，未被应答的所有帧都必须进行重传。回退 n 自动重复请求适用于接收方窗口大小为 1 的情况。

差错情况一般有 3 种：帧破坏、帧丢失、应答帧丢失。

图 4.10 显示了帧破坏的情况。设窗口大小为 5。发送方连续发送了 5 个数据帧之后，收到了应答帧 ACK3，说明数据帧 3 以前的所有帧已被正确接收，0、1、2 号帧被移出窗口之外，发送方继续发送数据帧 5。发送完数据帧 5，收到了否定应答帧 NAK3，说明数据帧 3 损坏，发送方重新发送数据帧 3 及以后的所有帧。接收方发现数据帧 3 损坏，向发送方发送 NAK3，并拒绝接收其后面的帧，直到正确收到数据帧 3，才可以继续接收后面的帧。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.10-回退n协议，帧破坏.14i9nc4uaw2k.png" alt="回退n协议，帧破坏">
    <br>
    图4.10 回退n协议，帧破坏
</div>

滑动窗口协议中，要求数据按顺序发送和接收。如果某一帧在传输中丢失，接收方就不能按顺序收到数据帧。图 4.11 显示了回退 n 自动重复请求协议中数据帧丢失的情况。发送方连续发送了 5 个数据帧，由于数据帧 2 在传输中丢失，接收方在收到数据帧 0 和 1 之后，收到了数据帧 3。数据帧不是按顺序接收的，于是接收方返回否定应答帧 NAK2，并丢弃数据帧 2 后面的所有帧，直到收到数据帧 2 为止。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.11-回退n协议，数据帧丢失.3ga7xpkuphk0.png" alt="回退n协议，数据帧丢失">
    <br>
    图4.11 回退n协议，数据帧丢失
</div>

图 4.12 显示了回退 n 自动重复请求协议中应答帧丢失的情况。一旦发送方发送窗口满，或者没有数据要发送了，定时器就开始计时。如果在时间限制内没有应答信息到来，发送方将最近一次应答帧之后的所有帧重新发送一次。接收方辨认出帧的重复，知道应答帧丢失，重新发送应答帧，并删除重复的帧。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.12-回退n协议，应答帧丢失.6yn5q1myflg0.png" alt="回退n协议，应答帧丢失">
    <br>
    图4.12 回退n协议，应答帧丢失
</div>

在回退 n 自动重复请求协议中，如果帧的编号范围是 0 到 n-1，则窗口的尺寸为 n-1。

如果窗口的尺寸大于 n，就会有多于 n 个未确认帧，相应地就会出现两个不同的未确认帧有相同的编号，当收到该帧的确认信息时，就无法知道是对这两帧中的哪一帧确认。

如果窗口的尺寸等于 n，就会出现失败情况。如图 4.13 所示，n=8，帧编号范围为 0 到 7，窗口尺寸为 8。在 $t_1$ 时刻，A 向 B 发送数据帧 0~7。在 $t_2$ 时刻，B 按顺序接收数据帧 0~7，并且发送 ACK0。但是，应答帧在传输中丢失了，A 收不到应答帧。在 $t_3$ 时刻，A 超时，重发数据帧 0~7。在 $t_4$ 时刻，B 按顺序收到数据帧 0~7，收到的数据帧的编号和期望收到的帧的编号相符，所以 B 认为是新数据帧，不认为是重复帧。在此情况下协议失败。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.13-窗口尺寸等于n，回退n协议失败.1uzznhujcnfk.png" alt="窗口尺寸等于n，回退n协议失败">
    <br>
    图4.13 窗口尺寸等于n，回退n协议失败
</div>

如果窗口尺寸等于 n-1，就不会出现上面所说的失败情况。图 4.14 所示的事件和上图相同，但这里窗口尺寸为 7。在 $t_1$ 时刻，A 向 B 发送数据帧 0~6。在 $t_2$ 时刻，B 按顺序收到数据帧 0~6，并且发送 ACK7。但是，ACK7 在传输中丢失了，A 收不到应答帧。在 $t_3$ 时刻，A 超时，重发数据帧 0~6。在 $t_4$ 时刻，B 按顺序收到数据帧 0~6，数据帧 0 不是期望收到的数据帧，所以 B 认为是重复帧。在此情况下协议成功。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.14-窗口尺寸等于n-1，回退n协议成功.7kp9rg5lbok0.png" alt="窗口尺寸等于n-1，回退n协议成功">
    <br>
    图4.14 窗口尺寸等于n-1，回退n协议成功
</div>

#### 4.2.2.4 选择拒绝自动重复请求

在选择拒绝自动重复请求中，只有特定的丢失或损坏帧被重发。接收方收到的数据帧可以是不按顺序到达的，但是应答必须是按顺序的。

选择拒绝自动重复请求与回退 n 自动重复请求有以下不同：

1. 接收设备必须具有排序的逻辑功能。接收方在发送了 NAK 帧之后，必须存储收到的所有帧，直到损坏的帧被重新收到为止。
2. 发送设备必须具有查找机制，以便发现和选择需要重传的帧。
3. 在所有重传帧被排序和所有重复帧被辨别出来并删除之前，接收方收到的所有帧都必须保存。
4. ACK 帧的编号指的是被正确接收的帧，NAK 帧的编号指的是错误或丢失的帧。

图 4.15 显示了帧破坏的情况。接收方返回 NAK2，说明数据帧 0 和 1 被正确接收，数据帧 2 有错误。发送方只重发数据帧 2，而不重发已发送的数据帧 3、4、5。接收方继续接收数据帧 3、4、5 而不是丢弃它们，但是不能对数据帧 3、4、5 作应答，因为数据帧 2 还未被正确接收。当重发的数据帧 2 到达接收方时，接收方对接收的数据帧进行排序，返回 ACK5，作为对数据帧 2、3、4、5 的应答。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.15-选择拒绝，帧破坏.15bevpd1oxj4.png" alt="选择拒绝，帧破坏">
    <br>
    图4.15 选择拒绝，帧破坏
</div>

图 4.16 显示了数据帧丢失的情况。数据帧 2 丢失了，接收方收到数据帧 3 时，会发现数据帧 2 丢失，向发送方返回 NAK2。如果丢失的是最后一帧，接收方不做任何响应，发送方当做丢失应答帧一样处理。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.16-选择拒绝，数据帧丢失.68ij5xhmbc80.png" alt="选择拒绝，数据帧丢失">
    <br>
    图4.16 选择拒绝，数据帧丢失
</div>

应答帧丢失。当发送窗口满或传输完毕时，启动定时时钟。如果在预定时间段内没有应答帧到来，发送方将尚未应答的所有帧都重传一遍。这和回退 n 协议是一样的。

如果帧的编号范围是 0 到 n-1，则发送窗口尺寸和接收窗口尺寸之和小于或等于 n。如果要求发送窗口和接收窗口大小相等，则窗口尺寸应小于或等于 n/2 。

设 n=8，发送窗口大小为 4，接收窗口大小为 5。如图 4.17 所示，在 $t_1$ 时刻，A 发送了数据帧 0~3 并等待应答。在 $t_2$ 时刻，B 收到数据帧 0~3，发送应答帧 ACK3，这时它可以移动窗口，从而可以接收 4、5、6、7、0 这 5 个数据帧。由于 ACK3 丢失，在 $t_3$ 时刻超时，A 重发数据帧 0~3。在 $t_4$ 时刻，B 收到数据帧 0，由于它在接收窗口中，认为是新帧，但它是重复帧。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.17-接收窗口尺寸太大，选择拒绝协议失败.6ajzii6evrs0.png" alt="接收窗口尺寸太大，选择拒绝协议失败">
    <br>
    图4.17 接收窗口尺寸太大，选择拒绝协议失败
</div>

如果发送窗口大小为 5，接收窗口大小为 4，协议也会失败，如图 4.18 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.18-发送窗口尺寸太大，选择拒绝协议失败.2u593mwg4tw0.png" alt="发送窗口尺寸太大，选择拒绝协议失败">
    <br>
    图4.18 发送窗口尺寸太大，选择拒绝协议失败
</div>

#### 4.2.2.5 滑动窗口协议的效率

1. 回退 n 自动重复请求协议的效率

为了简化问题的分析，不考虑应答帧的丢失。

在不出现错误时，回退 n 自动重复请求协议最快可每隔 $t_\text{I}$ 发送一帧。当出现一次错误时，损失的时间为 $t_\text{W}$。设出错概率为 $p$，则回退 n 自动重复请求协议中正确传送一帧所需的平均时间为
$$
\begin{equation*}
\begin{split}
    t_\text{V}
    &=(1-p)t_\text{I}+p(1-p)(t_\text{I}+t_\text{W})+p^2(1-p)(t_\text{I}+2t_\text{W})+p^3(1-p)(t_\text{I}+3t_\text{W})+\cdots\\
    &=(1-p)t_\text{I}\sum_{n=0}^\infty p^n+p(1-p)t_\text{W}\sum_{n=1}^\infty np^{n-1}\\
    &=\frac{(1-p)t_\text{I}}{1-p}+\frac{p(1-p)t_\text{W}}{(1-p)^2}\\
    &=t_\text{I}+\frac{p}{1-p}t_\text{W}
\end{split}
\end{equation*}
$$

令 $a=t_\text{W}/t_\text{I}$，则
$$
\begin{equation*}
\begin{split}
    t_\text{V}
    &=t_\text{I}+\frac{pat_\text{I}}{1-p}\\
    &=\frac{t_\text{I}(1-p)+pat_\text{I}}{1-p}\\
    &=\frac{t_\text{I}[1+p(a-1)]}{1-p}
\end{split}
\end{equation*}
$$

当传送差错率增大时，$t_\text{V}$ 也随之增大。当无差错时，$p=0$，$t_\text{V}=t_\text{I}$。

令 $\lambda_\text{max}$ 为系统最大吞吐量，则
$$
\lambda_\text{max}=\frac{1}{t_\text{V}}=\frac{1-p}{t_\text{I}[1+p(a-1)]}
$$

令 $M$ 为系统的极限吞吐量，则
$$
M=\frac{1}{t_\text{I}}
$$

令系统的传输效率为 $\rho$ ，则
$$
\rho=\frac{\lambda_\text{max}}{M}=\frac{(1-p)/t_\text{I}[1+p(a-1)]}{1/t_\text{I}}=\frac{1-p}{1+p(a-1)}
$$

2. 选择拒绝自动重复请求协议的效率

在不出现错误时，最快可每隔 $t_\text{I}$ 发送一帧。当出现一次错误时，损失的时间为 $t_\text{I}$。设出错概率为 $p$，则选择拒绝自动重复请求协议中正确传送一帧所需的平均时间为
$$
\begin{equation*}
\begin{split}
    t_\text{V}
    &=(1-p)t_\text{I}+p(1-p)(t_\text{I}+t_\text{I})+p^2(1-p)(t_\text{I}+2t_\text{I})+p^3(1-p)(t_\text{I}+3t_\text{I})+\cdots\\
    &=(1-p)t_\text{I}\sum_{n=0}^\infty p^n+p(1-p)t_\text{I}\sum_{n=1}^\infty np^{n-1}\\
    &=\frac{(1-p)t_\text{I}}{1-p}+\frac{p(1-p)t_\text{I}}{(1-p)^2}\\
    &=t_\text{I}+\frac{p}{1-p}t_\text{I}\\
    &=\frac{t_\text{I}}{1-p}
\end{split}
\end{equation*}
$$

#### 4.2.2.6 窗口大小的选择

如果窗口太大，会要求有足够大的缓存空间；如果窗口太小，由于传播和发送延迟，第一个应答帧返回发送方之前，发送方发送窗口中的帧已经全部发送出去，但是没有得到应答，发送方必须等待，从而影响了传输速度和传输效率。所以窗口应该选择得足够大，以保证在第一个应答帧返回到发送方之前，发送方可以继续发送。因此窗口大小 $n$ 应满足如下条件：
$$
nt_\text{I}>t_\text{W}
$$

即
$$
nt_\text{I}>t_\text{I}+2t_\text{P}+t_\text{S}
$$

由于 $t_\text{I}>t_\text{S}$，上式可以简化为
$$
nt_\text{I}>2(t_\text{I}+t_\text{P})
$$

## 4.3 HDLC通信协议

面向比特协议将传输帧看做是单个比特的连续流，通过它们在帧中的位置和与其他比特的组合模式来表达意义。1979 年，ISO 提出了高级数据链路控制（HDLC）协议。

### 4.3.1 HDLC支持的站点类型、链路配置和通信方式

HDLC 支持点对点和多点配置下的半双工和全双工模式。采用 HDLC 协议的系统可以通过它们的站点类型、链路配置和通信方式来描述。

#### 4.3.1.1 站点类型

HDLC 协议中，站点有 3 种类型：主站点、从站点、复合站点。

主站点是在点对点和多点链路配置中对链路具有完全控制权的设备。主站点发送命令到从站点，从站点对命令进行响应。

复合站点既可以发送命令也可以接收命令。复合站点是一组互相连接的对等站点中的一个，这些站点根据传输的属性和方向选择以主站点或从站点的方式工作。

#### 4.3.1.2 链路配置

链路配置是指链路上两个设备之间的关系。主站点、从站点和复合站点之间有 3 种配置方式：非平衡式、对称式、平衡式。如图 4.19 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.19-HDLC的链路配置.dpwtd9qtfk0.png" alt="HDLC的链路配置">
    <br>
    图4.19 HDLC的链路配置
</div>

非平衡式配置也称为主从配置，以一个设备为主设备，其他设备为从设备。这种主从关系在通信过程中是不会改变的。

对称式配置是指链路上的每个物理站点在不同的时刻充当不同的角色，一个时刻充当主设备，另一个时刻则充当从设备。

平衡配置是指在点对点拓扑中两个站点都是复合站点，站点之间由一条链路连接，并且该链路可以由任意一方控制。两个站点可以同时发送命令或进行响应。

#### 4.3.1.3 通信方式

HDLC 协议中的通信方式就是在一次交互中涉及的两个设备之间的关系，这种方式描述了链路由谁控制。

HDLC 协议支持 3 种通信方式：正常响应方式（Normal Response Mode，NRM）、异步响应方式（Asynchronous Response Mode，ARM）、异步平衡方式（Asynchronous Balanced Mode，ABM）。

正常响应方式是指标准的主从关系。在这种方式下，从设备必须在得到许可后才可以进行传输。一旦获得了许可，从设备可以发送一次传输作为响应。一次传输可以传送一帧或多帧数据。

在异步响应方式中，只要信道空闲，从设备可以在没有得到许可的情况下发起一次传输。异步响应方式在其他方面没有改变主从关系。从一个设备发出的传输，必须经过主设备转发到目的地。

在异步平衡方式中，所有站点都是平等的，这种方式只用于点对点连接的复合站点。一个站点发起的传输不需要得到其他站点的许可。

通过非平衡配置进行的交互总是采用正常响应方式。通过对称和平衡配置进行的交互可以通过命令帧设置成特定的通信方式。

### 4.3.2 HDLC帧格式

HDLC 协议定义了 3 种类型的帧：信息帧（I-帧）、监管帧（S-帧）、无编号帧（U-帧）。I-帧用来传输用户数据以及与用户数据有关的控制信息。S-帧用来传输控制信息，主要是数据链路层流量控制和错误控制信息。U-帧用来进行链路管理服务。

图 4.20 展示了 HDLC 三类帧的格式。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.20-HDLC的帧格式.1e1wnyst9cyo.png" alt="HDLC的帧格式">
    <br>
    图4.20 HDLC的帧格式
</div>

HDLC 协议的每一帧中最多可以包含 6 个域：一个开始标志（F）域，一个地址（A）域，一个控制（C）域，一个信息（Info）域，一个帧校验序列（FCS）域，以及一个结束标志（F）域。

#### 4.3.2.1 标志域

标志域为一个字节，其比特模式为 01111110。它用来表示一个帧的开始和结束，并且为接收方提供同步手段。在多帧传输中，一帧的结束标志可能同时是下一帧的开始标志。

除了标志域外，帧的其他域不能含有 01111110 这样的比特模式。为了确保在一帧中只在标志域中出现这样的比特模式，HDLC 协议采用**比特填充**方法。每次发送方要发送的信息中含有 5 个以上连续的 1 时，在第 5 个 1 后插入一个冗余的 0，不管第 6 个比特是 0 还是 1。

接收方在接收信息时进行 1 的计数，当发现 0 后有 5 个连续的 1 时，校验第 7 个比特。如果第 7 个比特是 0，接收方把它当做是一个填充比特，丢弃该比特；如果第 7 个比特是 1，接收方校验第 8 个比特。如果第 8 个比特是 0，该序列被认为是一个标志；如果第 8 个比特是 1，接收方继续计数，连续的 7 到 14 个 1 被认为是取消标志，15 个及 15 个以上连续的 1 被认为是信道空闲的标志。

#### 4.3.2.2 地址域

在 HDLC 协议中帧的第二个域是地址域。地址域是指从站点地址，或者是以从站点方式运行的复合站点地址。如果帧是由主站点发送的，则地址表示接收该帧的从站点地址；如果帧是由从站点发送的，则地址表示发送该帧的从站点地址。

根据网络的规模，地址域可以有一个或几个字节的长度。如果地址域只有一个字节，该字节最后一比特总是 1；如果地址域有多个字节，除最后一个字节外其他所有字节都要以 0 结尾，最后一个字节以 1 结尾。如果地址域的某一个字节的最后一位是 0，说明该地址域没有结束，下一个字节还是地址域的一个字节；如果地址域的某一个字节的最后一位是 1，说明该字节是地址域的最后一个字节。

#### 4.3.2.3 控制域

控制域有一个或两个字节，是用来进行流量管理的。这里只讨论一个字节的情况。

根据控制域的内容，可以确定一个帧的类型。如果控制域的第一个比特是 0，该帧就是信息帧；如果控制域的前两个比特是 10，该帧就是监管帧；如果控制域的前两个比特是 11，该帧就是无编号帧。

1. I-帧的控制域

I-帧控制域的格式如图 4.21 所示。其中，第一位为 0，它是 I-帧的标志。第 2、3、4 位是 N(S) 位，第 5 位是 P/F 位，第 6、7、8 位是 N(R) 位。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.21-I-帧的控制域.32epnhc2nrs0.png" alt="I-帧的控制域">
    <br>
    图4.21 I-帧的控制域
</div>

N(S) 是当前发送帧的编号。

N(R) 是期望收到的帧的编号，它是一个应答域。如果最近一帧是正确的，N(R) 域将是序列中下一帧的序号；如果最近一帧是错误的，N(R) 域将是这个损坏帧的序号。

I-帧中的 P/F 位表示是否还有要发送的帧，P/F=0 表示还有要发送的帧，P/F=1 表示没有要发送的帧。

I-帧是用来传输用户数据信息的，但是它也包含一些控制信息。我们把数据信息和控制信息结合到一帧中的技术称为**捎带确认**。

2. S-帧的控制域

S-帧控制域的格式如图 4.22 所示。其中，第 1、2 位为 10，它是 S-帧的标志。第 3、4 位是编码位，第 5 位是 P/F 位，第 6、7、8 位是 N(R) 位。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.22-S-帧的控制域.2t9cm7h43yy0.png" alt="S-帧的控制域">
    <br>
    图4.22 S-帧的控制域
</div>

两位编码位可用来表示 4 种不同的 S-帧：接收就绪帧（RR，编码为 00）、接收未就绪帧（RNR，编码为 01）、拒绝帧（REJ，编码为 10）、选择拒绝帧（SREJ，编码为 11）。

当 P/F 位为 1 时才是有意义的。当帧是由主站点发送到从站点时，它意味着查询；当帧是由从站点发送到主站点时，它意味着结束。

当不能在 I-帧上捎带确认信息时，就要用 S-帧来对收到的数据进行应答。N(R) 是期望收到的帧的编号，它是一个应答域。如果最近一帧是正确的，N(R) 域将是序列中下一帧的序号；如果最近一帧是错误的，N(R) 域将是这个损坏帧的序号。

3. U-帧的控制域

U-帧控制域的格式如图 4.23 所示。其中，第 1、2 位为 11，它是 U-帧的标志。第 3、4、6、7、8 位是编码位。第 5 位是 P/F 位，U-帧中的 P/F 位一般都应置 1。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.23-U-帧的控制域.598jkji92cg0.png" alt="U-帧的控制域">
    <br>
    图4.23 U-帧的控制域
</div>

#### 4.3.2.4 信息域

S-帧中没有信息域。I-帧的信息域是用于数据信息。U-帧中的信息域是链路管理信息，它的长度可以因网络不同而不同，但是在每一具体网络中，最大帧长总是固定的。

#### 4.3.2.5 帧校验序列域

帧校验序列是 HDLC 协议的错误检测域，它含有一个两字节或四字节的循环冗余校验码。

### 4.3.3 S-帧的使用方式

S-帧分为 4 类：接收就绪帧（RR，编码为 00）、接收未就绪帧（RNR，编码为 01）、拒绝帧（REJ，编码为 10）、选择拒绝帧（SREJ，编码为 11）。

#### 4.3.3.1 接收就绪帧

接收就绪帧有 4 种使用方式：

1. 对数据帧的应答（ACK）。接收站本身没有数据信息发送时，用一个接收就绪帧作为应答帧来对所接收的数据帧进行应答。这时，该接收就绪帧的 N(R) 域包含有期待接收的下一帧的编号。
2. 查询（POLL）。当主站点询问从站点是否有数据发送时，它向从站点发送一个 P/F 域为 1 的 RR 帧。
3. 对查询的否定应答（POLL.NAK）。从站点用一个 P/F 域为 1 的 RR 帧回答主站点的查询，通知主站点从站点没有数据发送。如果从站点有数据发送，从站点用一个 I-帧来响应查询。
4. 对选择的肯定应答（SEL.ACK）。如果从站点收到了主站点的选择帧，并且从站点已经准备好从主站点接收数据，它用一个 P/F 域为 1 的 RR 帧回答主站点的选择。

#### 4.3.3.2 接收未就绪帧

接收未就绪帧有 3 种使用方式：

1. 对数据帧的应答（ACK）。接收方向发送方返回 RNR 帧有两个含义：一是应答，表示接收方收到了编号在 N(R) 以前的所有帧；二是要求发送方暂停发送，直到发送方收到一个 RR 帧为止。
2. 选择（SEL）。当主站点想要向某个从站点发送数据时，它通过发送一个 P/F 域为 1 的 RNR 帧来通知从站点。
3. 对选择的否定应答（SEL.NAK）。当选择的从设备不能接收数据时，它回答一个 P/F 域为 1 的 RNR 帧。

#### 4.3.3.3 拒绝帧

在回退 n 自动重复请求中，当接收方收到一个损坏帧，并且没有要发送的数据用来捎带应答信息时，返回一个否定应答帧。其中 N(R) 域指明了损坏帧的序号，损坏帧及其以后所有的帧必须重发。

#### 4.3.3.4 选择拒绝帧

在选择拒绝自动重复请求中，当接收方收到一个损坏帧时，它返回一个选择拒绝帧。N(R) 域指明了损坏帧的序号，损坏帧需要重发。

### 4.3.4 U-帧的种类

U-帧用来在互连设备之间交换会话管理信息和控制信息。U-帧的控制域中有 5 位编码，其中有 2 位在 P/F 位之前，3 位在 P/F 位之后。

表 4.1 列出了不同类型的 U-帧。

<center>表4.1 不同类型的U-帧</center>

|  编码  | 名称  |   性质    |                             意义                             |
| :----: | :---: | :-------: | ---------------------------------------------------------- |
| 00001 | SNRM  |   命令    |                       设置正常响应模式                       |
| 11011 | SNRME |   命令    |                     设置扩展正常响应模式                     |
| 11000 | SARM  |   命令    |                       设置异步响应模式                       |
| 11010 | SARME |   命令    |                     设置扩展异步响应模式                     |
| 11100 | SABM  |   命令    |                       设置异步平衡模式                       |
| 11110 | SABME |   命令    |                     设置扩展异步平衡模式                     |
| 00100 |  UP   |   命令    |       无序号轮询。从指定站发来的关于对状态信息的轮询。       |
| 00000 |  UI   | 命令/响应 | 无序号信息。通常用来发送状态信息，一般在 UP 或 SIM 信号后发送。 |
| 00110 |  UA   |   响应    |           无序号确认。通常用来确认刚才发送的命令。           |
| 00010 |  RD   |   响应    |                         请求断开连接                         |
| 00010 | DISC  |   命令    |      断开连接。当另外一个站用一个 UA 响应时，断连结束。      |
| 11000 |  DM   |   响应    |        断开连接方式。告诉主站点，从站点处于断连状态。        |
| 10000 |  RIM  |   响应    |        请求初始化模式。从站点请求主站点发送一个 SIM。        |
| 10000 |  SIM  |   命令    |  设置初始化模式。命令其他的站初始化它们的数据链路控制功能。  |
| 11001 | RSET  |   命令    |                            重启动                            |
| 11101 |  XID  | 命令/响应 |        交换标示。允许两个站交换它们的标示和状态信息。        |
| 10001 | FRMR  |   响应    |         帧拒绝。通常被用于一个 U-帧出现了同步错误。          |

U-帧的命令和响应可分为 5 个基本功能类：方式设置、无序号交互、断开连接、启动模式、混杂形式。

1. 方式设置。方式设置命令是由传输的启动方发出的。一个方式设置 U-帧告诉接收站点采用何种方式传输。目的站点接收到这个帧之后，就将自己设置成从站点的工作方式。
2. 无序号交互。无序号交互 U-帧用来在设备之间发送或请求特殊的数据链路信息。UP 帧由主站点发送的链路上，用来获得目的站点的发送和接收状态。UI 帧用来传输状态信息，当它作为命令时，它传送的是对后续传输的参数要求；当它作为响应时，它传送的是诸如接收数据能力等方面的参数。UA 帧通常用来作为对命令或无序号请求帧的应答，如对 UP 帧、方式设置命令帧或 RD 帧的应答。
3. 断开连接。有 3 个断开连接 U-帧。DISC 帧是由断开连续的发起方发送的，目的是中断连接。RD 帧是对 DISC 帧的应答。DM 帧用来响应方式设置命令，告诉对方从站点处于断连状态，不可操作。
4. 启动模式。有 2 个启动模式 U-帧。SIM 帧是主站点要求从站点做好准备，让从站点初始化它的数据链路控制功能。如果从站点收到方式设置命令又不能对该命令正确执行时，它使用 RIM 帧对该命令进行响应，要求主站点发送一个 SIM 帧。
5. 混杂形式。有 3 个混杂形式 U-帧。RSET 帧用来通知对方重新设置发送序列号，并命令对方进行同样的操作，它通常作为 FRMR 帧的相应。XID 帧用来获得对方的标识（地址）。FRMR 帧用来通知对方，接收到的一个 U-帧存在同步错误。

### 4.3.5 HDLC协议通信实例

1. 查询/响应

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.24-HDLC协议查询.5g1pvtla60w0.png" alt="HDLC协议查询">
    <br>
    图4.24 HDLC协议查询
</div>

首先主站点向从站点 B 发送一个 RR 帧，表示对站点 B 进行查询。用 [B, RR, N(R)=0, P/F=1] 来表示此帧，它说明该帧的地址域为 B，帧类型为 RR 帧，接收序号 N(R)=0，P/F 位为 1。

从站点 B 收到主站点发送来的查询帧后，用两个编号为 0 和 1 的 I-帧来响应。第一个数据帧的 P/F 设置为 0，因为它后面还有数据帧要发送；第二个数据帧的 P/F 为 1，表示它后面没有数据要发送，数据发送结束。

主站点向从站点 B 发送一个 RNR 帧来对从站点 B 发送的数据帧进行应答。该帧的 N(R)=2，说明 0 号和 1 号数据帧已被主站点正确接收，主站点期待收到数据帧的编号为 2。RNR 帧要求从站点 B 不要再发送任何数据帧，直到它收到另一个 RR 帧为止。

2. 选择/响应

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.25-HDLC协议选择.3ew04xy75l00.png" alt="HDLC协议选择">
    <br>
    图4.25 HDLC协议选择
</div>

首先主站点向从站点 B 发送一个 RNR 作为选择帧，它通知从站点 B 准备好接收但不要发送。从站点 B 通过一个 P/F 为 1 的 RR 帧告诉主站点，从站点 B 已经准备好接收。之后主站点向 B 发送数据帧，B 站点用 RR 帧对数据帧进行应答。

3. 对等设备间通信

图 4.26 展示了采用捎带确认方式应答的异步平衡方式的信息交互。两个站点具有相同的地位并且通过点对点连接。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.26-HDLC协议中的对等通信.52au78c90840.png" alt="HDLC协议中的对等通信">
    <br>
    图4.26 HDLC协议中的对等通信
</div>

A 通过设置异步平衡方式的 U-帧来建立一条异步平衡方式链路。其中的 P/F 位被设置为 1，表示 A 希望控制会话并首先进行传输。B 返回一个 P/F 为 1 的 UA 帧来接受请求，同意采用异步平衡方式传输。

之后 A 发送了 0 号和 1 号数据帧。B 接着发送了 3 个数据帧，并在其 0 号帧中捎带了对 A 所发送数据帧的应答，B 的 0 号帧中的 N(R)=2，说明它正确收到了 A 的 0 号和 1 号帧，它期待收到 A 的 2 号帧。B 的 1 号和 2 号帧中的 N(R)=2，说明它仍然在等待 A 的 2 号帧。

由于 B 发送完数据后 A 没有数据要发送，所以 A 只能发送一个 S-帧来对 B 所发送的数据帧进行应答。这里 A 发送了一个 RR 帧作为应答，同时表示 A 仍然可以接收数据。A 的 RR 帧中的 N(R)=3，说明 A 收到了 B 的 0 号、1 号和 2 号帧，它期待收到 B 的 3 号帧。

B 收到 A 的应答后，向 A 发送了一个断开连接的命令帧 DISC 帧，决定断开连接。A 发送一个 UA 帧来确认，B 收到该帧后，知道双方都同意断开连接，因此中止连接。

## 4.4 数据链路层网络互连

### 4.4.1 网桥

网桥是数据链路层上的网络互连设备，它是一种存储转发设备，在数据链路层进行数据帧的存储和转发，用来连接局域网。从互连网络的结构上看，网桥属于数据电路终接设备（DCE）级的端到端的连接；从协议的层次上看，网桥同时作用在 OSI 的物理层和数据链路层。

网桥是局域网互连中第二层连接所使用的设备。网桥具有隔离通信、错误检测、帧格式转换和帧路由等数据链路功能。图 4.27 展示了用网桥连接的局域网。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.27-用网桥连接的局域网.7hq1kv96in00.png" alt="用网桥连接的局域网">
    <br>
    图4.27 用网桥连接的局域网
</div>

#### 4.4.1.1 网桥的路由功能

网桥具有根据帧的目的地址决定是否接收该帧的功能，也就是具有路由的功能。

例如，在图 4.27 所示的网络结构中，站点 B 发送局域网 L2 中的一个帧。网桥 B1 检查该帧的目的地址，若该帧是发往局域网 L1 的任意一个站点，B1 接收这个帧并缓存该帧，然后将该帧发往局域网 L1。若该帧是发往另一个局域网中的站点，B1 就忽略该帧。

#### 4.4.1.2 网桥的错误检测和帧格式转换功能

例如，在图 4.27 所示的网络结构中，网桥 B1 收到一个由 B 发往局域网 L1 的帧，它在将该帧发往局域网 L1 之前，先执行差错校验来确定这个帧是否正确。若没有错误，则 B1 在局域网 L1 上发送该帧。若 L1 的帧格式和 L2 的一样，网桥就按其原样发送；若 L1 的帧格式和 L2 的不一样，网桥将帧的格式转化成 L1 的格式。

#### 4.4.1.3 网桥的隔离通信功能

网桥和中继器的不同之处是，网桥具有隔离通信的功能。站点向本网络中的其他站点发送数据帧，该帧只会在本局域网中传播，网桥不会将该帧转发到其他网络中。例如，在图 4.28(a) 中，从站点 A 到站点 D 的帧到达网桥，由于站点 A 和站点 D 处于同一网段中，这个帧被阻止进入下面的网段，只能在上面的网段中传播。在图 4.28(b) 中，由于站点 A 产生的帧要送到站点 G，网桥允许这个帧通过，并传送到下面的网段中。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.28-网桥的隔离通信功能.2lx2mppc7sy0.png" alt="网桥的隔离通信功能">
    <br>
    图4.28 网桥的隔离通信功能
</div>

隔离通信的优点：

1. 提高通信效率。由于网内的通信不会传播到其他网络中，所以不同网络中的网内通信可以并行发生，从而提高了通信效率。
2. 提高安全性。由于网内的通信其他网络中的站点是看不到的，因而安全性得到了提高。

#### 4.4.1.4 桥连不同类型的局域网带来的问题

1. 不同的局域网可能有不同的数据传输速率。
2. 帧格式转换的问题。帧格式转换可能会引起一些其他问题。例如，一个网桥连接一个以太网和一个令牌环局域网，令牌环上的帧有优先级，而以太网上的帧没有优先级，所以从令牌环网到以太网的帧会丢失它的优先级。
3. 不同的局域网有不同的最大帧尺寸。有两种解决方法：第一种方法是限制所有网络中的最大帧尺寸，第二种方法是让网桥将大的帧分解为小的帧。

### 4.4.2 网桥路由算法

网桥决定转发哪个帧和往哪儿转发的过程称为网桥路由（bridge routing）。有 3 种路由策略：固定路由策略、路由学习策略、源路由策略。对应这 3 种策略，有 3 种网桥：固定路由网桥、透明网桥、源路由网桥。

#### 4.4.2.1 固定路由网桥

在每个网桥中都有一张表，这张表中记录了到某个特定站点的帧应该转发到哪个局域网中的信息，这个表称为**路由表**。在固定路由网桥中，路由表的生成是手工配置的，一旦配置完成路由表不会变动，所以叫做固定路由。这种路由策略不适应网络连接的动态变化。

在图 4.27 中有 4 个网桥，假如它们都是固定路由网桥，它们的路由表应该如图 4.29 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.29-网桥的路由表.3q2ivyp4pu80.png" alt="网桥的路由表">
    <br>
    图4.29 网桥的路由表
</div>

#### 4.4.2.2 透明网桥

能够根据网络信息自动生成和修改自己的路由表的网桥称为**透明网桥**（transparent bridge）。透明网桥可以在独立于拓扑结构和站点位置的情况下立即接入并且工作。它们会自动确定站点的位置，并且初始化它们的路由表。它们不需要特殊的设置。若一个站点从一个局域网移动到另一个局域网，每个网桥都会知道这种变动，并相应地修改它们的路由表。这种自动修改和生成路由表的能力称为**路由学习**（route learning）或**地址学习**（address learning）。

1. 路由表的自动修改

当透明网桥接收到一个帧时，它检查帧的源地址，然后就知道发送这个帧的站点可以通过这个帧刚到达的局域网来访问。网桥检查它的每个路由表，查找这个站点的地址。若一个表中的某一项显示这个站点可以通过一个不同的局域网到达，这个网桥就修改这一项，将该项改为该帧刚到达的局域网，并认为该站点移动到了一个不同的局域网上去。

2. 路由表的初始化

当网桥修改一个路由表的某一项时，它包含了对该项的修改时间。每个网桥同时维护一个定时器，只要定时器到期，网桥就检查路由表的每一项，若从定时器被设置以来该项一直未被修改，网桥就删除该项。该项没有被修改，说明网桥在这段时间内没有从对应的站点收到任何信息，因此不能保证该站点的位置是正确的。

当网桥收到一个发往某站点的帧，而在路由表中没有该站点的路由信息时，网桥使用**扩散算法**（flooding algorithm），也就是网桥向它所连接的所有局域网发送这个帧，而帧已经到达的那个局域网除外。网桥使用扩散算法可以实现两个目的：保证该帧到达它的目的站点，而且允许更多的网桥看见这个帧并记住发送站点的方向。这项信息使它们的路由表保持最新。

扩散算法使得网桥能初始化它们的路由表。最初每个网桥的路由表都为空。当一个网桥从一个局域网中收到第一个帧时，它将该帧向其他与它相连的局域网上转发该帧。类似地，与这些局域网相连的所有网桥会收到这个帧，并以同样的扩散算法转发该帧。不久，这个帧就会到达所有网桥和所有局域网。该帧最终能到达它的目的地，同时，所有的网桥也知道了发送站点的方向。

3. 帧循环问题

当一个互连局域网有回路时，就可能产生帧的循环传递问题。例如图 4.30 中的两个局域网由两个网桥连接。假定开始时路由表为空，A 发送一个帧给 B。每一个网桥均接收该帧并将它转发到局域网 L2 中。下一步，网桥 B1 收到网桥 B2 转发的帧，网桥 B2 收到网桥 B1 转发的帧。因为网桥 B1 和网桥 B2 都不知道站点 B 的位置，它们都将帧转发到 L1 上，这样，帧又回到 L1 中了。并且，A 在 L1 上发送了 1 帧，第一轮有 2 帧回到了 L1 中，这种过程继续下去将导致帧的爆炸，最终会阻塞整个系统，使通信停止。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.30-带回路的互连局域网.4zizvcno7c80.png" alt="带回路的互连局域网">
    <br>
    图4.30 带回路的互连局域网
</div>

4. 生成树算法

对于带有回路的互连局域网，必须停用某些网桥来淘汰循环，不允许某些网桥转发帧，把它们当做别的网桥失效时的备份。网桥执行生成树算法来完成这项工作。执行该算法后，帧的转发关系在一个树上进行，因而没有回路。

每个网桥到局域网的连接（即网桥端口）有一定的费用，费用对应于一个网桥端口能往一个局域网上传输的比特速率，一个低的比特速率意味着一个高的费用。这里的费用指网桥从网段接收数据帧时产生的费用，是有方向的。网桥的端口费用确定后，可以将一个互连局域网当做一个图看待，局域网和网桥变成顶点，局域网和网桥之间的连接看做边。图 4.31 是一个互连局域网及其图表示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.31-互连局域网及其图表示.4rl5lerkpno0.png" alt="互连局域网及其图表示">
    <br>
    图4.31 互连局域网及其图表示
</div>

生成树算法首先选择一个网桥作为根网桥（root bridge）。根网桥是具有最低地址（或标识 ID）的那个网桥，根网桥是生成树的根节点。根网桥的选择是通过发送网桥协议数据单元（Bridge Protocol Data Unit，BPDU）这样的特殊帧来完成的。每个 BPDU 包含源网桥的 ID、帧首次被发送时的端口 ID 和接收该帧的端口的累计费用。当一个网桥接收到一个 BPDU 时，它将源网桥的 ID 与自己的 ID 比较，若自己的 ID 大，自己就不是根网桥，它记录下源网桥的 ID 和源网桥到达自己的路径费用，将路径费用加上接收端口的费用，然后通过所有的其他端口转发这个 BPDU，同时它将停止发送自己的 BPDU；若自己的 ID 小于源网桥，它就不转发该帧，而是发送自己的 BPDU。最终，只有具有最低 ID 的网桥才能发送 BPDU，其他网桥不会发送 BPDU，根网桥就被确定了。

根网桥确定后，每个网桥确定它的根端口（root port），这个端口对应于到根网桥的最小费用路径。网桥查找每个端口记录下的路径费用，其中费用最小的端口即为根端口。随后，每个网桥会使用它的根端口来和根网桥通信。

最后，为每个局域网决定一个指定网桥（designated bridge），来自这个局域网的帧只用这个指定网桥来转发。在与某个局域网连接的所有网桥中，到达根网桥费用最小的网桥为指定网桥。网桥从某个局域网中收到了一个 BPDU 时，它将这个 BPDU 的费用和自己到根网桥的费用进行比较，如果自己的费用大，它就不会成为该局域网的指定网桥。在有两个或多个网桥具有相同费用的情况下，具有最小 ID 的网桥成为指定网桥。当每个局域网选定了指定网桥之后，生成树算法就完成了。将局域网和它的指定网桥连接起来，同时将指定网桥的根端口和对应的局域网连接起来，就组成了一个生成树。非指定网桥可以作为备用网桥。

在图 4.31(b) 中，B1 被选定为根网桥。在选定根网桥的过程中，每个网桥知道自己的根端口和到根网桥的最小费用。表 4.2 描述了每个网桥的根端口和从这个端口到根网桥的费用。

<center>表4.2  图4.31(b)所示的互连局域网中各网桥的根端口</center>

| 网桥 | 根端口 |                         最小费用路径                         | 费用 |
| :--: | :----: | :----------------------------------------------------------: | :--: |
|  B2  | B2→L2  |   $\text{B1}\rightarrow\text{L2}\xrightarrow{6}\text{B2}$    |  6   |
|  B3  | B3→L2  |   $\text{B1}\rightarrow\text{L2}\xrightarrow{2}\text{B3}$    |  2   |
|  B4  | B4→L3  | $\text{B1}\rightarrow\text{L2}\xrightarrow{2}\text{B3}\rightarrow\text{L3}\xrightarrow{6}\text{B4}$ |  8   |
|  B5  | B5→L3  | $\text{B1}\rightarrow\text{L2}\xrightarrow{2}\text{B3}\rightarrow\text{L3}\xrightarrow{1}\text{B5}$ |  3   |
|  B6  | B6→L1  |   $\text{B1}\rightarrow\text{L1}\xrightarrow{6}\text{B6}$    |  6   |

最后为每个局域网确定一个指定网桥。对于 L1 和 L2，它们直接连接根网桥，所以 L1 和 L2 的指定网桥为 B1。对于 L3，与它相连的网桥有 B3、B4、B5，其中 B3 到达根网桥的费用最小，所以 L3 的指定网桥为 B3。类似地，L4 的指定网桥为 B2。将局域网和它的指定网桥连接起来，同时将指定网桥的根端口和对应的局域网连接起来，就组成了一个生成树，如图 4.32 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.32-生成树的拓扑结构及其图表示.tngptvuighs.png" alt="生成树的拓扑结构及其图表示">
    <br>
    图4.32 生成树的拓扑结构及其图表示
</div>

#### 4.4.2.3 源路由网桥

源路由网桥转发帧的方法是，让发送帧的源站点决定转发路由，而不是由网桥来决定。发送站点的网络软件确定到目的站点的路由，并将它存储在帧中，这个路由由**路由指示**（route designator）的序列组成，每个路由指示由一个局域网和一个网桥 ID 组成。帧的格式如图 4.33 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.33-源路由网桥的部分帧格式.3hropl6f2ms0.png" alt="源路由网桥的部分帧格式">
    <br>
    图4.33 源路由网桥的部分帧格式
</div>

当一个网桥看见一个帧时，它就确定是否有一个路由指示。若有，该路由指示包含该网桥的 ID 和传输该帧的局域网的 ID，网桥接收该帧并将它转发到下一个路由指示指定的局域网上。例如，在图 4.31 所示的互连局域网中，假定 A 发送一个帧给 B，并指定一个路由为 L1:B5→L3:B4→L4。连接到 L1 的三个网桥 B1、B5 和 B6 都见到了这个帧，但是在路由指示序列中，B5 跟着 L1，所以只有 B5 接收这个帧，然后将这个帧转发到 L3。类似地，连接到 L3 的两个网桥 B3 和 B4 都见到了这个帧，但是在路由指示序列中，B4 跟着 L3，所以只有 B4 接收这个帧，然后将这个帧转发到 L4。

决定到目的站点的一个路由称为**路由发现**（route discovery）。一个路由发现的方法是，一个站点为了确定到另一个站点的路由时，该站点发送一个全路由广播帧（all-route broadcast frame），该帧的控制字段说明了帧的类型。开始时该帧的路由字段为空，控制字段中的路由字段长度为 0。当一个网桥从一个局域网上收到该帧时，它将自己的 ID 和将要进入的局域网的 ID 加入路由字段的末尾，并相应地增加路由字段长度，然后向所有的其他局域网转发。为了避免路由中的循环，网桥检查帧中已存在的路由指示，如果某个局域网的 ID 是帧中路由指示的一部分，就不会将帧转发到该局域网上。当一个帧抵达目的站点，路由字段包含了到达该目的站点所使用的路由。目的站点将这个路由放在一个非广播帧（nonbroadcast frame）的路由字段中，并将其发回源站点。非广播帧由目的站点发往源站点的过程中，路由指示是逆向解读的。当源站点收到这个非广播帧时，它也就知道了到目的站点的路由。

另一个路由发现方法是，发送站点发送一个单路由广播帧（single-route broadcast frame）。单路由广播帧不含路由信息，网桥转发这个帧时，它沿着一个端口转发该帧，该端口是生成树的一部分。在这种情况下，目的站点仅收到一个请求。当目的站点收到请求时，它发送一个全路由广播帧作为响应。最终源站点可能收到多个响应，每个响应包含一个路由，源站点选择一个路由。在这种方法中，网桥必须首先确定生成树。

### 4.4.3 二层交换机

局域网交换机拥有多个端口，每个端口有自己的专用带宽，并且可以连接不同的网段。交换机各个端口之间的通信是同时的、并行的，这就大大提高了信息吞吐量。

交换机可能工作在数据链路层上，也可能工作在网络层上。工作在数据链路层上的交换机称为二层交换机，工作在网络层上的交换机称为三层交换机。

与网桥和集线器相比，二层交换机从以下几方面改进了性能：

1. 通过支持并行通信，提高了交换机的信息吞吐量。
2. 利用网络微分段（micro-segmentation）技术，将一个大局域网上的用户分成若干工作组，每个端口连接一台设备或连接一个工作组，减少竞争带宽的用户数量，增加每个用户的可用带宽，从而缓解共享网络的拥挤状况。
3. 虚拟网（virtual LAN）技术的出现，给交换机的使用和管理带来了更大的灵活性。
4. 端口密度可以与集线器向媲美。

交换机主要从提高连接服务器的端口速率以及相应的帧缓冲区大小来提高整个网络的性能。一些高档的交换机还采用全双工技术进一步提高端口的带宽。

## 4.5 IEEE局域网通信协议

局域网是一个数据传输系统，它允许在有限的地理范围内连接多个独立设备，使它们相互之间直接进行通信。有 4 种体系结构在局域网中占主导地位：以太网、令牌总线、令牌环网、光纤分布式接口（Fiber Distributed Data Interface，FDDI）。以太网、令牌总线、令牌环网都是 IEEE 的标准，光纤分布式接口是 ANSI 标准。

### 4.5.1 IEEE局域网参考模型

IEEE 802 局域网参考模型如图 4.34 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.34 IEEE 802局域网参考模型与OSI模型比较.png">
    <br>
    图 4.34 IEEE 802局域网参考模型与OSI模型比较
</div>

在 OSI 模型中，物理层的任务是为上一层提供一个物理连接，以透明的方式传送比特流。而在局域网中，物理层分为上下两个子层，下面的子层是对电缆介质的说明，上面的子层是**介质访问单元**（Media Access Unit，MAU）。MAU 的主要作用是信息编码、信号发送和介质处理等。

OSI 模型的数据链路层采用 HDLC 协议。而 IEEE 802 标准的数据链路层分为上下两个子层，下面的子层是**介质访问控制**层（Media Access Control，MAC），上面的子层是**逻辑链路控制**层（Logical Link Control，LLC）。

逻辑链路控制层对于所有的局域网协议来说都是相同的，该层中包含数据帧中与终端用户相关的部分：逻辑地址、控制信息和数据。逻辑链路控制层的目的是有效地实现数据传输。

介质访问控制层解决共享介质的竞争使用问题。它包含将数据从一个地方传送到另一个地方所必需的同步、标记、流量和差错控制的规范，同时也包括下一个站点的物理地址。不同的局域网具有不同的介质访问控制协议。介质访问控制层的功能是保证物理功能和逻辑功能的连续性。

IEEE 802 定义了多种局域网和城域网的标准，各种 IEEE 802 标准与 OSI 模型的层次对应关系如图 4.35 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://raw.githubusercontent.com/zzx-JLU/images_for_markdown/main/images/%E5%9B%BE4.35%20IEEE%20802%E6%A0%87%E5%87%86%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png">
    <br>
    图4.35 IEEE 802标准与OSI参考模型的层次对应关系
</div>

从图 4.35 可知，数据链路层中与介质访问无关的部分都集中在逻辑链路控制层中，而与介质访问有关的部分则根据具体网络的介质访问方法分别进行处理，并分别给出不同的标准。

从图 4.35 还可以看出，局域网对逻辑链路控制层是透明的，只有下到介质访问控制层才知道所连接的是什么样的局域网。

### 4.5.2 逻辑链路控制

#### 4.5.2.1 LLC与相邻层的协议数据单元之间的关系

图 4.36 描述了网络层、逻辑链路控制层和介质访问控制层的协议数据单元（Protocol Data Unit，PDU）的关系。

<div align="center" style="margin-bottom: 10px">
    <img src="https://raw.githubusercontent.com/zzx-JLU/images_for_markdown/main/images/%E5%9B%BE4.36%20%E7%BD%91%E7%BB%9C%E5%B1%82%E3%80%81LLC%E5%B1%82%E5%92%8CMAC%E5%B1%82PDU%E7%9A%84%E5%85%B3%E7%B3%BB.png">
    <br>
    图4.36 网络层、LLC层和MAC层PDU的关系
</div>

LLC 层的 PDU 与具体的局域网无关，而 MAC 层的 PDU 则与局域网的介质访问控制方式有很大的关系，不同的局域网有不同的 MAC 层帧格式。

如图 4.36 所示，LLC 层的 PDU 包含 4 个域：目的服务访问点（DSAP）、源服务访问点（SSAP）、控制域、信息域。

目的服务访问点和源服务访问点是 LLC 层使用的地址，用来标明接收和发送数据的计算机上的协议栈。

目的服务访问点的第一个比特用来指明帧是为个体使用还是组使用，0 表示个体，1 表示组。局域网的数据链路层具有多点通信和广播通信的功能，多点通信是将帧发送给一组目的节点，广播通信是将帧发往除源节点外的所有其他节点。所以目的服务访问点有个体和组的区别。

源服务访问点的第一个比特用来指明帧是命令帧还是响应帧，0 表示命令，1 表示响应。

LLC 帧的类型分为 3 种：信息帧（I-帧）、监控帧（S-帧）、无编号帧（U-帧）。图 4.37 展示了这 3 类帧的控制字段的比较。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.37-LLC三类帧的控制字段.z05pc7i6ua8.png">
    <br>
    图4.37 LLC三类帧的控制字段
</div>

对于信息帧和监控帧，控制字段为 2 字节长，格式和 HDLC 协议中具有扩展控制字段的帧结构一样。对于无编号帧，控制字段为 1 字节长，格式和 HDLC 协议的无编号帧一样。因此，LLC 帧按模 128 进行编号。

监控帧用于应答和流量控制。共有 3 种形式的监控帧：接收就绪帧（RR）、拒绝帧（REJ）、接收未就绪帧（RNR）。它们的功能和 HDLC 协议相同。与 HDLC 协议相比，LLC 帧没有选择拒绝帧。

LLC 帧没有 CRC 差错校验，CRC 放在介质访问控制层中进行。在 MAC 帧的帧尾中有 4 个字节的校验序列 FCS。

#### 4.5.2.2 LLC地址与MAC地址

在 MAC 帧的帧首中有目的站地址和源站地址，它们都是 2 字节或 6 字节长。MAC 帧中的地址是站点的物理地址。

在 LLC 帧的帧首中设有目的服务访问点和源服务访问点，该地址是逻辑地址，标识的是数据链路层的不同访问服务点。

LLC 地址与 MAC 地址是两个不同的概念，在局域网中，一个站点上的多个服务访问点可以复用一条数据链路。在这一点上，LLC 层带有 OSI 网络层的某些功能。如图 4.38 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.38-LLC与MAC地址.4glffg373g80.png">
    <br>
    图4.38 LLC与MAC地址
</div>

设站点 A 中的一个进程 X 要向站点 C 中的某个进程发送报文，在 LLC 层 X 把自己连接到服务访问点 SAP1，并请求与站点 C 的 SAP1 建立一个连接。于是站点 A 的数据链路层向局域网发出一个连接请求帧，该帧里包含了源地址（A,1）、目的地址（C,1）和其他一些控制信息。源地址（A,1）中的 A 是物理地址，出现在 MAC 层的 PDU 中；1 是逻辑地址，是用来标识 SAP 的，出现在 LLC 层的 PDU 中。与此同时，假定站点 A 有另一个进程 Y 和（A,2）连接上，想和（B,1）交换数据，这时又可建立一条连接。同理，进程 Z 还可以在（B,2）与（A,3）之间建立一条连接。从图 4.38 可以看出，几个 SAP 可以复用一条链路。

#### 4.5.2.3 LLC层提供的服务

LLC 层向上可以提供以下 3 种服务：

1. 非确认的无连接服务。非确认的无连接服务是一种类似于数据报的服务，它不需要确认信息。使用该服务时，端对端的差错控制和流量控制由高层协议（通常是传输层）来实现。这个服务可用于点对点、广播和多点传送。
2. 面向连接服务。LLC 层的面向连接服务相当于虚电路服务，每次通信都要经过连接建立、数据传输和释放连接 3 个阶段。
3. 确认的无连接服务。确认的无连接服务介于上述两种服务之间，它对数据帧提供应答信息，但数据传输之间不需要进行逻辑连接。确认的无连接服务用于传输某些非常重要且时间性很强的信息，如报警信号，这时不确认信息则不可靠，但先建立连接则延迟太大。

## 4.6 以太网

IEEE 802.3 标准定义了以太网。以太网上的每一个站点都有自己的网络接口卡（Network Interface Card，NIC），即网卡。NIC 通常安装在站点内部，并为站点提供一个 6 字节的物理地址。NIC 上的物理地址是唯一的，任意两个不同的 NIC 都具有不同的物理地址。

### 4.6.1 以太网访问模式：CSMA/CD

当多个用户在没有任何控制的情况下同时访问一条线路时，存在由于不同信号叠加而相互破坏的情况，叠加后的信号将无法识别，我们将这种情况称为**冲突**。

以太网中使用的介质访问控制模式称为带冲突检测的载波监听多路访问技术（Carrier Sense Multiple Access with Collision Detection，CSMA/CD）。CSMA/CD 是从多路访问（MA）发展到载波监听多路访问（CSMA），最后发展到 CSMA/CD 的。

#### 4.6.1.1 多路访问（MA）

在多路访问方法中并不提供通信管制，对链路的访问在任何时候对任何站点都是开放的。这种方法依赖于应答来判断帧是否因为冲突而被链路上的其他通信破坏。

#### 4.6.1.2 载波监听多路访问（CSMA）

在 CSMA 中，任何想发送数据的站点必须首先监听链路上已经存在的通信情况。如果链路空闲，就可以开始传输。如果发送者监听到链路是非空闲的，则应该避让一段时间，然后再试图发送。

根据避让时间的选择方法，CSMA 可分为 3 种：非坚持 CSMA、坚持 CSMA、P-坚持 CSMA。

非坚持 CSMA 的算法如下：

1. 如果链路是空闲的，则可以发送。
2. 如果链路是忙的，则等待一段时间，然后转步骤 1。等待时间的长短在一个时间范围内随机选择。

采用随机的重发延迟时间可以减少冲突的可能性。其缺点是即使有多个站点要发送数据，链路仍然有可能处于空闲状态，链路的利用率较低。

坚持 CSMA 的算法如下：

1. 如果链路是空闲的，则可以发送。
2. 如果链路是忙的，则继续监听，直到检测到链路空闲，立即发送。
3. 如果有冲突，则等待随机的时间，转步骤 1。

这种方法的优点是只要链路空闲，站点就立即发送，链路的利用率较高。其缺点是假如多个站点有数据要发送，冲突就不可避免。

P-坚持 CSMA 是一种折中方案，其算法如下：

1. 如果链路是空闲的，则以 $P$ 的概率发送，以 $1-P$ 的概率延迟一个时间单位。时间单位通常等于最大传播延迟的 2 倍。
2. 如果链路是忙的，继续监听直至链路空闲，转步骤 1。
3. 如果传输延迟了一个时间单位，则转步骤 1。

P-坚持 CSMA 的问题在于如何选择 $P$ 的值。假设有 $N$ 个站点要发送数据，则试图传输的站点的期望数为 $NP$。如果选择 $P$ 过大，使 $NP>1$，表明有多个站试图发送，冲突不可避免。所以必须选择 $P$ 值使 $NP<1$。但是 $P$ 值也不能过小，否则链路利用率会大大降低。

CSMA 减少了冲突的可能，但并没有完全消除冲突。如果其他某个站点刚刚发送了信号，由于信道的传播延迟，在信号还没有到达正在监听的站点时，监听者仍然认为链路是空闲的，因此继续将自己的信号发送到链路上，从而发生了冲突。由于 CSMA 算法没有冲突检测功能，即使冲突已经发生，仍然要将已破坏的帧发送完，使总线的利用率降低。

#### 4.6.1.3 带冲突检测的载波监听多路访问（CSMA/CD）

在 CSMA/CD 中，站点在传输时继续监听链路，一旦检测到冲突就立即停止发送，并向链路上发送一串阻塞信号，通知链路上各站点冲突已发生，这样链路就不会因为传送已受损的帧而浪费带宽，从而提高链路的利用率。

在 CSMA/CD 中，浪费掉的带宽为检测冲突所花费的时间；而在 CSMA 中，浪费掉的是整个帧的传输时间。检测冲突所需的时间称为**冲突检测窗口**。对于基带总线而言，用于检测冲突的时间等于任意两个站点之间最大的传播延迟的 2 倍。

如图 4.39 所示，假定 A、B 两个站点位于总线两端，传播时间为 $a$。由图可知，当 A 发送后，经过 $2a$ 的时间才能检测出冲突。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.39 冲突检测所需时间.png">
    <br>
    图4.39 冲突检测所需时间
</div>

这说明以太网的 MAC 帧最小长度应至少两倍于传播延迟，否则在检测出冲突之前传输已经完成，但实际上帧在远端可能被冲突所破坏。设 $S$ 为任意两站点间的最大距离，$R$ 为数据传输速率，$V$ 为信号传播速度，则最短帧长 $L_\text{min}$ 为：
$$
L_\text{min}=2R\times\frac{S}{V}
$$

如果给定数据传输速率 $R$、信号传播速度 $V$ 和最小帧长 $L_\text{min}$，可以算出系统中两个站点的最大距离。

CSMA/CD 的算法如下：

1. 如果链路是空闲的，则可以发送并同时检测冲突。
2. 如果链路是忙的，则继续监听，直到链路空闲，发送并同时检测冲突。
3. 如果在发送过程中检测到冲突，则停止当前帧的发送，发阻塞信号，等待一段选定的时间，转步骤 1。

在 CSMA/CD 中，等待时间的大小是由退避算法选定的。退避算法的过程如下：

1. 对每一个帧，当第一次发生冲突时，设置参数 $L=2$。
2. 退避间隔取 1 到 $L$ 个时间片中的一个随机数。一个时间片等于链路上最大传播延迟的 2 倍。
3. 当帧再次发生冲突时，将参数 $L$ 乘 2。$L$ 的最大值为 1024。
4. 帧的最大重传次数为 16，超过这个次数，则该帧不再重传，并报告出错。

从退避算法可以看出，未发生冲突的帧或发生冲突次数较少的帧具有优先发送的概率，而发生过多次冲突的帧成功发送的概率较小。同时，没有经历冲突或经历过冲突次数较少的帧可能比等待时间较长的帧先成功发送。

以太网采用曼彻斯特编码，通过检测链路上的信号存在与否来实现载波监听。发送站在发送的同时检测冲突，如果检测到链路上的信号超过本身发送信号的幅度，就判断出冲突。

### 4.6.2 以太网MAC帧格式

IEEE 802.3 定义了一种具有 7 个域的 MAC 帧，这 7 个域是：前导码、帧起始分界符（SFD）、目标地址（DA）、源地址（SA）、LLC-PDU 的长度/类型、LLC-PDU、CRC。以太网不提供任何确认收到帧的应答机制，确认必须在高层完成。以太网 MAC 帧的结构如图 4.40 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.40 以太网MAC帧的结构.png">
    <br>
    图4.40 以太网MAC帧的结构
</div>

前导码包含 7 个字节，在这个域中 1 和 0 交替出现，警告系统接收即将到来的数据帧，同时使系统能够调整同步输入时钟。

帧起始分界符（SFD）标记了帧的开始，它只有一个字节，模式是 10101011。SFD 通知接收方后面所有的内容都是数据。

目的地址（DA）为 6 个字节，标记了数据帧下一个站点的物理地址。

源地址（SA）为 6 个字节，它包含了最后一个转发此帧的设备的物理地址。

LLC-PDU 长度指出了 LLC-PDU 域中的有效字节数。如果 PDU 的长度是固定的，那么这个域可以用来表示类型，或者作为其他协议的一个基础。

LLC-PDU 由上层（LLC 层）创建，然后整个传送给 MAC 帧，MAC 帧将 802.2 的整个帧作为透明数据包含进来。该域的长度可以从 46~1500 字节不等。为了使 CSMA/CD 协议正常工作，需要一个最小帧长度，必要时可以在 LLC-PDU 字段内以字节为单位加一些填充位。

### 4.6.3 以太网种类

IEEE 802.3 定义了两个类别：基带和宽带。

基带使用数字信号传输数据，编码使用曼彻斯特编码。IEEE 将基带分为 5 个不同的标准：10Base5、10Base2、10Base-T、1Base5、100Base-T。这些标准的开头数字（10、1、100）指明了以 Mbps 为单位的数据传输速率，最后的数字或字母（5、2、T）指明了最大电缆长度或电缆的类别，Base 指明的是基带传输。

10Base5 称为粗缆以太网，是一种总线型拓扑结构。

10Base2 称为细缆以太网，是一种总线型拓扑结构。

10Base-T 是一个星状拓扑结构的局域网，使用无屏蔽双绞线（UTP）电缆。

宽带使用模拟信号传输数据。宽带以太网只有一种标准：10Broad36，10 指明了以 Mbps 为单位的数据传输速率，36 指明了最大电缆长度，Broad 指明的是宽带传输。宽带以太网使用的是差分 PSK 编码。

## 4.7 无线局域网

### 4.7.1 无线局域网标准

无线局域网（WLAN）技术定义在 IEEE 802.11 规格说明系列中。IEEE 802.11 定义了 3 种物理介质：跳频扩展频谱（Frequency Hopping Spread Spectrum，FHSS）、直接序列扩展频谱（Direct Sequence Spread Spectrum，DSSS）和红外线。

### 4.7.2 CSMA/CA协议

IEEE 802.11 的 MAC 层采用 CSMA/CA（载波监听多路访问/冲突避免）协议进行无线介质的共享访问。CSMA/CA 与 CSMA/CD 的区别在于：CSMA/CD 是带有冲突检测的载波监听多路访问，发送包的同时可以检测到信道上有无冲突；CSMA/CA 是带有冲突避免的载波监听多路访问，发送包的同时不能检测到信道上有无冲突，只能尽量避免。

IEEE 802.11 的载波监听机制与 IEEE 802.3 的载波监听机制基本相同。要发送数据的站点首先要监听无线信道，如果信道处于空闲状态，则等待一个很短的时间（IFS），若信道仍然空闲，它就可以发送数据。如果信道上有信号传播，它就推迟自己的数据发送而继续监听直到信道空闲。当一帧传输结束后，站点再等待一个 IFS 时间，如果在此时间内信道忙，站点便执行二进制指数退避算法并继续监听信道，如果信道空闲便可以传送下一帧。

CSMA/CA 协议的关键在于冲突避免（Collision Avoidance，CA）。IEEE 802.11 的冲突避免采用 3种机制来实现：预约信道、正向确认、RTS/CTS 机制。

1. 预约信道：发送站点利用 MAC 帧中的传输持续时间字段向所有其他无线站点通告本站点将要占用信道多长时间，其他站点在这段时间内不要发送数据，以避免冲突。每一个站点的 MAC 层将检查接收到的帧中的传输持续时间字段，如果发现该字段的值大于本站点当前的网络分配向量（NAV）的值，就用该字段的值更新本站点的 NAV。NAV 是一个计数器，它从设定的值开始不断减 1，当 NAV 的值减为 0 且信道空闲时，本站点就可以发送数据了。
2. 正向确认：接收站点如果正确收到以它为目的地的数据帧时，就向发送站点发送一个 ACK 帧作为接收成功的肯定应答，否则将不采取任何动作。发送站点在发送完数据帧的规定时间内若没有收到 ACK 帧就需要重发数据帧，直到收到 ACK 帧为止，重发的最大次数根据预先确定的限定值而定。
3. RTS/CTS 机制：IEEE 802.11 提供请求发送（Request to Send，RTS）/允许发送（Clear to Send，CTS）选项来解决**隐蔽站点问题**。隐蔽站点是指这样一种情况，有 3 个站点 A、B、C，B 位于 A 和 C 之间，虽然 A 和 C 都能与 B 通信，但 A 和 C 却因为距离较远或二者之间存在障碍物而彼此收不到对方发出的信号。当 A 和 C 都要与 B 通信时，因为 A 和 C 相互感知不到对方的存在，因而都向 B 发送数据，结果数据在 B 站点发生冲突。使用 RTS/CTS 机制就可以解决隐蔽站点的问题：首先，A 向 B 发送 RTS 帧，表明 A 要向 B 发送若干数据，B 收到 RTS 帧后，就向 A 回送一个 CTS 帧，表明 B 准备接收。而此时 C 也会收到 B 发送给 A 的 CTS 帧，C 就不会发送任何帧，从而使得 A 可以向 B 发送数据而不会发生冲突。B 收到 A 发送的数据后，立即发送一个 ACK 帧，随后 3 个站点可以重新竞争信道。RTS 和 CTS 帧都包含了传输持续时间字段，隐蔽站点问题正是利用了 RTS 和 CTS 帧的信道预约功能而得到解决的。

## 4.8 其他局域网技术

### 4.8.1 令牌环网

令牌环网的物理层采用差分曼彻斯特编码。

#### 4.8.1.1 令牌环网访问模式：令牌传递

每当网络空闲时，它便传递一个令牌。令牌是一个简单的帧，它只有 3 个字节。这个令牌按顺序从一个 NIC 传送到另一个 NIC，直到遇到一个需要发送数据的站点。

每个站点只有在拥有令牌的时候才能发送数据，并且一次只能发送一帧数据。

当数据帧回到它的发送站点时，发送站点发现该帧的源地址和自己的地址相同，于是就检查该数据帧的最后一个域（帧状态域 FS）。如果该帧的最后一个域中的相关信息被设置，发送站点就知道这个帧已经被接收了，于是发送站点丢弃该帧，同时将令牌释放。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.41-令牌传递.3011rf08sa60.png">
    <br>
    图4.41 令牌传递
</div>

#### 4.8.1.2 令牌环网的MAC帧格式

令牌环有三种类型的帧：数据帧、令牌帧、异常终止帧。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.42-令牌环网的MAC帧格式.4f3v40myy0m0.png">
    <br>
    图4.42 令牌环网的MAC帧格式
</div>

起始分界符 SD：1 个字节长，用来警告接收站点一个帧即将到来。SD 的格式为 JK0JK000，JK 为违法码，J 表示开始和比特中间没有跳变，K 表示比特中间没有跳变。

访问控制 AC：1 个字节长，其比特模式为 PPPTMRRR。PPP 是三位优先级，T 用来指明该帧是令牌帧还是数据帧。M 是监控位，用来防止永久循环的帧在网中存在。RRR 是预留位，由希望对下一个令牌作预留的站点来填写。

结束分界符 ED：ED 域是第二个标记域，1 个字节长，指明了数据或控制信息的结束。其比特模式为 JK1JK1IE。E 为错误检测位，任何中间站点检测到任何错误，就将该位置位。I 用于多帧传送中使用，该位置位表示还有后续的帧要传送，此帧不是最后一帧。

帧状态 FS：比特模式为 ACrrACrr，其中 r 没有定义。A 和 C 由接收者来设置，A 被置位表示地址被识别，C 被置位表示帧被接收者拷贝。

### 4.8.2 令牌总线网

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图4.43-令牌总线网.76qwom8w3eo0.png">
    <br>
    图4.43 令牌总线网
</div>
### 4.8.3 FDDI

FDDI 使用一种特殊的编码机制，称为 4比特/5比特（4B/5B）编码。数据的每 4 个比特先编码为 5 个比特，然后采用 NRZ-I 编码成信号，NRZ-I 使用 1 反转。

NRZ-I 在数据单元中含有一长串 0 的情况下，可能会丢失同步。4B/5B 编码将每 4 个比特数据转换为不包含超过连续两个 0 的 5 比特单元。

# 5 网络层

在 OSI 模型中，通信子网由物理层、数据链路层和网络层组成。网络层是通信子网的最高层，也是主机和通信子网的接口。网络层负责数据包经过多段链路、由信源到信宿的传递过程，将数据包从源节点传送到目的节点，负责的是多段链路组成的路径上的数据传送问题。

## 5.1 网络层的功能和服务

网络层提供了两种主要功能：交换和路由。

交换是在两个或多个设备之间建立临时连接，使得没有物理链路直接连接的两个或多个设备之间能够通信。它实际上是将多段物理链路连接成一条通信路径。

路由意味着在有多于一条路径可选时，选择从一点到另一点发送数据包的最佳路径。在这种情况下，每个数据包可以经过不同的路由到达目的地，然后在目的地按照原始顺序重新组装起来。

路由和交换都需要在原始数据上附加报文头，包括数据包源地址和目的地址以及其他信息。这些地址与数据链路层中所加的地址是不同的。数据链路层地址即物理地址，又称为 MAC 地址、网卡地址。数据包中的数据链路层地址只包括现在和下一个节点的物理地址，当一个数据帧从一个节点传输到另一个节点时，数据链路层地址信息也随之改变。而网络层地址是信源地址和信宿地址，在传输中不会改变。

### 5.1.1 网络层的功能

网络层的功能如下：

1. 信源到信宿的传输。通过多条物理链路连接成的传输路径将一个数据包从源点传输到目的点。这为它的上层（传输层）提供了完整的服务，传输层不必关心两站点间传送信息的具体细节。
2. 逻辑寻址。在数据包的头部加入源地址和目的地址。
3. 路由。在有多于一条路径可选时，选择从一点到另一点发送数据包的最佳路径。
4. 地址转换。将网络层地址翻译成对应的物理地址，或者将物理地址转换成对应的网络层地址。
5. 复用。使用同一条物理线路同时传输多个设备间的数据。
6. 流量和拥塞控制。网络层协议必须能够在部分报文丢失时通知发送方，调节发送的流量。
7. 网络互连。发送端和接收端节点可能不在一个网络之内，要成功实现端对端的传送，必须解决网络互连的有关问题。

网络层负责在不同网络之间建立、管理和终止连接。网络层协议提供了网络中的透明路由和中继服务，这些服务被网络层的上层所使用。

在 OSI 模型中，网络层提供了两种类型的服务：面向连接的网络服务（Connection Oriented Network Service，CONS）、无连接的网络服务（Connection Less Network Service，CLNS）。在 TCP/IP 协议中，网络层只提供无连接的网络服务。

### 5.1.2 面向连接的网络服务

面向连接的网络服务为数据传输建立一条虚电路，这条电路在整个数据传输过程中都是有效的。属于这次数据传输过程的所有包都将按顺序沿着这条电路传输。

在面向连接的网络服务环境中，在数据可以发送之前必须先在传输的两端建立一个连接。在传输开始时，发送设备发送一个请求发送包，如果接收者空闲的话，它可以返回一个准备接收包。在两端都准备好之前，数据将不会被传输。

一个面向连接的网络服务通过如下步骤完成一次传输过程：

1. 发送者发送一个连接请求包。
2. 接收者使用一个连接确认包进行确认。
3. 发送者传输数据。
4. 发送者发送一个连接终止请求包。
5. 接收者使用一个连接终止确认包进行确认。

面向连接的网络服务的优点如下：

1. 允许一个协议包含全面的顺序、差错和流量控制。
2. 在数据包中使用了较少的协议控制信息。由于所有的包都是沿着相同的路径传送，所以只有用于连接的包才使用显式的地址信息。进行数据包传送时，每个包不需要携带完整的目的地址，仅需要一个虚电路的号码标志。这就减少了包的控制信息，从而减少了额外开销。

面向连接的网络服务的缺点如下：

1. 一旦连接建立后，路由的灵活性就不存在了。如果一条链路发送阻塞或出现其他问题，后续的包不能使用其他的路径来替代。
2. 面向连接的网络服务比无连接的网络服务速度低。

### 5.1.3 无连接的网络服务

在无连接的网络服务中，一次多包传输中每个包被当做一个独立的单元。无连接协议不提供逻辑连接。发送者不需要提醒接收者有通信即将到来，它仅仅是发送数据。每个数据包的到来对于接收方来说是一个独立的事件，接收方并没有准备它的发生，它可能接收这个包也可能不接收这个包。无连接的网络服务比面向连接的网络服务简单。

优点：

1. 速度快，开销小。单个传输的各个片段可以通过不同的路径传输，从而达到最大的效率。
2. 灵活性。如果某一条路径发生阻塞或中断，包可以选择另一条路径。

缺点：

1. 不可靠，无法保证数据包按顺序到达。
2. 每个包所需的开销较大，每个信息包必须携带完整的地址信息。

## 5.2 网络层互连设备

### 5.2.1 路由器

路由器工作在 OSI 模型的物理层、数据链路层和网络层。

路由器在多个互连设备之间中继包。路由器对来自某个网络的包确定传输路径，发送到互连网络中任何可能的目的网络中。图 5.1 显示了一个由 5 个网络组成的互连网络。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.1-互连网络中的路由器.5aaugkugub40.png" alt="互连网络中的路由器">
    <br>
    图5.1 互连网络中的路由器
</div>

从一个网络中的站点发送到一个临近网络中的包，将会先发送到连接处的路由器，通过这个路由器把此包转发到目的网络中。如果没有一个路由器直接连接发送和接收网络，发送路由器通过和它相连的网络，把包转发到通往目的网络的路径上的下一个路由器上，该路由器将会把这个包转发到路径中的再下一个路由器中，如此这般，直到包到达目的网络。

路由器如同网络中的一个站点一样工作。但是路由器同时连接到多个网络中，同时是多个网络中的成员，并同时拥有这些网络中的地址。

路由器最简单的功能是从一个连接的网络中接收包，同时将这些包传送到第二个连接的网络中。如果一个包的目的节点不在这个路由器所直接连接的网络中，路由器能够决定与它连接的哪一个网络是这个包的最好的下一个中继节点。一旦路由器识别出一个包所应走的最佳路径，它将通过合适的网络将包传递给下一个路由器。

路由器既包含硬件设备，又包含互连网络协议的软件系统模块和相应的协议转换模块。路由器的一般结构如图 5.2(a) 所示。按照 ISO/OSI 网络互连子层的概念，路由选择器的结构如图 5.2(b) 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.2-路由器的结构.4dqqavsqxqg0.png" alt="路由器的结构">
    <br>
    图5.2 路由器的结构
</div>

当路由器用于连接两个由不同单位管理的计算机网络时，就会有路由器放在哪一边管理的问题。这时可以把路由器一分为二，每一半连接一个网络，两个半路由器之间用通信线路连接，如图 5.3 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.3-半路由器的结构.34nuhl359t20.png" alt="半路由器的结构">
    <br>
    图5.3 半路由器的结构
</div>

### 5.2.2 三层交换机

三层交换机具有以下特征：

1. 转发基于第三层地址的业务流。
2. 完全交换功能。
3. 可以完成特殊服务，如报文过滤或认证。
4. 执行或不执行路由处理。

第三层交换机与传统路由器相比有如下优点：

1. 子网间传输带宽可任意分配。传统路由器每个接口连接一个子网，子网通过路由器进行传输的速率被接口的带宽所限制。而三层交换机可以把多个端口定义成一个虚拟网，把多个端口组成的虚拟网作为虚拟网接口，该虚拟网内信息可通过组成虚拟网的端口送给三层交换机。由于端口数可任意指定，子网间传输带宽没有限制。
2. 合理配置信息资源。在全局网中设置服务器群不仅节省费用，更可以合理配置信息资源。
3. 降低成本。采用三层交换机进行网络设计，既可以进行任意虚拟子网划分，又可以通过交换机三层路由功能完成子网间通信，为此节省了价格昂贵的路由器。
4. 交换机之间连接灵活。三层交换机用生成树算法阻塞造成回路的端口，但进行路由选择时，依然把阻塞掉的通路作为可选路径参与路由选择。

### 5.2.3 网关

网关可能工作在 OSI 模型的所有七层中。网关是一个协议转换器。路由器只能在使用相同网络层协议的网络中转发、接收和中继包，而网关可以接收一种协议格式的包，然后在转发之前将它转换为另一种协议的格式。

网关通常是安装在路由器内部的软件。一个网关知道连接到路由器上的每个网络所使用的协议。

## 5.3 路由选择原理

路由选择就是网络中各个节点为到来的数据包选择一条输出链路。如果网络内部使用数据报（无连接的网络服务），那么就必须为每个到来的包做一次路由选择；如果网络内部使用虚电路（面向连接的网络服务），则仅在建立一个虚电路时做一次路由选择，以后各数据包都按建立的路由传输。

路由选择算法的基本要求：

1. 正确性。即路由算法必须是正确的，路由不能有回路。
2. 简单性。即算法在计算上应该简单，使延迟增加很少。
3. 坚定性。是指可靠性，长时间运行不会出现整个系统的故障。
4. 稳定性。指算法是收敛的，即当网络拓扑和通信量发生变化时，路由算法应收敛于一个可以接受的解，而不会产生过多的震荡，使其在一些路由之间来回不停地变化。
5. 公平性。指各通信节点利用信道的机会均等，不会使有的节点负载过重，而有的节点负载过轻。
6. 最佳性。指按一定的标准获得最好的效果。

在路由中，具有最短距离的路径是最佳的路径，距离最短的标准可以是费用最小、传输延迟最小、数据传输速率最大以及这些因素的一种组合。有两种最常用的计算最短路径的方法：距离向量路由算法、链路状态路由算法。

### 5.3.1 距离向量路由算法

在距离向量路由算法中，每个路由器周期性地将自己关于整个网络的信息发送给它的邻居。这个算法有 3 个要点：

1. 每个路由器保存关于整个网络的信息。最初，路由器所知道的关于网络的信息可能是有限的、不完全的，但是经过和邻居的若干次信息交换，路由器就会较全面地掌握关于网络的信息。
2. 仅仅和邻居交换网络信息。这种信息将被每个邻居路由器接收和保存，并被邻居路由器用来更新自己的关于网络的信息。
3. 信息的交换是通过有规律的时间间隔来进行的。时间间隔通常为 30 秒。

以图 5.4 所示的互连网络为例，简单介绍距离向量路由算法的基本思想。假设每条链路的距离为 1。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.4-互连网络的例子.1l07axmdfadc.png" alt="互连网络的例子">
    <br>
    图5.4 互连网络的例子
</div>

每个路由器依据路由表来转发数据包，距离向量路由算法的路由表中的每一项一般具有如下格式：
$$
\text{NetID:Distance:Nexthop}
$$

其中，NetID 表示数据包应到达的目的网络，Distance 表示到达目的网络的距离，Nexthop 表示要转发到的路由器。表 5.1 以图 5.4 所示的网络为例说明路由表是如何创建和更新的。

<table>
    <caption>表5.1 路由表的创建和更新</caption>
    <tr align="center">
        <th rowspan="2">轮次</th>
        <th rowspan="2">路由器</th>
        <th colspan="7">目的网络</th>
    </tr>
    <tr align="center">
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
        <td>5</td>
        <td>6</td>
        <td>7</td>
    </tr>
    <tr align="center">
        <td rowspan="6">0</td>
        <td>A</td>
        <td>1:1:-</td>
        <td>2:∞:?</td>
        <td>3:1:-</td>
        <td>4:∞:?</td>
        <td>5:1:-</td>
        <td>6:∞:?</td>
        <td>7:∞:?</td>
    </tr>
    <tr align="center">
        <td>B</td>
        <td>1:1:-</td>
        <td>2:1:-</td>
        <td>3:∞:?</td>
        <td>4:∞:?</td>
        <td>5:∞:?</td>
        <td>6:∞:?</td>
        <td>7:∞:?</td>
    </tr>
    <tr align="center">
        <td>C</td>
        <td>1:∞:?</td>
        <td>2:1:-</td>
        <td>3:∞:?</td>
        <td>4:∞:?</td>
        <td>5:∞:?</td>
        <td>6:1:-</td>
        <td>7:∞:?</td>
    </tr>
    <tr align="center">
        <td>D</td>
        <td>1:∞:?</td>
        <td>2:∞:?</td>
        <td>3:∞:?</td>
        <td>4:∞:?</td>
        <td>5:∞:?</td>
        <td>6:1:-</td>
        <td>7:1:-</td>
    </tr>
    <tr align="center">
        <td>E</td>
        <td>1:∞:?</td>
        <td>2:∞:?</td>
        <td>3:∞:?</td>
        <td>4:∞:?</td>
        <td>5:1:-</td>
        <td>6:∞:?</td>
        <td>7:1:-</td>
    </tr>
    <tr align="center">
        <td>F</td>
        <td>1:∞:?</td>
        <td>2:∞:?</td>
        <td>3:1:-</td>
        <td>4:1:-</td>
        <td>5:∞:?</td>
        <td>6:∞:?</td>
        <td>7:∞:?</td>
    </tr>
    <tr align="center">
        <td rowspan="6">1</td>
        <td>A</td>
        <td>1:1:-</td>
        <td>2:2:B</td>
        <td>3:1:-</td>
        <td>4:2:F</td>
        <td>5:1:-</td>
        <td>6:∞:?</td>
        <td>7:2:E</td>
    </tr>
    <tr align="center">
        <td>B</td>
        <td>1:1:-</td>
        <td>2:1:-</td>
        <td>3:2:A</td>
        <td>4:∞:?</td>
        <td>5:2:A</td>
        <td>6:2:C</td>
        <td>7:∞:?</td>
    </tr>
    <tr align="center">
        <td>C</td>
        <td>1:2:B</td>
        <td>2:1:-</td>
        <td>3:∞:?</td>
        <td>4:∞:?</td>
        <td>5:∞:?</td>
        <td>6:1:-</td>
        <td>7:2:D</td>
    </tr>
    <tr align="center">
        <td>D</td>
        <td>1:∞:?</td>
        <td>2:2:C</td>
        <td>3:∞:?</td>
        <td>4:∞:?</td>
        <td>5:2:E</td>
        <td>6:1:-</td>
        <td>7:1:-</td>
    </tr>
    <tr align="center">
        <td>E</td>
        <td>1:2:A</td>
        <td>2:∞:?</td>
        <td>3:2:A</td>
        <td>4:∞:?</td>
        <td>5:1:-</td>
        <td>6:2:D</td>
        <td>7:1:-</td>
    </tr>
    <tr align="center">
        <td>F</td>
        <td>1:2:A</td>
        <td>2:∞:?</td>
        <td>3:1:-</td>
        <td>4:1:-</td>
        <td>5:2:A</td>
        <td>6:∞:?</td>
        <td>7:∞:?</td>
    </tr>
    <tr align="center">
        <td rowspan="6">2</td>
        <td>A</td>
        <td>1:1:-</td>
        <td>2:2:B</td>
        <td>3:1:-</td>
        <td>4:2:F</td>
        <td>5:1:-</td>
        <td>6:3:B</td>
        <td>7:2:E</td>
    </tr>
    <tr align="center">
        <td>B</td>
        <td>1:1:-</td>
        <td>2:1:-</td>
        <td>3:2:A</td>
        <td>4:3:A</td>
        <td>5:2:A</td>
        <td>6:2:C</td>
        <td>7:3:A</td>
    </tr>
    <tr align="center">
        <td>C</td>
        <td>1:2:B</td>
        <td>2:1:-</td>
        <td>3:3:B</td>
        <td>4:∞:?</td>
        <td>5:3:A</td>
        <td>6:1:-</td>
        <td>7:2:D</td>
    </tr>
    <tr align="center">
        <td>D</td>
        <td>1:3:C</td>
        <td>2:2:C</td>
        <td>3:3:E</td>
        <td>4:∞:?</td>
        <td>5:2:E</td>
        <td>6:1:-</td>
        <td>7:1:-</td>
    </tr>
    <tr align="center">
        <td>E</td>
        <td>1:2:A</td>
        <td>2:3:D</td>
        <td>3:2:A</td>
        <td>4:3:A</td>
        <td>5:1:-</td>
        <td>6:2:D</td>
        <td>7:1:-</td>
    </tr>
    <tr align="center">
        <td>F</td>
        <td>1:2:A</td>
        <td>2:3:A</td>
        <td>3:1:-</td>
        <td>4:1:-</td>
        <td>5:2:A</td>
        <td>6:∞:?</td>
        <td>7:3:A</td>
    </tr>
    <tr align="center">
        <td rowspan="6">3</td>
        <td>A</td>
        <td>1:1:-</td>
        <td>2:2:B</td>
        <td>3:1:-</td>
        <td>4:2:F</td>
        <td>5:1:-</td>
        <td>6:3:B</td>
        <td>7:2:E</td>
    </tr>
    <tr align="center">
        <td>B</td>
        <td>1:1:-</td>
        <td>2:1:-</td>
        <td>3:2:A</td>
        <td>4:3:A</td>
        <td>5:2:A</td>
        <td>6:2:C</td>
        <td>7:3:A</td>
    </tr>
    <tr align="center">
        <td>C</td>
        <td>1:2:B</td>
        <td>2:1:-</td>
        <td>3:3:B</td>
        <td>4:4:B</td>
        <td>5:3:A</td>
        <td>6:1:-</td>
        <td>7:2:D</td>
    </tr>
    <tr align="center">
        <td>D</td>
        <td>1:3:C</td>
        <td>2:2:C</td>
        <td>3:3:E</td>
        <td>4:4:E</td>
        <td>5:2:E</td>
        <td>6:1:-</td>
        <td>7:1:-</td>
    </tr>
    <tr align="center">
        <td>E</td>
        <td>1:2:A</td>
        <td>2:3:D</td>
        <td>3:2:A</td>
        <td>4:3:A</td>
        <td>5:1:-</td>
        <td>6:2:D</td>
        <td>7:1:-</td>
    </tr>
    <tr align="center">
        <td>F</td>
        <td>1:2:A</td>
        <td>2:3:A</td>
        <td>3:1:-</td>
        <td>4:1:-</td>
        <td>5:2:A</td>
        <td>6:4:A</td>
        <td>7:3:A</td>
    </tr>
</table>

在第 0 轮次中，各路由器还没有和其他路由器交换信息，只知道与它直接相连的网络的距离。例如，路由器 A 到 Net1 的路由信息为 1:1:- ，表示 A 到 Net1 的距离为 1，可以直接到达目的网络；路由器 A 到 Net2 的路由信息为 2:∞:? ，表示 A 不知道到 Net2 的路由信息，不知道距离是多少，也不知道转发到哪个路由器上。

在第 1 轮次中，各个路由器和相邻的路由器进行了一次信息交换，并根据从邻居获得的网络信息更新自己的路由表。例如， A 从邻居路由器得到如下路由信息：B{(1:1:-), (2:1:-)}、E{(5:1:-), (7:1:-)}、F{(3:1:-), (4:1:-)}。这样 A 就知道到达 Net1 有两条路径：一条是从 A 直接到达 Net1，距离为 1；另一条是从 A 到 B，然后从 B 到达 Net1，总距离为 2。所以 A 选择最短的一条，从 A 直接到达 Net1。同样地，A 可以获得到达 Net2、Net3、Net4、Net5、Net7 的路由信息。

如此往复，继续进行信息交换，最终所有的路由器都知道了到所有网络的路由。

距离向量路由算法的优点：

1. 简单，适用于小规模网络。
2. 信息交换不要求同步。

距离向量路由算法的缺点：

1. 网络规模的伸展性差。
2. 对链路状态的变化响应慢。
3. 路由报文尺寸大，且报文长度与路由器个数成正比。

### 5.3.2 链路状态路由算法

在链路状态路由算法中，每个路由器和互连网络中的所有其他路由器共享关于其邻居的信息。链路状态路由算法有 3 个要点：

1. 共享关于邻居的信息。路由器仅仅发送关于自己邻居的信息，而不是像距离向量路由算法那样发送整个路由表。
2. 共享的信息发给所有的路由器。每个路由器将关于自己邻居的信息发送给互连网络中所有其他路由器，而不是像距离向量路由算法那样仅仅发送给它的邻居。
3. 信息的共享在有规律的时间间隔内进行。链路状态路由中的时间间隔比距离向量路由中的时间间隔要长，链路状态路由中的时间间隔通常是 30 分钟，而距离向量路由中的时间间隔通常是 30 秒。

链路状态路由分为两步：

1. 共享链路状态信息，即每个路由器将它自己和它的所有邻居之间的链路状态信息发送给互连网络中的所有其他路由器。
2. 每个路由器根据自己所掌握的关于整个网络的链路状态信息计算出到每个网络的路由，建立路由表。

#### 5.3.2.1 链路状态信息共享

1. 路由器传输包的费用

在链路状态路由中，费用是许多因素的加权值。这些因素包括安全级别、流量和链路的传输速率等。

一个路由器到另一个路由器的费用的计算方法：两个路由器通过网络相连，假设路由器编号为 A 和 B，网络编号为 Net1，则 A 到 B 的费用 = A 到 Net1 的费用，而 Net1 到 B 的费用不计。这是因为，路由器相当于网络中的一个站点，当 A 发送的包到达 Net1 时，Net1 的所有站点都可以收到这个包，包括路由器 B。

图 5.5 所示的例子展示了每个路由器的每个输出链路的费用。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.5-链路状态路由中的费用.5m7k3onp2nk0.png" alt="链路状态路由中的费用">
    <br>
    图5.5 链路状态路由中的费用
</div>

2. 链路状态包

路由器通过向整个互连网络中的所有路由器发送链路状态包（Link State Package，LSP），在网络中扩散关于自己邻居的信息。一个 LSP 通常包含 4 个信息域：广告者的 ID、所影响的目标网络 ID、费用、邻居路由器的 ID。

3. 获得关于邻居路由器的信息

每个路由器都周期性地发送一个简短的问候包来获取关于邻居的信息。如果邻居对问候做出响应，它的这个邻居就被认为是活跃的且起作用的；如果没有响应，那么它的这个邻居被认为发生了某种变化，发送问候包的路由器将通过它的下一个 LSP 向网络的其他部分发出警告。

4. 初始化

每个路由器在启动时向它的所有邻居发送一个问候包来获取每条链路的状态信息，然后它基于这些问候的结果准备一个 LSP，并将它扩散到整个网络。

5. 链路状态数据库

每个路由器接收每个其他路由器发送来的 LSP，并将它们的信息存放到一个链路状态数据库中。由于每个路由器接收相同的 LSP，每个路由器将创建相同的链路状态数据库。如果一个路由器被删除或加入网络中，所有的链路状态数据库将被更新。表 5.2 是图 5.7 所对应的网络的链路状态数据库。

<center>表5.2 链路状态数据库</center>

| 相关网络 | 广告者 | 费用 | 邻居 |
| :------: | :----: | :--: | :--: |
|    1     |   A    |  1   |  B   |
|    3     |   A    |  3   |  F   |
|    5     |   A    |  2   |  E   |
|    1     |   B    |  4   |  A   |
|    2     |   B    |  2   |  C   |
|    2     |   C    |  5   |  B   |
|    6     |   C    |  2   |  D   |
|    6     |   D    |  5   |  C   |
|    7     |   D    |  3   |  E   |
|    7     |   E    |  2   |  D   |
|    5     |   E    |  3   |  A   |
|    3     |   F    |  2   |  A   |
|    4     |   F    |  3   |  -   |

#### 5.3.2.2 使用Dijkstra算法计算路由表

Dijkstra 算法使用由结点和弧组成的图计算网络中两点之间的最短路径。结点有两种类型：网络和路由器。弧也有两类：路由器到网络的链路和网络到路由器的链路。从路由器到网络的链路的费用才有效，从网络到路由器的链路的费用总是 0。

当一个路由器拥有一个完整的链路状态数据库之后，它先为自己创建一个最短路径树，然后根据这个最短路径树形成自己的路由表。

路由器计算最短路径树的步骤：

1. 选择自己作为树的根，并将根标记为永久性结点。接着从根出发连接它的所有邻居结点，这种连接是临时性的。
2. 比较所有的临时连接，找出费用最小的路径，这个路径上的所有弧和结点被标记为最短路径树上的永久部分。
3. 考察链路状态数据库，找出从这个选定的最短路径向外延伸所能连接的所有非永久性结点，将这些结点临时性地加到最短路径树上。
4. 如果所有的结点已经成为最短路径树的永久部分，则算法结束，去掉非永久性的弧；否则，转步骤 2 继续执行。

以图 5.5 中路由器 A 为例，展示最短路径树的建立过程。A 建立自己的最短路径树的过程如下：

1. 选自己为树的根，即 A 为树的根，将 A 的邻居临时连接到 A 上，如图 5.6 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.6-算法运行过程1.7gpt4mjcz580.png" alt="算法运行过程1">
    <br>
    图5.6 算法运行过程1
</div>

2. 找出图 5.6 中从根出发的 3 条路径中最短的那条，将这条路径中的所有结点和弧标记为永久部分，如图 5.7 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.7-算法运行过程2.5ljfne73dbw0.png" alt="算法运行过程2">
    <br>
    图5.7 算法运行过程2
</div>

3. 考察链路状态数据库，找出从这个选定的最短路径向外延伸所能连接的所有结点，将这些结点临时加到最短路径树上。从 Net1 向外延伸只能连接结点 B，所以将 B 临时加到树上，如图 5.8 所示。图中标注的费用为从 A 到该结点的总费用。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.8-算法运行过程3.1fk293wb4q68.png" alt="算法运行过程3">
    <br>
    图5.8 算法运行过程3
</div>

4. 还有网络不是树的永久部分，算法未结束。在树上的所有路径中找出最短的一条，即 A 到 B 的路径，将这条路径上的所有结点标记为永久部分，如图 5.9 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.9-算法运行过程4.697cfhhju2w0.png" alt="算法运行过程4">
    <br>
    图5.9 算法运行过程4
</div>

5. 从 B向外延伸只有一个结点 Net2，将 Net2 临时连接到 B，如图 5.10 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.10-算法运行过程5.1lyguzhtnb6o.png" alt="算法运行过程5">
    <br>
    图5.10 算法运行过程5
</div>

6. 算法未结束。A 到 Net5 的路径最短，这条路径上的所有结点标记为永久部分，并由 Net5 向外延伸，将 E 临时加到 Net5 上，如图 5.11 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.11-算法运行过程6.1ik9vs76fy2o.png" alt="算法运行过程6">
    <br>
    图5.11 算法运行过程6
</div>

7. 算法未结束。A 到 E 的路径最短，这条路径上的所有结点标记为永久部分，并由 E 向外延伸，将 Net7 临时加到 E 上，如图 5.12 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.12-算法运行过程7.5kyr9fiko9c0.png" alt="算法运行过程7">
    <br>
    图5.12 算法运行过程7
</div>

8. 算法未结束。A 到 Net2 的路径最短，这条路径上的所有结点标记为永久部分，并由 Net2 向外延伸，将 C 临时加到 Net2 上，如图 5.13 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.13-算法运行过程8.4j09uvnq5v20.png" alt="算法运行过程8">
    <br>
    图5.13 算法运行过程8
</div>

9. 算法未结束。A 到 C 的路径最短，这条路径上的所有结点标记为永久部分，并由 C 向外延伸，将 Net6 临时加到 C 上，如图 5.14 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.14-算法运行过程9.76dvsy94xog.png" alt="算法运行过程9">
    <br>
    图5.14 算法运行过程9
</div>

10. 算法未结束。A 到 Net3 的路径最短，这条路径上的所有结点标记为永久部分，并由 Net3 向外延伸，将 F 临时加到 Net3 上，如图 5.15 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.15-算法运行过程10.6dn1xumcbug0.png" alt="算法运行过程10">
    <br>
    图5.15 算法运行过程10
</div>

11. 算法未结束。A 到 F 的路径最短，这条路径上的所有结点标记为永久部分，并由 F 向外延伸，将 Net4 临时加到 F 上，如图 5.16 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.16-算法运行过程11.59uehtdr2b80.png" alt="算法运行过程11">
    <br>
    图5.16 算法运行过程11
</div>

12. 算法未结束。A 到 Net7 的路径最短，这条路径上的所有结点标记为永久部分，并由 Net7 向外延伸，将 D 临时加到 Net7 上，如图 5.17 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.17-算法运行过程12.3ojhec3f1020.png" alt="算法运行过程12">
    <br>
    图5.17 算法运行过程12
</div>

13. 算法未结束。A 到 D 的路径最短，这条路径上的所有结点标记为永久部分，并由 D 向外延伸，将 Net6 临时加到 D 上，如图 5.18 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.18-算法运行过程13.13yvcalxbw0w.png" alt="算法运行过程13">
    <br>
    图5.18 算法运行过程13
</div>

14. 算法未结束。A 到 Net6 的路径最短，这条路径上的所有结点标记为永久部分。由于 Net6 的所有邻居结点都是永久性结点，Net6 为叶结点，不再向外延伸。如图 5.19 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.19-算法运行过程14.5zkgfqx08vk0.png" alt="算法运行过程14">
    <br>
    图5.19 算法运行过程14
</div>

15. 算法未结束。A 到 Net4 的路径最短，这条路径上的所有结点标记为永久部分。由于 Net4 的所有邻居结点都是永久性结点，Net4 为叶结点，不再向外延伸。如图 5.20 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.20-算法运行过程15.3yai9o03j200.png" alt="算法运行过程15">
    <br>
    图5.20 算法运行过程15
</div>

16. 所有的结点都是永久性结点，算法结束，去掉非永久性的弧，所得到的图就是路由器 A 的最短路径树，如图 5.21 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.21-算法运行过程16.69rtq8aoqok0.png" alt="算法运行过程16">
    <br>
    图5.21 算法运行过程16
</div>

对应于这个最短路径树的路由表如图 5.22 所示，该路由表就是路由器 A 的路由表。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.22-路由器A的路由表.2hw4tr04osw0.png" alt="路由器A的路由表">
    <br>
    图5.22 路由器A的路由表
</div>

## 5.4 Internet路由问题

互连网络中可以提供两级路由选择算法：

1. 各网络内部使用内部网关协议（Interior Gateway Protocol，IGP）。
2. 网络之间使用外部网关协议（Exterior Gateway Protocol，EGP）。

互联网络中的每个网络都独立于其他网络，每个网络都可以看成一个自治系统（Autonomous System，AS）。一个自治系统中的所有路由器必须相互连接，运行相同的路由协议。每个自治系统运行自己的内部网关协议，但每个自治系统中都有一个或多个路由器除运行本系统的内部网关协议外，还运行自治系统间的外部网关协议。

内部网关协议：RIP、OSPF。

RIP（Routing Information Protocol，路由信息协议）是一种距离向量路由协议，适用于小规模自治系统。

OSPF（Open Shortest Path First，开放最短路径优先）是一种链路状态路由协议，是应用最广的路由协议。

外部网关协议：BGPv4。

BGPv4 是典型的外部网关协议，是现行的因特网实施标准，它完成自治系统间的路由选择。BGP 协议是一种距离向量协议，使用增量的、触发性的路由更新，而不是一般的距离向量协议的整个路由表的、周期性的更新。

## 5.5 虚电路中数据包的传输

包的传送依赖于路由表，每个交换节点都有一个虚电路路由表，表中的每一行记录了一个虚电路的信息，包括源地址、源虚电路号、目的地址、目的虚电路号。

在建立路由表时，每个节点对虚电路进行独立编号。对于源地址相同或目的地址相同的虚电路，使用不同的虚电路号加以区分，并且按照建立的先后顺序依次编号；对于源地址不同或目的地址不同的虚电路，允许虚电路号相同。按照这种编号方式，同一条虚电路上各段的虚电路号可能不同，但是前一个节点的目的虚电路号和后一个节点的源虚电路号一定相同。

例如，在图 5.23 所示的网络中，有 5 条虚电路：

1. VC~1~：H~1~→A→B→E→H~5~
2. VC~2~：H~1~→A→B→D→H~4~
3. VC~3~：H~2~→B→D→E→H~5~
4. VC~4~：H~3~→C→B→E→H~5~
5. VC~5~：H~1~→A→B→C→E→H~5~

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.23-示例网络.2h9s6fkh15u0.png">
    <br>
    图5.23 示例网络
</div>

对应的虚电路路由表如图 5.24 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.24-虚电路路由表.2wes46jeh2g0.png">
    <br>
    图5.24 虚电路路由表
</div>

虚电路服务是网络层向传输层提供的一种使所有分组按顺序到达目的端系统的可靠的数据传输方式，也是通信子网向端系统提供的网络服务。提供这种虚电路服务的通信子网内部的实际操作可以是虚电路方式，也可以是数据报方式。

以虚电路方式工作的网络一般总是提供虚电路服务。

以数据报方式工作的网络也可以提供虚电路服务，通信子网内部节点按数据报方式交换数据，而与端系统相连的网络节点向端系统提供虚电路服务。每个分组在网络节点分成若干数据报，以数据报的工作方式送到目的节点，目的节点再将数据报排序，送给端系统，从而满足虚电路服务的要求。

**【例题 5.1】** 两个用户之间的传输线路由 3 段组成,每段的传输延迟为 0.001s，呼叫建立时间为 0.2s，报文长 3200bit，分组大小为 1024bit，报头开销为 16bit，线路数率 9600bps。假设中间节点处理时间为零，试问在下列交换下的端到端的延迟：
(1)电路交换；(2)报文交换；(3)虚电路；(4)数据报。

**解**：（1）电路交换

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/例5.1-1-电路交换.3pesm6h7mkk0.png" height="400px">
</div>

（2）报文交换

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/例5.1-2-报文交换.5h6z47iu56w0.png" height="400px">
</div>

（3）虚电路

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/例5.1-3-虚电路.4x2h6m61ip60.png" height="400px">
</div>

（4）数据报

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/例5.1-4-数据报.gxiatche9jc.png" height="400px">
</div>

## 5.6 拥塞控制和流量控制

### 5.6.1 拥塞控制

网络或其一部分出现过多的包，导致网络性能下降的现象称为拥塞。拥塞控制的基本目的是防止整个网络或网络的一部分出现过多的数据包。

图 5.25 展示了包交换节点的模型。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.25-包交换节点队列模型.2zn5yfks10c0.png">
    <br>
    图5.25 包交换节点队列模型
</div>
对于包交换网络中的每一个节点，它一般和多个其他节点或主机相连接，因此该节点有多条链路。每条链路上有两个队列，即输入队列和输出队列。输入队列和输出队列其实就是两个缓冲区。输入队列用于存放从链路接收的但还没来得及处理的包，输出队列用于存放将要向链路上发送的包。

包的延迟时间受输入队列和输出队列长度的影响。造成输入队列过长的原因是节点的处理速度有限，造成输出队列过长的原因是链路的传输能力有限。所以造成拥塞的原因主要有两个：节点的处理速度和链路的传输速度不够高。

拥塞会造成系统吞吐量的显著降低和包传输延迟的急剧增加。图 5.26 展示了拥塞对系统性能的影响，图 5.26(a) 表示拥塞对系统吞吐量的影响，图 5.26(b) 表示拥塞对包延迟的影响。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.26-拥塞对系统的影响.6qnu9yuj0qo0.png">
    <br>
    图5.26 拥塞对系统的影响
</div>

在理想情况下，系统的吞吐量随着输入负载的增加而增加，当输入负载达到系统的理论最大传输能力时，系统的吞吐量也达到系统的理论最大传输能力，系统的利用率达到 100%。此后随着输入负载的增加，系统的吞吐量维持在这个最大值上。如果没有拥塞控制，随着输入负载的增加，系统的吞吐量会逐渐增加到某个最大值，此时当输入负载继续增加时系统的吞吐量反而会下降。在极端的情况下，系统的吞吐量会降为 0，造成整个系统的瘫痪。为了防止拥塞的发生，需要进行拥塞控制。拥塞控制需要额外的代价，所以在有拥塞控制的情况下，系统的吞吐量不可能达到理想时的水平。

无论有没有拥塞控制，包延迟都会随着输入负载的增加而无限增加。在无拥塞控制的情况下，随着输入负载的增加，系统会较早地进入饱和状态。在轻负载的情况下，有拥塞控制时包的延迟反而比无拥塞控制时的大，这是因为拥塞控制需要额外的开销。

控制拥塞的方法：

1. 预分配缓冲区。这种方法常用于虚电路技术中，虚电路的建立会通知该虚电路上的相关节点为此虚电路预留缓冲区。如果建立虚电路的请求到达某节点，而这个节点没有缓冲区可以预留，这个节点就会拒绝该请求，网络会为此申请另选一条路径。在没有路径可选时，通知源节点建立虚电路的请求被拒绝。
2. 丢弃包。当某个节点上收到过多的包而来不及处理或无法发送出去时，可丢弃一部分包。被丢弃的包最终会重发。如果拥塞是由突发的通信造成的，那么拥塞只是零星的，系统会消除拥塞；如果长时间出现大的通信量，丢弃包的方法是行不通的。
3. 限制网内包数量。可以在网内设置若干个许可证，某个节点想发送数据包时，必须先获得一个许可证。当它发送完一个包时，就释放它所获得的许可证。
4. 流量控制。接收端调节发送端发送数据的速率，防止到达接收端的数据速率超过接收端的处理速率。
5. 阻塞包。每个节点都监视其所有输出链路的使用情况，当达到一定的状态时就进入“警戒”状态。对每个新到达的包，都要检查其输出链路是否处于警戒状态，如果其输出链路处于警戒状态，则此节点向发送此包的源主机发送一个阻塞包。

### 5.6.2 流量控制

流量控制的目的是保证发送方发送的信息量不会超过接收方的接收能力。

如图 5.27 所示，流量控制可以在如下层次上进行：主机—主机间的流量控制、源节点—目的节点间的流量控制、主机—源节点间的流量控制、相邻节点间的流量控制。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.27-流量控制层次.uhargsaahgg.png">
    <br>
    图5.27 流量控制层次
</div>

主机与主机间的流量控制一般要由传输层协议来实现。在通信子网内，源节点和目的节点之间的流量控制由网络层协议来实现。相邻节点间的流量控制主要由数据链路层来实现。主机和源节点间流量控制也称为网络访问流量控制，可由数据链路层或网络层实现。

#### 5.6.2.1 主机和源节点间的流量控制

主机和源节点间的流量控制本质上是控制进入通信子网的信息量，它是在测量网络内部拥塞的基础上控制输入网络的通信量。拥塞的测量可以是局部的，即只测量源节点中缓冲区的占用程度；拥塞的测量可以是全局的，即测量整个网络中缓冲区的占用程度；拥塞的测量也可以是选择性的，例如，测量到达目的节点的整条路径的拥塞情况。将测量的结果报告给源节点，以控制从外部进入网内的通信量。

主机和源节点间的流量控制所采用的方法主要有停止等待流量控制、缓冲区预约、许可证方案。

#### 5.6.2.2 源节点和目的节点之间的流量控制

源节点和目的节点之间流量控制的任务是和通信子网的工作方式紧密相关的。如果通信子网采用虚电路工作方式，该层流量控制的任务就比较轻，因为虚电路方式本身要有基本的缓冲区，包沿固定路径传送，又有滑动窗口控制，且包按顺序到达目的节点。

如果通信子网采用数据报方式工作，而缓冲区的分配采用先来先服务且全部分配的方法，则有可能产生如图 5.28 所示的存储转发死锁。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.28-存储转发死锁.5l467y79hmo0.png">
    <br>
    图5.28 存储转发死锁
</div>

图 5.28(a) 是直接存储转发死锁。这时，节点 A 的所有缓冲区都装满了要发往节点 B 的包，节点 B 的所有缓冲区也装满了要发往 A 节点的包。A 等待 B 能释放出缓冲区，以使 A 能够向 B 发送数据包；B 也等待 A 能释放出缓冲区，以使 B 能够向 A 发送数据包。A 和 B 循环等待，即发生了死锁。

图 5.28(b) 是间接存储转发死锁。A、B、C 三个节点的缓冲区都满了，不能再接收更多的包。A 要向 B 发送包，而 B 的缓冲区满了，不能接收任何包，A 要等待 B 发送一个包，释放出一个缓冲空间后，才能向 B 发送。同理，B 要等待 C，C 要等待 A。出现循环等待，从而发生了死锁。

发生了存储转发死锁后，系统就不能传输任何包。在数据报工作方式中，只要保证每条输入链路有一个空缓冲区，并允许丢弃包，则可防止存储转发死锁。

如果通信子网采用数据报工作方式，在向传输层提供虚电路服务时，需要在目的节点将包重新装配成报文，这时可能会出现重装死锁。图 5.29 是一个重装死锁的例子。报文 A 分成 4 个包 A~1~、A~2~、A~3~、A~4~，报文 A 在节点 Y 上已经占了 4 个缓冲区，虽然包 A~3~ 还没有到达 Y，但是其缓冲区已经保留好。由于缺少包 A~3~，不能形成一个完整的报文，不能交付给主机 H。包 A~3~ 暂存于节点 X 的缓冲区中，但由于 A~3~ 前面的包 B~1~ 无法转发到节点 Y 中，导致 A~3~ 无法转发到 Y 中，从而导致死锁。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.29-重装死锁.5175oo0xrgo0.png">
    <br>
    图5.29 重装死锁
</div>

ARPANET 采用了分配重装缓冲并预约缓冲的方法，该方法能够解决重装死锁。源节点在发送报文之前，先向目的节点发送一个请求缓冲区的包，如果目的节点有足够的缓冲区，则返回一个准备接收包，此后源节点逐个发送报文的所有包。目的节点收到所有包后按顺序装配成报文，传送给主机，并向源主机返回一个“请求下一个报文”。如果预约包到达目的节点后，目的节点无缓冲区，则可在目的节点等待缓冲。超时仍无缓冲区可用，则预约失败，源节点重新发送预约包。

## 5.7 IP协议

IP 协议是 TCP/IP 协议族中的核心协议，所有的 TCP、UDP、ICMP、IGMP 数据都封装在 IP 数据报中传输。IP 协议为高层提供不可靠、无连接的数据报通信。

IP 协议提供的不可靠服务是指它不能保证 IP 数据报能成功地到达目的地，它仅提供尽可能好的服务。如果发生错误，IP 协议直接丢弃数据报，然后向该数据报的源地址对应的主机发送 ICMP 报文。任何要求的可靠性必须由上层来提供。

无连接是指 IP 协议并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的，IP 数据报可以不按发送顺序接收。

### 5.7.1 IP地址

网络中的每个独立主机的每个接口必须有一个唯一的 Internet 地址，称为 IP 地址。IP 地址长度为 32 位。32 位的 IP 地址通常写成点分的 4 个十进制数，其中每个十进制数对应一个字节，这种表示方法称为 “点分十进制表示法”（dotted decimal notation）。

IP 地址按照层次结构划分成 5 类，如图 5.30 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.30-IP地址分类.3a4kt32j9cy0.png">
    <br>
    图5.30 IP地址分类
</div>

区分各类地址的最简单方法是检查地址的第一个十进制数。表 5.3 列出了各类地址的起止范围。

<table>
    <caption>表5.3 各类 IP 地址的范围</caption>
    <tr align="center">
        <th>类型</th>
        <th>范围</th>
    </tr>
    <tr align="center">
        <td>A</td>
        <td>0.0.0.0 到 127.255.255.255</td>
    </tr>
    <tr align="center">
        <td>B</td>
        <td>128.0.0.0 到 191.255.255.255</td>
    </tr>
    <tr align="center">
        <td>C</td>
        <td>192.0.0.0 到 223.255.255.255</td>
    </tr>
    <tr align="center">
        <td>D</td>
        <td>224.0.0.0 到 239.255.255.255</td>
    </tr>
    <tr align="center">
        <td>E</td>
        <td>240.0.0.0 到 247.255.255.255</td>
    </tr>
</table>

国际互联网络信息中心（Internet Network Information Center，InterNIC）是一个用来分配 IP 地址的管理机构。InterNIC 只分配网络号，主机号的分配由本地的网络管理员负责。InterNIC 由 3 部分组成：注册服务（rs.internic.net）、目录和数据服务（ds.internic.net）、信息服务（is.internic.net）。

按照通信方式来分类，IP 地址分为 3 类：单播地址（目的地址为单个主机）、广播地址（目的地址为指定网络上的所有主机）、多播地址（目的地址为同一组中的所有主机）。

在 TCP/IP 环境中，域名系统（Domain Name System，DNS）是一个分布式数据库系统，通过它来提供 IP 地址和主机名之间的映射。

特殊的 IP 地址：

1. 网络地址：主机号部分全为 “0”。
2. 直接广播地址：主机号部分全为 “1”，网络号部分指定一个网络，将数据报发送给指定网络上的所有主机。
3. 有限广播地址：32 位全为 “1”，即 255.255.255.255，将数据报发送给当前网络上的所有主机。
4. 本机地址：32 为全为 “0”，即 0.0.0.0。
5. 回送地址：127.0.0.1，常用于本机上软件测试和本机上网络应用程序之间的通信地址。
6. 本网中的主机：网络号部分全为 “0”，主机号部分指定一个主机。

### 5.7.2 子网编址与子网掩码

子网编址是把主机号进一步划分为一个子网号和一个主机号。目前所有的主机都要求支持子网编址。

子网掩码用于确定 IP 地址中哪些比特用于子网号，哪些比特用于主机号。子网掩码是一个 32 位的数值，其中值为 1 的比特用于网络号和子网号，为 0 的比特用于主机号。IP 地址中与子网掩码的 1 相对应的位构成了网络号和子网号，IP 地址中与子网掩码的 0 相对应的位构成了主机号。

通过 IP 地址可以确定它的类型，也就知道了网络号和子网号之间的分界线。而根据子网掩码就可以知道子网号和主机号的分界线。

知道 IP 地址和子网掩码后可以算出网络地址、广播地址、地址范围和网络中能容纳的主机数量。

**【例题 5.2】** IP 地址为 192.168.100.5，子网掩码为 255.255.255.0，计算网络地址、广播地址、地址范围、主机数。

**解**：将 IP 地址和子网掩码换算为二进制，子网掩码连续全 1 的是网络地址，后面的是主机地址。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/例5.2.re4skrjxaqo.png">
</div>

网络地址：192.168.100.0

广播地址：192.168.100.255

地址范围：网络地址+1 至 广播地址-1，即 192.168.100.1 至 192.168.100.254

主机数量：$2^8-2=254$

### 5.7.3 IPv4报文格式

IPv4 数据报的格式如图 5.31 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.31-IPv4数据报格式.47fko51xt5k0.png">
    <br>
    图5.31 IPv4数据报格式
</div>

如果不含选项字段，IP 报头长度为 20 字节。

IPv4 数据报报头中的各字段说明如下：

1. 版本号字段：IPv4 的版本号为 4。
2. 报头长度字段：报头长度指的是报头占 32 位字的数量，包括任选项字段。由于报头长度字段为 4 比特，因此报头最长为 60 个字节。对于一般的数据报，该字段的值为 5，即报头长度为 20 字节。
3. 服务类型字段：服务类型（Type of Service，ToS）字段包括一个 3 比特的优先权字段、4 比特的 ToS 子字段和 1 比特未用位，其中未用位必须置 0。4 比特的 ToS 分别表示最小延迟、最大吞吐量、最高可靠性和最小费用，4 比特只能将其中一位置 1。如果所有 4 比特均为 0，则表示一般的服务。
4. 总长度字段：整个 IP 数据报的长度，以字节为单位。利用报头长度字段和总长度字段就可以判断 IP 数据报中数据部分的起始位置和长度。由于总长度字段的长度为 16 比特，IP 数据报的最大长度可达 65535 字节，但在实际使用中一般达不到最大长度。如果数据报长度超过了信道可以传输的最大数据长度，就需要将数据报分段，总长度字段的值也要随之变化。
5. 标识字段：标识字段唯一地标识主机发送的每一个数据报。当数据报被分段时，同一数据报的每个分段将在标识字段中使用一个相同的值来识别。
6. 标志字段：3 位标志位的第一位没有使用；第二位为 DF 位，DF 位为 1 表示不要分段；第三位是 MF 位，MF 位为 1 表示该分段之后还有其他分段，最后一个分段的 MF 位为 0。
7. 偏移量字段：分段偏移说明该分段在当前数据报的什么位置。分段偏移以 8 字节为单位，偏移量 1 对应字节号 8，偏移量 2 对应字节号 16，以此类推。每个分段的长度必须是 8 的整数倍。
8. 生存时间（TTL）字段：设置了数据报可以经过的最多路由器数量。每经过一个路由器，TTL 字段的值就减去 1。当 TTL 字段的值为 0 时，该数据报被丢弃，并发送 ICMP 报文通知源主机。
9. 协议字段：IP 数据报的上层携带的协议。
10. 报头检查和字段：根据 IP 报头计算的检查和，不包括数据部分。为了计算一个数据报的 IP 检查和，首先把检查和字段置为 0，然后对报头中的每个 16 比特进行二进制反码求和，并对最终的求和结果取反，存放在检查和字段中。接收方收到 IP 数据报后，同样对报头中每个 16 比特进行二进制反码求和，如果求和结果为全 1，说明传输没有差错；如果结果不是全 1，就丢弃该数据报，但不生成差错报文，由上层去发现丢失的数据报并进行重传。
11. 源 IP 地址和目的 IP 地址字段。
12. 任选项字段：数据报中一个可变长度的可选信息。任选项字段都是以 32 比特作为界限，在必要时插入值为 0 的填充字节，以保证 IP 报头始终是 32 比特的整数倍。

### 5.7.4 IP路由选择

如果目的主机与源主机直接相连（点对点链路）或都在一个共享网络上（以太网或令牌环），那么 IP 数据报就直接送到目的主机上。否则，主机把数据报发往一个默认的路由器上，由该路由器负责转发该数据报。

当收到一个数据报时，IP 首先检查目的 IP 地址是否为本机的 IP 地址之一或者 IP 广播地址。如果是，该数据报就被送到上层协议模块进行处理，这个上层协议模块由 IP 报头的协议字段指定。如果不是，说明本机不需要接收该数据报，在这种情况下，如果 IP 层被设置为路由器功能，就对该数据报进行转发；如果 IP 层没有被设置为路由器功能，就丢弃该数据报。

IP 层在内存中维持一个路由表，当收到一个数据报并进行转发时，它都要对路由表搜索一次。路由表中的每一行包含如下信息：

1. 目的 IP 地址。它既可以是一个主机地址，也可以是一个网络地址，由路由表的标志字段指定。
2. 下一跳 IP 地址。它可能是一个路由器的 IP 地址，也可能是直接相连的网络 IP 地址。
3. 标志。其中一个标志指明目的 IP 地址是网络地址还是主机地址，另一个标志指明下一跳 IP 地址是一个路由器还是一个直接相连的接口。
4. 为数据报的传输指定一个网络接口。

IP 路由选择是逐跳进行的，所有的 IP 路由选择只为数据报传输提供下一跳路由器的 IP 地址。

IP 路由选择的步骤：

1. 检索路由表，寻找能与目的 IP 地址完全匹配的表项。如果找到，则把数据报发给该表项指定的下一跳路由器或直接连接的网络接口。如果未找到，转步骤 2。
2. 检索路由表，寻找能与目的网络号相匹配的表项。如果找到，则把数据报发给该表项指定的下一跳路由器。如果未找到，转步骤 3。
3. 检索路由表，寻找标为 “默认” 的表项。如果找到，则把数据报发给该表项指定的下一跳路由器。
4. 如果上述操作都不成功，那么该数据报就不能被传送。

为一个网络指定一个路由器，而不必为每个主机指定一个路由器，这是 IP 路由选择机制的另一个特性。这样就可以大大地缩小路由表的规模。

无类别域间路由（Classless Inter-Domain Routing，CIDR）通过把多个地址块组合到一个路由表表项，组成一个 CIDR 地址块，从而减少路由表的表项数量，减少由核心路由器承载的路由选择信息的数量。CIDR 取消了 IP 地址的分类结构，用一个前缀取代了原来地址结构对地址网络部分的限制。

IPv4 的 CIDR 地址块的表示方法是：由 4 部分组成的点分十进制地址，后跟一个斜杠，最后是范围在 0~32 之间的一个数字。斜杠后的数字表示前缀长度，也就是网络部分的长度。如果若干个 IP 地址的前 $N$ 位相同，就可以将它们组合在一起，用一个前缀为 $N$ 的 CIDR 地址块表示。

CIDR 的优点有：

1. 支持路由聚合。前缀相同的地址可以合并，减少了路由表项的数量，减少对路由器内存的占用，减少路由选择协议造成的网络流量。
2. 有利于地址分配。

### 5.7.5 IPv6

#### 5.7.5.1 IPv6基本报头

IPv6 将报头长度变为固定的 40 字节，称为基本报头（base header）。它取消了不必要的功能，将报头的字段数减少到 8 个，还取消了检验和字段。

IPv6 数据报在基本报头的后面允许有 0 个或多个扩展首部（extention header），再后面是数据。所有的扩展报头都不属于数据报的基本报头，所有的扩展报头和数据部分合起来称为数据报的有效载荷（payload）或净载荷。

IPv6 报文头格式如图 5.32 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.32-IPv6报文头格式.79byff28lvw0.png">
    <br>
    图5.32 IPv6报文头格式
</div>

IPv6 基本报头中各字段的作用如下：

1. 版本号（Version）：占 4 位。它指明了协议的版本，对 IPv6 该字段总是 6。
2. 通信类型（Traffic class）：占 8 位。这是为了区分不同 IPv6 数据报的类别或优先级。
3. 流标号（Flow Label）：占 20 位。IPv6 支持资源预分配，并且允许路由器将每一个数据报与一个给定的资源分配相联系。IPv6 提出流（flow）的抽象概念，所谓 “流” 就是互联网络上从特定源点到特定终点（单播或多播）的一系列数据报，所有属于同一个流的数据报都具有同样的流标号。
4. 有效载荷长度（Payload length）：占 16 位。它指明 IPv6 数据报除基本报头以外的字节数。这个字段的最大值是 64KB。
5. 下一个报头（Next header）：占 8 位。它相当于 IPv4 的协议字段或可选字段。当 IPv6 数据报没有扩展报头时，下一个报头字段的作用和 IPv4 的协议字段一样，它的值指出了基本报头后面的数据应交付给哪个高层协议；当出现扩展报头时，下一个报头字段的值就标识后面第一个扩展报头的类型。
6. 跳数限制（Hop limit）：占 8 位。相当于 IPv4 的生存时间字段，用来防止数据报在网络中无限期地存在。源站在每个数据报发出时设定某个跳数限制。每个路由器在转发数据报时，要先将跳数限制字段中的值减 1。当跳数限制的值为 0 时，将此数据报丢弃。
7. 源地址（Source Address）：占 128 位。是数据报的发送站的 IP 地址。
8. 目的地址（Destination Address）：占 128 位。是数据报的接收站的 IP 地址。

#### 5.7.5.2 IPv6扩展报头

IPv6 将原来 IPv4 报头中选项的功能都放在扩展报头中，并将扩展报头留给路径两端的源站和目的站的主机来处理，而数据报途中经过的路由器都不处理这些扩展报头（只有一个报头例外，即逐跳选项扩展报头），这样就大大提高了路由器的处理效率。

扩展报头有 6 种：逐跳选项报头、路由选择报头、分段报头、认证报头、ESP 协议报头、目的站选项报头。

#### 5.7.5.3 IPv6地址

IPv6 的 128 位地址以 16 位为一分组，每个分组写成 4 个十六进制数，中间用冒号分隔，称为冒号分十六进制格式。例如：21DA:00D3:0000:2F3B:02AA:00FF:FE28:9C5A。

IPv6 地址中，每个 16 位分组中的前导零位可以去除做简化表示，但每个分组必须至少保留一位数字。如上例中的地址，去除前导零位后可写成：21DA:D3:0:2F3B:2AA:FF:FE28:9C5A。

某些地址中可能包含很长的零序列，为进一步简化表示法，还可以将冒号十六进制格式中相邻的连续零位合并，用双冒号 “::” 表示。“::” 符号在一个地址中只能出现一次。例如，地址 1080:0:0:0:8:800:200C:417A 的压缩格式为 1080::8:800:200C:417A。

在 IPv4 和 IPv6 混合环境中，有时更适合于采用另一种表示形式：$x:x:x:x:x:x:d.d.d.d$。其中 $x$ 是地址中 6 个高阶 16 位分组的十六进制值，$d$ 是地址中 4 个低阶 8 位分组的十进制值（标准 IPv4 表示）。

#### 5.7.5.4 IPv6地址类型

IPv6 地址是独立的接口标识符，所有 IPv6 地址都被分配到接口，而非节点。节点的任意一个接口地址都可用来标识一个节点。

IPv6 有 3 种类型的地址：

1. 单点传送（单播）地址。一个 IPv6 单点传送地址与单个接口相关联。
2. 多点传送（组播）地址。一个多点传送地址标识多个接口，发给组播地址的包传送到该地址标识的所有接口上。IPv6 协议不再定义广播地址，其功能可由组播地址替代。
3. 任意点传送（任播）地址。一个 IPv6 任意点传送地址被分配给一组接口（通常属于不同的节点），发送给任播地址的包传送到该地址标识的一组接口中的任意一个。

IPv6 单点传送地址包括：可聚集全球单点传送地址、链路本地地址、站点本地地址和其他特殊的单点传送地址。

可聚集全球单点传送地址是可以在全球范围内进行路由转发的地址，格式前缀为 001，相当于 IPv4 公共地址。

本地单点传送地址的传送范围仅限于本地，又分为链路本地地址和站点本地地址两类。

链路本地地址：前缀为 1111 1110 10，用于同一链路的相邻节点间通信。链路本地地址相当于在当前 Windows 下使用 169.254.0.0/16 前缀的 APIPA IPv4 地址，其有效域仅限于本地链路。链路本地地址可用于邻居发现，且总是自动配置的，包含链路本地地址的包永远也不会被 IPv6 路由器转发。

站点本地地址：格式前缀为 1111 1110 11，相当于 10.0.0.0/8、172.16.0.0/12 和 192.168.0.0/16 等 IPv4 私用地址空间。

IPv6 的多点传送（组播）与 IPv4 运作相同。多点传送可以将数据传输给组内所有成员。组的成员是动态的，成员可以在任何时间加入一个组或退出一个组。IPv6 多点传送地址格式前缀为 1111 1111。

## 5.8 ARP：地址解析协议

地址解析协议（Address Resolution Protocol，ARP）是根据 IP 地址获取物理地址的协议。ARP 协议的基本功能是通过目的设备的 IP 地址，查询目的设备的物理地址，以保证通信的顺利进行。

### 5.8.1 ARP工作过程

主机发送信息时将包含目标 IP 地址的 ARP 请求广播到网络上的所有主机，并接收返回信息，以此确定目标的物理地址。收到返回消息后将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。

假设主机 A 要与主机 B 通信，ARP 协议的工作过程如下：

1. 主机 A 根据主机 B 的 IP 地址，在自己的本地 ARP 缓存中检查主机 B 的物理地址。
2. 如果主机 A 在 ARP 缓存中没有找到，它将 ARP 请求帧广播到本地网段上的所有主机，源主机 A 的 IP 地址和物理地址都包括在 ARP 请求中。本地网段上的每台主机都接收到 ARP 请求并且检查是否与自己的 IP 地址匹配。如果主机发现请求的 IP 地址与自己的 IP 地址不匹配，则丢弃 ARP 请求。
3. 主机 B 确定 ARP 请求中的 IP 地址与自己的 IP 地址匹配，则将主机 A 的 IP 地址和物理地址映射添加到本地 ARP 缓存中。
4. 主机 B 将包含其物理地址的 ARP 应答直接发送回主机 A。
5. 当主机 A 收到从主机 B 发来的 ARP 应答时，会用主机 B 的 IP 和物理地址映射更新 ARP 缓存。主机 B 的物理地址一旦确定，主机 A 就能向主机 B 发送 IP 通信了。

### 5.8.2 ARP缓存

ARP 缓存是用来存储 IP 地址和物理地址映射的缓冲区，其本质是一个 IP 地址到物理地址的映射表，表中每一项分别记录了网络上其他主机的 IP 地址和对应的物理地址。

通过使用 ARP 缓存，可以减少广播量，避免远程访问的开销，提高效率。

### 5.8.3 ARP报文格式

ARP 协议属于网络层中的最底层协议，ARP 报文直接封装在数据链路层的帧中，其格式如图 5.32 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.32-ARP报文格式.17mm5mvnmrds.png">
    <br>
    图5.32 ARP报文格式
</div>

1. 硬件类型：硬件接口类型。例如，以太网的值为 1。
2. 协议类型：发送方提供的高层协议类型。例如，IP 为 0x0800。
3. 硬件地址长度和协议长度：指明硬件地址和高层协议地址的长度，这样 ARP 报文就可以在任意硬件和任意协议的网络中使用。
4. 操作类型：表示这个报文的类型，ARP 请求为 1，ARP 响应为 2。

### 5.8.4 ARP代理

如果 ARP 请求是从一个网络中的主机发往另一个网络中的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称为 ARP 代理。路由器的这个功能相当于目的主机的代理，代替目的主机做出 ARP 响应，完成 IP 地址到物理地址之间的映射。

## 5.9 ICMP：Internet控制报文协议

Internet 控制报文协议（Internet Control Message Protocol，ICMP）传送差错报文以及其他控制信息。

ICMP 报文是封装在 IP 数据报中被传输的，如图 5.33 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.33-ICMP报文封装在IP数据报中.58j8kyvyi800.png">
    <br>
    图5.33 ICMP报文封装在IP数据报中
</div>

ICMP 报文的格式如图 5.34 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.34-ICMP报文格式.1mk15gqfeg0w.png">
    <br>
    图5.34 ICMP报文格式
</div>

所有报文的前 4 个字节都是一样的，其余的字节不同。其中：

1. 类型字段：占 8 位，可以选取 15 个不同的值，每个值描述了一种特定类型的 ICMP 报文。
2. 代码字段：占 8 位，进一步描述某类型的 ICMP 报文的不同功能。
3. 检查和字段：占 16 位，覆盖整个 ICMP 报文，使用的算法和 IP 报头检查和算法相同。对于 ICMP 报文，检查和字段是必须具有的。
4. 根据类型字段和代码字段值的不同，ICMP 报文有很多种，其内容也有所不同。

ICMP 协议有两种报文：差错报文、查询报文。

当发送一个 ICMP 差错报文时，报文包含了 IP 的首部和产生 ICMP 差错报文的 IP 数据报的前 8 个字节。所有的 ICMP 差错报文中的数据字段都具有同样的格式。

下列情况不会导致产生 ICMP 差错报文：

- ICMP 差错报文。
- 目的地址是广播地址或多播地址的数据报。
- 作为数据链路层广播的数据报。
- 不是 IP 分片的第一片。
- 源地址不是单个主机的数据报，即源地址不能为零地址、环回地址、广播地址或多播地址。

对 ICMP 差错报文进行响应时，不会产生另一个差错报文，通过这个规则可以避免差错产生差错的无限循环。其他关于广播地址的规则是为了防止广播风暴。

Ping 程序使用 ICMP 协议来测试网络连通性。

Tracert 程序使用 ICMP 协议来测试目的主机路由线路。

## 5.10 IGMP：Internet组管理协议

### 5.10.1 多播的基本概念

IP 地址有 3 种类型：单播地址、广播地址、多播地址。广播和多播地址只应用于 UDP 协议，它们主要应用在将报文同时传送到多个接收者的情况。TCP 协议是一个面向连接的协议，在两个主机之间进行一对一通信，因此只使用单播地址。

数据帧仅发往单个目的主机，目的地址指明单个接收者，这种通信方式称为**单播**（unicast）。在单播通信中，任意两个主机的通信不会干扰其他主机间的通信。

一个主机向网络上的所有主机发送帧，这种通信方式称为**广播**（broadcast）。

**多播**（multicast）处于单播和广播之间，帧仅传送给属于多播组的多个主机。

IP 多播提供两类服务：

1. 向多个目的地址传送数据。
2. 客户对服务器的请求。

### 5.10.2 多播组地址

IP 地址中的 D 类地址为多播地址，图 5.35 展示了 D 类 IP 地址的格式。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.35-D类IP地址.16lvzcjd0k5c.png">
    <br>
    图5.35 D类IP地址
</div>

D 类 IP 地址中的低 28 位均用作多播组号而不表示其他含义。多播组地址包括 1110 的最高 4 比特和多播组号，它们通常可以表示为点分十进制数，其范围从 224.0.0.0 到 239.255.255.255。

能够接收发往特定多播组地址的数据的主机集合称为主机组。一个主机组可跨越多个网络。主机组中成员可以随时加入或离开主机组。主机组中对主机的数量没有限制，不属于某一主机组的主机可以向该组发送信息。

多播组地址到以太网地址的转换如图 5.36 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.36-多播组地址到以太网地址的转换.1jfe0dae7csg.png">
    <br>
    图5.36 多播组地址到以太网地址的转换
</div>

以太网多播地址中，前 3 个字节固定为 01:00:5E，第 4 个字节的第 1 位固定为 0，剩余的 23 位来自 IP 组播地址中的低 23 位。

由于 IP 组播地址的后 28 位中只有 23 位被映射到 MAC 地址，这样会有 32 个 IP 组播地址映射到同一个 MAC 地址。由于地址映射不是唯一的，设备驱动程序或 IP 层就必须对数据报进行过滤。

### 5.10.3 IGMP报文格式

IGMP 报文通过 IP 数据报进行传输，图 5.37 描述了 IGMP 报文如何封装在 IP 数据报中。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.37-IGMP报文封装在IP数据报中.2v6v6fs9t3o0.png">
    <br>
    图5.37 IGMP报文封装在IP数据报中
</div>

图 5.38 展示了 IGMP 报文的格式。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.38-IGMP报文格式.6nh4p3oxpt00.jfif">
    <br>
    图5.38 IGMP报文格式
</div>

1. 版本字段：此处版本为 1。
2. 类型字段：有两种取值，为 1 说明是由多播路由器发出的查询报文，为 2 说明是主机发出的报告报文。
3. 检查和字段：检查和的计算与 ICMP 协议相同。
4. 组地址字段：在查询报文中组地址设置为 0，在报告报文中组地址为要参加的组地址。

### 5.10.4 IGMP协议功能

Internet 组管理协议（Internet Group Management Protocol，IGMP）用于支持主机和路由器进行多播通信，让一个物理网络上的所有系统知道主机当前所在的多播组。

多播服务建立在进程基础上，进程在一个主机的给定接口上加入一个多播组。在一个给定接口上的多播组中的成员是动态的，它因进程加入和离开多播组而动态改变。一个进程可以在多个接口上加入同一个多播组。

主机必须保留一个表，此表中包含所有至少含有一个进程的多播组以及多播组中的进程数量。

多播路由器使用 IGMP 报文来记录与该路由器相连网络中组成员的变化情况，使用方法如下：

1. 当第一个进程加入一个组时，主机发送一个 IGMP 报告。如果一个主机上的多个进程加入同一组，只发送一个 IGMP 报告，这个报告被发送到进程加入组所在的同一接口上。
2. 多播路由器定时发送 IGMP 查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个 IGMP 查询，IGMP 查询报文中的组地址被设置为 0。
3. 主机通过发送 IGMP 报告来响应一个 IGMP 查询，对每个至少包含一个进程的组均要发回 IGMP 报告。
4. 进程离开一个组时，主机不发送 IGMP 报告。当主机知道在确定的组中没有组成员后，在收到 IGMP 查询时不再发送报告报文。

使用 IGMP 查询和报告报文，多播路由器对每个接口维持一个表，表中记录接口上至少还包含一个主机的多播组。当路由器收到要转发的数据报时，它只将该数据报转发到还拥有属于那个组主机的接口上。

## 5.11 DHCP协议

动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）提供了一种动态指定 IP 地址和配置参数的机制，是一种用于简化主机 IP 配置管理的 IP 标准。

DHCP 使用 C/S 模型。网络管理员建立一个或多个维护 TCP/IP 配置信息并将其提供给客户端的 DHCP 服务器。DHCP 服务器以地址租约的形式将该配置提供给发出请求的客户端。

DHCP 的工作过程：

1. 发现阶段：DHCP 客户机以广播方式发送 DHCP discover 报文来寻找 DHCP 服务器。
2. 提供阶段：DHCP 服务器在网络中接收到 DHCP discover 报文后会做出响应，它从尚未出租的 IP 地址中挑选一个分配给 DHCP 客户机，向 DHCP 客户机发送一个包含出租的 IP 地址和其他设置的 DHCP offer 报文。
3. 选择阶段：如果有多台 DHCP 服务器向 DHCP 客户机发来 DHCP offer 提供报文，则 DHCP 客户机只接受第一个收到的 DHCP offer 提供报文，然后它就以广播方式回答一个 DHCP request 请求报文，该报文中包含向它所选定的 DHCP 服务器请求 IP 地址的内容。
4. 确认阶段：DHCP 服务器收到 DHCP 客户机回答的 DHCP request 请求报文之后，它便向 DHCP 客户机发送一个包含它所提供的 IP 地址和其他设置的 DHCP ack 确认报文，告诉 DHCP 客户机可以使用它所提供的 IP 地址。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.39-DHCP发现阶段.5qayiybe2l40.png">
    <br>
    图5.39 DHCP发现阶段
</div>

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.40-DHCP提供阶段.1trojcypdm4g.png">
    <br>
    图5.40 DHCP提供阶段
</div>

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.41-DHCP选择阶段.1u379njkwxgg.png">
    <br>
    图5.41 DHCP选择阶段
</div>

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图5.42-DHCP确认阶段.6zmeq9id6dw0.png">
    <br>
    图5.42 DHCP确认阶段
</div>

以后 DHCP 客户机每次重新登录网络时，就不需要再发送 DHCP discover 发现报文了， 而是直接发送包含前一次所分配的 IP 地址的 DHCP request 请求报文。

DHCP 服务器向 DHCP 客户机出租的 IP 地址一般都有一个租借期限 ，期满后 DHCP 服务器便会收回出租的 IP 地址。

# 6 传输层

## 6.1 传输层服务

### 6.1.1 传输层功能与服务概述

传输层又称运输层。在 ISO OSI 参考模型中，传输层处于通信子网和资源子网之间，是整个协议层次中最核心的一层。它的作用是在优化网络服务的基础上，为源主机上的进程和目的主机上的进程之间提供可靠的透明数据传送，使高层用户在相互通信时不必关心通信子网实现的细节。

若从面向通信和面向数据处理来划分，传输层属于面向通信的低层中的最高层。从用户功能和网络功能来划分，传输层属于用户功能的高层中的最低层。上述关系如图 6.1 所示，因此，传输层也被称为中间层。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.1-传输层的功能定位.2p4v7bfpoig0.png">
    <br>
    图6.1 传输层的功能定位
</div>

传输层的具体功能包括：

1. 端到端的报文传递。在传输终点需要监管一个报文中的所有数据包的传输和到达。
2. 服务访问点的寻址。在一台运行多道程序的计算机上，保证报文被传输到正确的程序。
3. 拆分和组装。将报文分解成可传输的片段，并且给这些片段编上序号。这些序号不仅使传输层可以在接收端将报文正确地重组，而且可以用来标识和替换传输中丢失的包。
4. 连接控制。决定是否通过一条单独路径来传输所有的包。

传输层的工作原理类似于数据链路层。然而，数据链路层是在单个网络中传输数据的，而传输层是在跨越许多网络的互连网络上提供数据传输服务的；数据链路层控制物理层，而传输层控制所有 3 个低层。

传输层向上层提供两种类型的传输服务：面向连接的传输服务、面向无连接的传输服务。

### 6.1.2 传输层寻址

传输层通信不仅仅是从源计算机到目的计算机，而且是从源端应用程序到目的端应用程序。由一台计算机上的应用程序产生的数据不仅必须被另一台计算机接收，而且必须被这台计算机上正确的应用程序接收。

在大多数情况下，通信是在两个传输服务访问点（Transport Service Access Point，TSAP）之间进行的。图 6.2 展示了两个应用程序通过传输服务访问点进行通信。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.2-应用程序通过传输服务访问点通信.38nzxojy5zu0.png">
    <br>
    图6.2 应用程序通过传输服务访问点通信
</div>

传输层的地址就是传输服务访问点的地址，传输服务访问点的地址称为端口号。当一个应用程序想同一个远程应用程序通信时，它必须知道两个地址，一个是网络服务访问点（Network Service Access Point，NSAP）地址（即主机地址），另一个是端口号。

### 6.1.3 传输层复用

传输层的复用分为两个层面：向上复用和向下复用。向上复用意味着多个传输层连接使用同一个网络层连接，向下复用意味着一个传输层连接使用多个网络层连接。

如果传输层使用基于下 3 层服务的虚电路，通常下面的网络为每个虚电路收费。为了使一条建立的电路具有最高的成本效率，传输层可以通过复用绑定若干个沿同一路径到同一目标站点的传输，如图 6.3(a) 所示。

向下复用允许传输层将单个传输分散到不同的路径中来提高传输速度。图 6.3(b) 是向下复用的情况。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.3-传输层复用.1mahbc4licrk.png">
    <br>
    图6.3 传输层复用
</div>

### 6.1.4 可靠传输

在传输层，可靠传输包括 4 个方面：差错控制、序列控制、丢失控制、重复控制。

#### 6.1.4.1 差错控制

在传输数据时，可靠性的主要目标是差错控制。传输层差错控制基于差错检测和重传。差错处理通常是使用软件实现的，一般采用检查和算法来实现。

数据链路层的功能保证每条链路中节点到节点的无差错传输，然而节点到节点的可靠性并不保证端到端的可靠性，因此传输层必须进行自己的端到端检查，以保证包可以正确地到达。图 6.4 展示了数据链路层和传输层的差错处理范围。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.4-数据链路层和传输层的差错处理范围.76o8z3sbij00.png">
    <br>
    图6.4 数据链路层和传输层的差错处理范围
</div>

#### 6.1.4.2 次序控制

在发送方，传输层负责保证从上层接收到的数据单元可以被下层使用。在接收方，传输层保证一次传输的不同片段按照期待的顺序到达目的地。

当从上层接收到的数据单元对于网络层数据报或数据链路层的帧来说太大时，传输层实体将会把它分割成更小的、下层可处理的块，划分的过程称为**分段**。另一方面，当属于一个会话的数据单元太小，以至于可以把多个这样的数据单元放到单个数据报或数据帧中时，传输层协议会把它们结合到单个数据报或数据帧中，这个过程称为**连接**。

大多数传输层服务在每个段的结尾增加一个序列编号。如果一个大的数据单元被分段，这个编号将指明重新组合的顺序；如果多个小单元被连接，这个编号则指明每个子单元的结尾，同时使它们能够在接收端被正确地分割。另外，每段有一个域指明该段是一次传输的最后段还是有后续需要传输的中间段。

图 6.5 展示了在发送端分段、在接收端组合的情况。因为整个数据的大小超过了网络处理的最大单元，发送方传输层必须将数据进行分段。它将数据分成两段，分别标为序号 1 和序号 2，分两个包进行传送，每个包还保持原有的端口地址。这两个包分别被送到网络层，在网络层加上网络层地址 A 和 P。数据包可能经过不同的路径以任意顺序出现在接收端。当这两个包被送到接收端的传输层后，接收端的传输层根据这两个包的序号组合成一个完整的数据单元，并将这个数据单元传递给上层。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.5-分段和组合.2jp7vjgahx00.png">
    <br>
    图6.5 分段和组合
</div>

图 6.6 展示了在发送端连接、在接收端分割的情况。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.6-连接和分割.24gvf2mzs7nk.png">
    <br>
    图6.6 连接和分割
</div>

#### 6.1.4.3 丢失控制

传输层保证所有的一次传输的所有片段都会到达目的地。当数据被分段传输时，序列编号使接收方的传输层可以识别出丢失的段，并要求重传。

#### 6.1.4.4 重复控制

传输层的功能必须保证没有一个数据片段会重复到达上层。序列编号使接收方可以识别并丢弃重复的段。

### 6.1.5 传输层流量控制

传输层和数据链路层都负责流量控制，但是，传输层中的流量控制是作用在端到端上的，而不是作用在单条链路上的。传输层流量控制也使用滑动窗口协议，但是传输层中的窗口大小可以变化，以适应可使用的缓冲区的变化情况。

使用动态窗口大小时，传输层协议根据传输数据的需要向主机申请缓冲区，接收方在应答报文中一方面指出已经正确接收的报文序号，另一方面指出已申请到的缓冲区数目。当接收方缓冲区被用尽时，数据传输暂停，等待新的缓冲分配应答后再继续传送。

在大多数情况下，窗口大小的控制是接收方的责任，接收方在应答包中可以指明窗口大小能够增加还是减少。在大多数情况下，传输层的滑动窗口基于接收方所能容纳的字节数，而不是帧数。

为了适应窗口大小的变化，传输层滑动窗口使用 3 个指针来识别缓冲区，如图 6.7 所示。当发送方收到应答包时，表示窗口左边界的指针向右移动。当数据发送时，窗口中间的指针向右移动。窗口右边界的指针可以向左或向右移动来改变窗口的大小。如果收到应答包而没有要求改变窗口大小，则窗口右边界的指针向右移动，以保持窗口的大小不变。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.7-传输层滑动窗口.7k5a6rdpekw0.png">
    <br>
    图6.7 传输层滑动窗口
</div>

图 6.8 是使用可变大小的滑动窗口进行流量控制的一个例子。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.8-传输层的流量控制.24t6i8pmn4g0.png">
    <br>
    图6.8 传输层的流量控制
</div>

1. A 请求 B 分配 8 个缓冲区。
2. B 仅仅申请到 4 个缓冲区，在应答报文中指出。窗口大小为 4。
3. 发送方发送序列号为 0 的报文。
4. 发送方发送序列号为 1 的报文。
5. 发送方发送序列号为 2 的报文，报文丢失。
6. 接收方发出应答，说明 2 号报文之前的报文已经正确收到，现在的缓冲区还有 3 个。
7. 发送方收到应答，将窗口大小调整为 3，发送 3 号报文。
8. 发送方发送 4 号报文，至此不能再发送了。
9. 发送方在规定的时间内未收到对 2 号报文的应答，重发 2 号报文。
10. 接收方发送应答，说明 5 号报文之前的报文已经正确收到，现在没有缓冲区。发送方收到这样的应答后，将窗口大小调整为 0，不能继续发送报文。
11. 接收方发送应答，说明 5 号报文之前的报文已经正确收到，现在有 1 个缓冲区。
12. 接收方发送应答，说明 5 号报文之前的报文已经正确收到，现在有 2 个缓冲区。
13. 发送方收到（11）发来的应答，将窗口大小调整为 1，发送 5 号报文。
14. 发送方收到（12）发来的应答，将窗口大小调整为 2，发送 6 号报文。
15. 接收方发送应答，说明 7 号报文之前的报文已经正确收到，现在没有缓冲区。发送方收到这样的应答后，将窗口大小调整为 0，不能继续发送报文。
16. 接收方发送应答，说明 5 号报文之前的报文已经正确收到，现在有 4 个缓冲区。但是该应答丢失了。

现在 A 等待 B 分配缓冲区的应答，而 B 在发出应答后在等待接收报文，发生了死锁。为了避免这种死锁，每个主机在等待时间过长后再发送控制报文。在上述情况下，A 发送请求分配缓冲报文或 B 再发送应答报文都可以解除死锁状态。

### 6.1.6 传输连接

面向连接传输有 3 个步骤：连接建立、数据传输、连接终止。

#### 6.1.6.1 连接建立

在通信设备可以发送数据之前，开始通信的设备必须首先确定交换数据的对方是否存在，同时必须找到一条经过网络的路径。这个步骤称为连接建立。

连接建立需要 3 个动作，称为三次握手：

1. 请求连接方发送连接请求包到预期的接收方。
2. 接收方回送一个确认包给请求方。
3. 请求方回送一个包给接收方，对确认包进行认可。

例如，在图 6.9(a) 中，A 向 B 发送一个连接请求 CR，并希望以 x 作为起始序列号。B 应答一个连接确认包 CC，并告知 A，B 希望以 y 作为起始序列号。A 收到这个确认包后，向 B 发送一个对确认的回应 AK。这样 A 和 B 建立了连接，都知道了对方的起始序列号，也能确信对方也知道了自己的起始序列号。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.9-三次握手方法建立连接.6z52uyg400c0.png">
    <br>
    图6.9 三次握手方法建立连接
</div>

在图 6.9(b) 中，第一个 TPDU 是图 6.9(a) 中的那个旧的连接中的一个连接请求包的重复包，这个旧的连接请求重复包延迟到达 B，B 发送一个连接确认包给 A。A 收到这个包后，通过应答号知道这是对一个旧的连接请求的应答，于是发送一个拒绝连接包给 B。B 收到这个拒绝连接包后，放弃连接。在这种情况下，重复的连接请求包不会造成危害。

#### 6.1.6.2 连接终止

当数据传输完成之后或出现异常情况都需要释放连接。释放连接是通过断连请求及断连确认实现的。

如果断连选择的时机不当而突然发生断连就有可能造成丢失数据。为了防止数据丢失，断连应选择在确信对方已经收到自己发送的数据，并且自己和对方不再发送任何数据时。

连接终止需要三次握手：

1. 请求方发送终止连接请求包。
2. 响应方发送终止连接确认包。
3. 请求方发送认可确认包。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.10-连接终止.6r4dsce9zeg0.png">
    <br>
    图6.10 连接终止
</div>

## 6.2 UDP：用户数据报协议

UDP 是一个简单的面向数据报的传输层协议。UDP 不提供可靠性，它发送应用程序数据到 IP 层的数据报，但不保证这些数据报到达其目的地。

UDP 必须在 IP 上运行，它的下层协议是以 IP 作为前提的。图 6.11 展示了 UDP 数据报封装在 IP 数据报中的格式。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.11-UDP封装.73piilg0lwc0.png">
    <br>
    图6.11 UDP封装
</div>

### 6.2.1 UDP报文格式

图 6.12 展示了 UDP 报文的格式。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.12-UDP报文格式.69hvppzddbo0.png">
    <br>
    图6.12 UDP报文格式
</div>

端口号标识出发送进程和接收进程。由于 IP 已将到来的 IP 数据报分解复用为 TCP 和 UDP，这意味着 TCP 端口号由 TCP 查看，UDP 端口号由 UDP 查看，TCP 端口号与 UDP 端口号无关。尽管二者无关，但若一个众所周知的服务 TCP 和 UDP 都提供，端口号通常取同一个值。

UDP 长度域以字节为单位，包括 UDP 报头和 UDP 数据，其最小值为 8。UDP 数据报的长度是 IP 数据报的总长度减去 IP 报头长度。

### 6.2.2 UDP检查和

UDP 检查和覆盖 UDP 报头和 UDP 数据。对于 UDP 而言，检查和是可选的。

检查和的计算以 16 位字为单位，如果 UDP 报文的长度不是 16 位的整数倍，需要在尾部追加全 0 的填充字节。

UDP 在报头中包含一个 12 字节的伪报头以计算检查和。该伪报头包含 IP 报头的某些域，目的是让 UDP 检测数据已到达正确的目的端。伪报头如图 6.13 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.13-UDP伪报头.yrsekdz6vkw.png">
    <br>
    图6.13 UDP伪报头
</div>

如果发送者计算了检查和并且接收者检测出检查和错误，则该 UDP 数据报会被简单地丢弃，不产生错误信息。

UDP 检查和是端对端检查和，它由发送端计算，由接收者验证。

## 6.3 TCP：传输控制协议

### 6.3.1 TCP提供的服务

TCP 提供一种面向连接的、可靠的字节流服务。面向连接是指两个使用 TCP 的应用在彼此交换数据之前必须先建立一个 TCP 连接。

在一个 TCP 连接中只能是双方进行通信，广播和多播不能使用 TCP。

TCP 通过下列方式提供可靠性：

1. 应用数据被分割成 TCP 认为最合适发送的数据块。由 TCP 传递给 IP 的信息单位称为**报文段**或**段**。
2. 当 TCP 发出一个段后，它启动定时器，等待目的端确认收到这个报文段。如果不能及时确认，将重发这个报文段。这就要求发送端在收到确认信息前必须保留该报文段的副本。
3. 当 TCP 收到来自 TCP 连接另一端的数据，它将发送一个确认。
4. TCP 保持它首部和数据的检查和。如果收到一个段的检查和有差错，TCP 将丢弃这个报文段，同时向该报文段的发送方发送否定的信息，表示收到的报文段有错误，希望对方重发该报文段。
5. 由于 TCP 报文段封装在 IP 数据报中传送，因此 TCP 报文段的到达可能乱序。TCP 对收到的数据进行重新排序，将收到的数据以正确的顺序提交给应用层。
6. IP 数据报会发生重复，因此 TCP 的接收端必须丢弃重复的数据。
7. TCP 提供流量控制。TCP 的接收端只允许另一端发送接收端缓冲区所能容纳的数据。

两个应用程序通过 TCP 连接交换字节流。接收方不知道发送方发送了多少次、每次发送多少字节，双方的收发次数可以不同。

TCP 对字节流的内容不作任何解释，对字节流的解释由应用层进行。

### 6.3.2 TCP的报文格式

TCP 数据被封装在 IP 数据报中，如图 6.14 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.14-TCP数据在IP数据报中的封装.51ymnpfuv6w0.png">
    <br>
    图6.14 TCP数据在IP数据报中的封装
</div>

图 6.15 展示了 TCP 的报文格式。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.15-TCP报文的格式.2rk09m80g000.png">
    <br>
    图6.15 TCP报文的格式
</div>

1. 端口号：用于定位接收和发送应用进程。源端口号、目的端口号与 IP 数据报中的源 IP 地址和目的 IP 地址唯一确定一个 TCP 连接。
2. 序号。TCP 传送的数据流中，每个字节都有一个序号。序号字段的值是本报文段发送的数据的第一个字节的序号。
3. 确认序号：期望收到的下一个字节的序号，即上次已成功收到的数据字节序号加 1。只有 ACK 标志为 1 时，确认序号字段才有效。一旦一个 TCP 连接建立起来，ACK 标志总是被置为 1，确认序号字段总是被设置。
4. 首部长度：首部中 32 比特字的数目。首部长度字段占 4 位，因此 TCP 最多有 60 字节的首部。如果没有任选字段，正常的首部长度是 20 字节。
5. 保留字段：保留为今后使用，目前一般置 0。
6. 标志：在 TCP 首部中有 6 个标志比特，每个标志位表示一个控制功能。
   （1）URG：紧急指针标志，为 1 时表示紧急指针有效，为 0 则忽略紧急指针。
   （2）ACK：确认序号标志，为 1 时表示确认序号有效，为 0 则忽略确认序号。
   （3）PSH：push 标志，为 1 时指示接收方在收到该报文段后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。
   （4）RST：重置连接标志。当 RST 为 1 时，表明 TCP 连接中出现严重差错（如主机崩溃或其他原因），必须释放连接，然后再重新建立连接。
   （5）SYN：同步序号，用于建立连接过程。SYN 为 1 表示这是一个连接请求或连接接受报文。
   （6）FIN：finish 标志，用于释放连接。FIN 为 1 表明发送方已经发送完毕，要求释放连接。
7. 窗口大小：滑动窗口大小，单位为字节。接收端声明自己的的缓冲区大小，用于控制发送端发送数据的速率，从而进行流量控制。窗口大小字段为 16 位，因此窗口大小最大为 65535 字节。
8. 检查和：覆盖整个 TCP 报文段，包括 TCP 首部和数据。TCP 检查和的计算与 UDP 检查和的计算相似。
9. 紧急指针：一个正的偏移量，指出在本报文段中紧急数据共有多少个字节。紧急指针字段中的值和序号字段中的值相加表示紧急数据最后一个字节的序号。
10. 任选字段。最常见的可选字段是最长报文大小（Maximum Segment Size，MSS），每个连接方通常都在通信的第一个报文段（为建立 TCP 连接而设置 SYN 标志的那个报文段）中指明这个选项，它指明本端所能接收的数据部分的最大长度（不包括首部）。
11. 数据部分：TCP 数据报中的数据部分是可选的，有些 TCP 报文段不包含数据。

TCP 可以描述为一个没有选择确认和否定的滑动窗口协议。

### 6.3.3 TCP连接的建立和释放

#### 6.3.3.1 TCP连接的建立

三次握手建立连接：

1. 请求端发送一个 SYN 段，指明想要连接的目的主机的端口以及初始序号（ISN），并进入 SYN_SEND 状态。
2. 目的主机发送一个包含目的主机的初始序号的 SYN 段作为应答，并将确认序号设置为请求端的 ISN 加 1，以对请求端的 SYN 报文段进行确认。此时目的主机进入 SYN_RECV 状态。
3. 请求端向目的主机发送确认包，将确认序号设置为目的主机的 ISN 加 1。此包发送后，请求端和目的端进入 ESTABLISHED 状态。

三次握手的过程如图 6.16 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.16-TCP连接的建立.lctmpguw6e8.png">
    <br>
    图6.16 TCP连接的建立
</div>

发送第一个 SYN 段的一端执行主动打开，接收这个 SYN 并发回下一个 SYN 的另一端执行被动打开。

#### 6.3.3.2 TCP连接的释放

一个 TCP 连接是全双工的，因此每个方向需要单独地进行关闭。

当 TCP 连接的一方完成数据发送后，就能发送一个 FIN 来终止这个方向的连接；当 TCP 连接的另一端收到一个 FIN，它必须通知应用层对方已经终止了那个方向上的数据传送。

收到一个 FIN 只意味着在这个方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。

首先进行关闭的一方执行主动关闭，另一方执行被动关闭。

图 6.17 展示了释放一个 TCP 连接的典型握手顺序。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.17-TCP连接的释放.7juncz58z300.png">
    <br>
    图6.17 TCP连接的释放
</div>

图 6.18 展示了一个完整的 TCP 通信过程。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.18-TCP通信过程.c5osgr08xt4.png" height="500px">
    <br>
    图6.18 TCP通信过程
</div>

### 6.3.4 传输层拥塞控制

TCP 的流量和拥塞控制机制采用的是一种信用分配机制，TCP 采用流量控制方法实现拥塞控制。TCP 报文中的序号、确认序号和窗口大小 3 个字段与流量控制、差错控制和拥塞控制有关。

TCP 拥塞控制算法主要由 4 种算法组成：慢启动、拥塞避免、快速重传、快速恢复。

首先给出如下术语：

1. 发送端最大数据段尺寸（Sender Maximum Segment Size，SMSS）：发送端所能发送的最大数据段的尺寸，不包括报文头和选项字段。
2. 接收端窗口（rwnd）：最近通知的接收端窗口。
3. 拥塞窗口（cwnd）：一个 TCP 状态参量，代表一个 TCP 允许发送的最大数据量。在任意一个给定的时刻，TCP 不会发送序号大于最大确认序号和 cwnd、rwnd 中较小者的数据。

#### 6.3.4.1 慢启动和拥塞避免

TCP 发送端使用慢启动和拥塞避免算法来控制向网络输送的数据量。

慢启动阈值（ssthresh）被用来确定是用慢启动算法还是用拥塞避免算法来控制数据传送。在 cwnd<ssthresh 时使用慢启动算法，在 cwnd>ssthresh 时使用拥塞避免算法。当 cwnd=ssthresh 时，发送方既可以使用慢启动算法也可以使用拥塞避免算法。

在慢启动期间，发送方将 cwnd 设置为 1 个 SMSS 字节；在第 1 个超时周期内没有丢失报文的情况下，cwnd 设置为 2 个SMSS 字节；在第 2 个超时周期内没有丢失报文的情况下，cwnd 设置为 4 个 SMSS 字节；在第 3 个超时周期内没有丢失报文的情况下，cwnd 设置为 8 个 SMSS 字节；依此方式，cwnd 按指数方式增长，直到 cwnd 超过 ssthresh。

当 cwnd 超过 ssthresh 或者当 cwnd 大小达到 ssthresh 的大小，进入拥塞避免期间。在拥塞避免期间，在没有丢失报文的情况下，cwnd 按线性方式增长，即每收到一个 ACK，cwnd 的大小增加 1 个 SMSS 字节。

当检测到数据段丢失时，将 ssthresh 设置为当前 cwnd 的一半，并重新开始慢启动算法。

图 6.19 说明了慢启动和拥塞避免的工作过程，其中初始 ssthresh 设置为 16 个 SMSS。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图6.19-慢启动和拥塞避免的工作过程.340eulewzn60.png">
    <br>
    图6.19 慢启动和拥塞避免的工作过程
</div>

#### 6.3.4.2 快速重传/快速恢复

当一个次序紊乱的数据段到达时，TCP 接收端应该迅速发送一个重复 ACK，通知发送端收到了一个次序紊乱的数据段，并通知发送端期望的序列号。当接收数据段填补了全部或部分序列号间隔时，TCP 接收端应立即发送一个 ACK。

TCP 发送端使用快速重传算法来探测或者修复数据丢失。快速重传算法以 3 个重复 ACK 的到达（收到 4 个一样的 ACK，其间没有任何其他包到达）为一个数据段已经丢失的标志。在收到 3 个重复 ACK 之后，TCP 不等重传定时器超时就重传疑似已经丢失的数据段。之后，“快速恢复” 算法支配新数据的传送，直到一个非重复 ACK 到达。

快速重传和快速恢复算法常按如下方式一起实现：

1. 当第三个重复 ACK 收到时，设置 ssthresh=cwnd/2。
2. 重传丢失的数据段并设置 cwnd=ssthresh+3*SMSS。
3. 对每个接收到的附加的重复 ACK，将 cwnd 增大 SMSS 字节。这将人为地扩充拥塞窗口以反映已经离开网络的附加数据段。
4. 如果 cwnd 和接收端通知窗口的值允许，则发送一个数据段。
5. 当下一个确认新数据的 ACK 到达时，设定 cwnd 值为 ssthresh（步骤 1 设置的值）。这称作 “deflating” 窗口。

# 7 应用层

## 7.1 域名服务

### 7.1.1 DNS的工作原理

域名系统是一个分布式的数据库，每个子域负责维护整个数据库的一个分段。DNS 采用 C/S 工作模式。

#### 7.1.1.1 域名空间

Internet 上的主机名采用层次化的命名方法，这种层次化的主机名叫做**域名**（domain name）。域名空间分为若干层次，分别为顶级域、二级域、三级域等，其结构就像一个倒置的树，如图 7.1 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图7.1-域名空间.4g157y9jipk0.png">
    <br>
    图7.1 域名空间
</div>

域名全称是一个从该域到根的标签序列，以 “.” 分隔这些标签。域名既可以是叶节点的名称，也可以是子树的根节点名称。

**域**即为树状域名空间中的一棵子树，域的名字同该子树根节点的域名一样。也就是说，域名就是该域中最高层节点的名字。例如， edu.cn 域的顶端即名为 edu.cn 的节点。子域中的任何域名均被认为是域的一部分。

#### 7.1.1.2 代理技术

域名系统要实现的一个主要目标是让管理分散化，这是通过代理实现的。

代理包含两层意思：一是数据存储的分散化，二是管理权的分散化。

从域名的角度来看，代理意味着域名又多了一层，并用 “.” 实现层间的分隔。管理某域的组织可以负责维护该域中的所有数据，也可以进一步划分子域。每一子域可以由其他组织代理，这意味着那些代理组织负责维护在该子域中的所有数据。父域中包含指向这些子域数据的指针，因此它可以索引完成对子域的查询。

#### 7.1.1.3 名字服务器

存储有关域名空间信息的程序称为**名字服务器**（name server），它是一个在后台时时运行的守护程序，随时监听来自客户机的请求。

通常，名字服务器拥有部分域名空间，即称为**区**（zone）的完整信息。该名字服务器就称为对该区具有权限。区就是域中除去代理出去的子域所含有的域名和数据之后余下的部分，如图 7.2 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图7.2-域和区的区别.302x3yv5yt60.png">
    <br>
    图7.2 域和区的区别
</div>
名字服务器的类型：

1. 主名字服务器（Primary Name Server）：特定区域的官方服务器，对于某个指定区域，主名字服务器是唯一存在的。主名字服务器从它所运行的主机上的文件获得它所负责的区的数据。
2. 辅助名字服务器（Secondary Name Server）：提供主名字服务器的备份，通常与主名字服务器同时提供服务。对于客户端来说，辅助名字服务器提供与主名字服务器完全相同的功能，但是辅助名字服务器从其他具有该区权限的名字服务器上获得它的区数据。
3. 缓存域名服务器（Caching-only Server）：不负责解析域，只是缓存域名解析结果。

名字服务器的工作过程：

1. 监听来自客户机的请求。名字服务器利用 53H 口进行监听。
2. 根据客户请求提供服务。若客户查询的是本域数据则到本地数据库进行查找，查找的结果有两种，一是找到该域名对应的 IP 地址，二是找到该域名所属下级子域的指针。若非本域数据，则首先到缓存中从最近记录中查找，若仍无结果，则根据 DNS 配置文件的记录返回一参考域名服务器地址或根服务器地址。
3. 返回结果。结果仍由 53H 口返回。

#### 7.1.1.4 解释过程

域名解析器首先查询本地主机的的缓冲区，查看主机是否以前解析过主机名。如果主机缓冲区中没有与其 IP 地址的映射关系，解析器将向本地域名服务器发出请求。本地域名服务器首先检查域名与其 IP 地址的映射关系是否存储在它的数据库中，如果是，本地服务器将该映射关系传送给请求者。如果该域名非本网络子域域名，则解释方法有两种：重复解释、递归解释。

在重复解释中，名字服务器仅简单地将它所知道的最好答案返回给查询者，不需要额外的查询。被查询的名字服务器检索其本地数据，来寻找所要求的数据。如果名字服务器未找到所需的数据，它将尽力返回可以帮助查询者继续解释过程的答案，例如一些更靠近被搜索数据的名字服务器的名字和地址。重复解释的过程如图 7.3 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图7.3-重复解释.5gnocr0c8y80.png">
    <br>
    图7.3 重复解释
</div>

递归解释是当名字服务器收到递归查询时所使用的解释过程。在递归解释中，解释器将域名的递归查询请求发送给名字服务器。名字服务器只能返回查询到的数据结果，或者返回所要查询的数据类型不存在以及所要查询的域名不存在等错误信息。这时名字服务器不能返回其他名字服务器的地址。当被查询的名字服务器未在本地数据库或缓存中找到所要查询的数据时，它将继续查询其他名字服务器来获得答案。这时，被查询的名字服务器可以发送一个递归查询给其他名字服务器，从而迫使它们找到答案并将答案返回；或者发送重复查询给其他名字服务器，然后根据返回结果不断向更靠近所寻域名的名字服务器发送重复查询知道找到答案。递归解释的过程如图 7.4 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图7.4-递归解释.qhn1gqznqe8.png">
    <br>
    图7.4 递归解释
</div>

### 7.1.2 DNS与ARP的比较

1. DNS 进行主机名与 IP 地址之间的翻译，也就是应用层地址到网络层地址的翻译；ARP 进行 IP 地址与物理地址间的翻译，也就是网络层地址和到数据链路层地址的翻译。
2. DNS 提供全局性的地址服务，全世界主机的名字与其 IP 地址的翻译都是通过单一的 DNS 系统提供的；ARP 提供的是一个局域性地址映射机制，服务的范围在一个 LAN 内。
3. DNS 通过专用的 DNS 服务器来进行翻译服务，而 ARP 作为一个软件模块驻留在每台主机或路由器的每个适配器接口中。

## 7.2 电子邮件服务

### 7.2.1 电子邮件系统的组成

一个电子邮件系统由 3 部分组成：用户代理（User Agent，UA）、邮件服务器（Email Server）、电子邮件协议。如图 7.5 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图7.5-电子邮件系统的组成.61nolc2jvv80.png">
    <br>
    图7.5 电子邮件系统的组成
</div>

用户代理就是用户与电子邮件系统的接口，是用户机上运行的程序。用户代理使用户能够通过一个友好的界面来发送和接收邮件。用户代理至少应具有以下 3 个功能：

1. 撰写：给用户提供方便的编辑信件的环境。
2. 显示：能方便地在计算机屏幕上显示出来信，包括来信附上的声音和图像。
3. 处理：包括发送邮件和接收邮件。

邮件服务器是电子邮件系统的核心构件。Internet 上所有的 ISP（Internet Service Provider，互联网服务提供商）都有邮件服务器。邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况。邮件服务器按照 C/S 方式工作。

邮件服务器之间、用户代理与邮件服务器之间需要使用两个不同的协议：一个协议用于发送邮件，如 SMTP 协议；另一个协议用于接收邮件，如邮局协议（Post Office Protocol，POP）。

图 7.5 可以说明一封电子邮件的发送和接收过程：

1. 发信人调用用户代理来编辑要发送的邮件。然后，用户代理利用 SMTP 协议将邮件传送给发送端邮件服务器 。
2. 发送端邮件服务器将邮件放入邮件缓存队列中，等待发送。
3. 运行在发送端邮件服务器的 SMTP 客户进程发现在邮件缓存中有待发送的邮件，就向运行在接收端邮件服务器的 SMTP 服务器进程发起建立 TCP 连接的请求。如果接收服务器关闭，则发送服务器将新建继续保留在新建队列中，并在以后再尝试发送。
4. 当 TCP 连接建立后，SMTP 客户进程开始向远程的 SMTP 服务器进程进行握手交互。交互内容包括邮件服务器之间的身份介绍、邮件中发件人和收件人的邮箱地址等。如果邮件收件人的邮箱拼写有误，发送过程即告结束。如果握手交互成功，则可继续发送邮件。当所有的待发送邮件发完时，SMTP 客户进程就关闭所建立的 TCP 连接。
5. SMTP 服务器进程收到邮件后，将邮件放入收信人的用户邮箱中。
6. 收信人在打算收信时调用用户代理，使用 POP3 或 IMAP 等邮件接收协议将邮件从接收端邮件服务器的用户邮箱中取回。

电子邮件由信封和内容两部分组成。电子邮件的传输程序根据邮件信封上的信息来传送邮件。在邮件的信封上，最重要的是收信人的地址。TCP/IP 体系的电子邮件系统规定电子邮件地址的格式如下：

<div align="center" style="margin-bottom: 10px">
    收信人邮箱名@邮箱所在主机的域名
</div>

收信人邮箱名在邮箱所在计算机中必须是唯一的。由于一个主机的域名在 Internet 上是唯一的，而每个邮箱名在该主机中也是唯一的，因此在 Internet 上的每个人的电子邮箱地址都是唯一的。

在发送电子邮件时，邮件服务器只使用目的主机的域名。只有在邮件到达目的主机后，目的主机的邮件服务器才根据收信人邮箱名，将邮件存放在收件人的邮箱中。

### 7.2.2 简单邮件传输协议（SMTP）

简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）的目标是实现有效和可靠的邮件传输。SMTP 使用 C/S 方式，负责发送邮件的 SMTP 进程是 SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。

SMTP 并不依赖于特定的网络传输服务，TCP 服务、ARPANET 使用的主机到主机的网络控制协议（Network Control Protocol，NCP）服务、网络无关传输服务（Network Independent Transport Service，NITS）和 X.25 等都可以用于 SMTP 协议。

SMTP 既用在发送方邮件服务器向接收方邮件服务器的发送过程中，也用在发送方的用户代理向发送方邮件服务器发送邮件的过程中。

SMTP 以 “持续连接” 的模式工作，若某邮件服务器要想另一邮件服务器发送若干邮件报文，那么它可以使用一个 TCP 连接一次性将所有邮件报文发送出去。

SMTP 规定邮件信体（包含信件首部）必须是 7 位 ASCII 码。

SMTP 协议的缺点：所有的多媒体二进制数据在使用 SMTP 发送前必须全部转换成 ASCII 码；传送到目的地后，ASCII 码的报文必须再转换成二进制数据。这个规定使邮件服务在传送大型附件和图像资料时显得并不十分方便。

### 7.2.3 邮件读取协议

常用的邮件读取协议有 2 个：邮局协议版本 3（Post Office Protocol version 3.0，POP3）、Internet 邮件访问协议（Internet Message Access Protocol，IMAP）。

#### 7.2.3.1 邮局协议（POP）

POP 使用 C/S 工作方式。接收邮件的计算机运行 POP 客户程序，其 ISP 的邮件服务器中运行 POP 服务程序。

POP 是一个脱机协议。所有收到的邮件先送到 ISP 的 POP 服务器，收信人的 PC 机不定期地连接到这个邮件服务器以便下载发送给该收信人的邮件。此后，所有对邮件的处理都在用户的 PC 机上进行。POP 服务器是一个具有存储转发功能的中间服务器，一旦邮件交付给用户的 PC 机，POP 服务器就不再保存这些邮件。

#### 7.2.3.2 Internet邮件访问协议（IMAP）

IMAP 是联机协议。用户在自己的 PC 机上就可以远程操纵 ISP 服务器上邮件服务器的邮箱。当用户 PC 机上的 IMAP 客户打开 IMAP 服务器的邮箱时，用户就可以看到邮件的首部。若用户需要打开某个邮件，该邮件才传到用户的计算机上。在用户未发出删除邮件的命令之前，IMAP 服务器邮箱中的邮件一直保存着。

IMAP 的优点：

1. 节省用户 PC 机的存储空间。
2. 用户可以在不同的地方使用不同的计算机随时阅读和处理自己的邮件。
3. IMAP 允许收信人只读取邮件中的某一部分。

IMAP 的缺点：邮件一直存放在 IMAP 服务器上，用户需要经常与 IMAP 服务器建立连接。

### 7.2.4 多用途Internet邮件扩充（MIME）

SMTP 协议只能传送 ASCII 码，为了能够发送 ASCII 码以外的内容，制订了多用途 Internet 邮件扩充（Multipurpose Internet Mail Extensions，MIME）。

MIME 增加了 5 个新的邮件首部：

1. MIME-Version：MIME 版本标识。
2. Content-Description：可读字符串，用于简单描述邮件内容，类似于 Subject。
3. Content-Id：邮件的唯一标识符。
4. Content-Transfer-Encoding：内容传送编码。
5. Content-Type：内容类型。

其中 Content-Transfer-Encoding 和 Content-Type 最为关键，它们使得邮件接收方的用户代理知道如何对接收到的邮件数据进行处理。

#### 7.2.4.1 内容传送编码

1. Quoted-Printable 编码

对于可打印的 ASCII 码（除等号外）都不变，而对等号以及编号超过 127 的 ASCII 码的编码方式是：先将每个字节的二进制代码用两个十六进制数字表示，然后在前面加上一个等号。例如，汉字 “系统” 的二进制编码是 10111111 10100101 10111100 10100011，其十六进制数字表示为 CFB5CDB3，用 Quoted-Printable 编码表示为 CF=B5=CD=B3；等号的二进制代码为 00111101，即十六进制的 3D，因此等号的 Quoted-Printable 编码是 =3D。

2. Base64 编码

将 24 位的代码划分为 4 个 6 位组。6 位组的二进制代码共有 64 种不同的值，从 0 到 63。用 A 表示 0，用 B 表示 1，等等。26 个大写字母排列完毕后，接下去再排 26 个小写字母，再后面是 10 个数字，最后用 “+” 表示 62，用 “/” 表示 63。再用 “==” 和 “=” 分别表示最后一组的代码只有 8 或 16 位。例如，24 位二进制代码为 01001001 00110001 01111001，将其划分为 4 个 6 位组为 010010 010011 000101 111001，对应的 Base64 编码为 STE5。

#### 7.2.4.2 内容类型

MIME 内容类型的格式为：

<div align="center" style="margin-bottom: 10px">
    Content-Type: type/subtype; parameters
</div>

MIME 标准规定 Content-Type 说明必须含内容类型（type）和子类型（subtype），中间用 “/” 分开，而参数（parameters）是可选的。

MIME 用于传送文本、图像、声音等多种媒体数据，因此 RFC2046 定义了多种媒体类型与内容类型相对应。RFC2046 将媒体分为两大类：独立媒体类型（discrete）、复合媒体类型（composite）。两类媒体类型包含 7 个基本内容类型，每种基本内容类型还有若干子类型。

独立媒体类型包含 5 个基本媒体类型：

1. 文本（text）：表示邮件中包含文字信息。子类型 plain 表示文本中不包含格式命令，文本只需按字面形式展示。子类型 html 表示邮件阅读器对邮件中的 HTML 标记进行解析，将邮件报文作为网页处理。
2. 图像（image）：表示邮件报文体是一个图像。子类型有 gif、jpeg 等。
3. 音频（audio）：表示邮件报文体包含音频数据。子类型有 basic、32kadpcm 等。
4. 视频（video）：表示邮件报文体包含视频数据。子类型有 mpeg、quicktime 等。
5. 应用（application）：该类型囊括了所有不能归入其他类型的数据。子类型 msword 表示邮件附件中有 Word 文件，octet-stream 表示邮件中包含任意的二进制内容。

复合媒体类型包含 2 个基本媒体类型：多重类型（multipart）、消息类型（message）。

多重类型有 4 种子类型：

1. 混合（mixed）：允许单个报文有多个相互独立的子报文，每个子报文可以有自己的类型和编码。在 Content-Type 中使用参数 “boundary” 指定分隔报文各部分的字符串。例如：

```text
Content-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08j34c0p
--gc0p4Jq0M2Yt08j34c0p<CRLF> // 表示上一部分的结束和新部分的开始
--gc0p4Jq0M2Yt08j34c0p-- // 表示整个邮件体的结束
```

2. 选择（alternative）：允许单个报文含有同一数据的多种可以选择的表示方式。
3. 并行（parallel）：允许单个报文含有可同时显示的各个子部分。例如，图像和声音子部分必须一起播放。
4. 摘要（digest）：允许单个报文含有一组其他报文。

## 7.3 文件传输服务

文件传输协议（File Transfer Protocol，FTP）是用于文件传输的因特网标准。FTP 屏蔽了计算机系统的差别，用于在两台异构的主机间传送文件。FTP 是基于 TCP 的文件传输协议，其传输的可靠性由 TCP 来保障。

因特网上有两大类 FTP 服务器：

1. 匿名 FTP 服务器：向公众提供文件资源服务，不要求用户事先在该服务器注册。
2. 非匿名 FTP 服务器：要进入该类服务前，用户必须先向服务器系统管理员申请用户名和密码。

FTP 是一个 C/S 系统，用户通过一个支持 FTP 的客户程序连接到在远程主机上的 FTP 服务器程序。用户通过客户程序向服务器程序发出命令，服务器程序执行用户所发出的命令，并将执行的结果返回到客户机。

FTP 有两种工作模式：主动模式（PORT 模式）、被动模式（PASV 模式）。PORT 模式是 FTP 的默认工作模式。

FTP 使用两个并行的 TCP 连接来传输文件，一个称为控制连接，默认端口号为 21；另一个称为数据连接，PORT 模式下默认端口号是 20，PASV 模式下创建一个临时端口进行数据连接。控制连接用来在两个主机之间传输控制信息，数据连接用来传送文件。

PORT 模式下 FTP 的工作原理如图 7.6 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图7.6-PORT模式工作原理.49kv9iul1zm0.png">
    <br>
    图7.6 PORT模式工作原理
</div>

当用户启动一次 FTP 会话时，首先建立一个 TCP 连接到 FTP 服务器的 21 号端口，FTP 客户端通过该连接发送用户标识、密码等。当用户要求传送文件时，FTP 服务器则在其 20 号端口上建立一个数据连接，FTP 在该连接上传送完一个文件后立即断开该连接。如果在一次 FTP 会话过程中需要传送另一个文件，FTP 服务器则会建立另一个连接。在整个 FTP 会话过程中，控制连接始终保持，而数据连接则随着文件的传输不断地打开和关闭。

PASV 模式下 FTP 的工作原理如图 7.7 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图7.7-PASV模式工作原理.6mhhik3o7is0.png">
    <br>
    图7.7 PASV模式工作原理
</div>

## 7.4 万维网服务

万维网（World Wide Web，WWW）是一个分布式超文本系统，其文件中包含指向其他文件的链接（超文本链接），并且能够使 Internet 中不同计算机上的文件相互链接。万维网也是一个超媒体系统，它的文件可以包括声音、图像以及视频信息等。

Internet 用户通过浏览器（browser）访问万维网服务，而万维网上的信息是由 Web 服务器和网站提供的。网站是指放在 Web 服务器上的一系列网页文档。万维网中的网页可以包含文本、图片、动画、声音等元素。

Web 服务器是指服务器及运行在其上的服务器软件的总和。用户浏览一个网页，实际上是发送访问请求到 Web 服务器；Web 服务器接受请求后，将用户要求的超文本文件发送到用户计算机上，这些网页通过用户计算机上的浏览器显示出来。超文本传输协议（Hypertext Transfer Protocol，HTTP）是用来在因特网上传送超文本的通信协议。

### 7.4.1 超文本

超文本标记语言（Hypertext Markup Language，HTML）是万维网文档发布和浏览的基本格式。HTML 的特点有：

1. 独立于平台（即计算机硬件和操作系统）。
2. 超文本：允许文档之间漫游。
3. 精确的结构化文档。

统一资源定位器（Uniform Resource Locator，UML）是专为标识网络上资源位置而设的一种编址方式。URL 一般由 3 部分组成：

<div align="center" style="margin-bottom: 10px">
    传输协议://主机IP地址或主机域名/资源所在路径和文件名
</div>

HTTP 的网页由多个对象组成，一个对象就是一个文件。大部分网页由一个基本 HTML 文件及相关的对象组成。例如，一个网页有 HTML 文本和 5 个 JPEG 图像，则这个网页由 6 个对象组成：一个基本 HTML 文件和 5 个相关对象。

### 7.4.2 超文本传输协议（HTTP）

超文本传输协议（HTTP）是用来在因特网上传送超文本的通信协议。

HTTP 协议是 TCP/IP 协议族中的一个应用层协议。HTTP 需要 TCP 提供支持，HTTP 协议的默认 TCP 端口号是 80。

HTTP 协议是 C/S 模式，客户端程序一般称为浏览器，服务器端程序通常称为 Web 服务器。浏览器和 Web 服务器通常运行在不同的主机上，通过交换 HTTP 报文来完成网页请求和响应，HTTP 协议定义了这些报文的结构和报文交换的规范。当用户在浏览器地址栏中输入一个 URL 或点击一个超链接时，浏览器就向服务器发出 HTTP 请求报文，该请求被送往由 URL 指定的 Web 服务器，然后 Web 服务器进行相关文档的检索并生成 HTTP 响应报文送回所要求的文件或其他相关信息，最后由用户机上的浏览器负责解释和显示。

HTTP 协议与浏览器如何解析网页毫无关系，它只定义了浏览器和 Web 服务器的通信协议。

HTTP 协议是一个无状态协议，Web 服务器不保存客户端的状态信息。

HTTP 可以实现非持续连接和持续连接。HTTP 1.0 使用非持续连接，HTTP 1.1 的默认操作模式是持续连接。

在非持续连接模式下，服务器在发送每个对象过后都要关闭 TCP 连接。如果一个网页由 n 个对象组成，那么传送这个网页就需要进行 n 次 TCP 连接。这种模式开销较大，效率较低，而且 Web 服务器负担较重。

在持续连接模式下，服务器在完成一次 HTTP 报文交互后继续保持连接，同一客户端和服务器之间后继的请求和响应报文可以在原来的连接上进行。持续连接的优点有：

1. 减少了 TCP 连接数目，从而减少了通信过程中客户机、服务器、代理、路由器以及网关等设备中的 CPU 开销，也减少了用于 TCP 协议的内存开销。
2. 多个 HTTP 请求和响应可以共享一个 TCP 连接，以流水线的方式处理。流水线方式允许一个 HTTP 客户在响应到达之前连续发送多个请求，这样可以更有效地利用 TCP 连接。
3. 减少了用于新建 TCP 连接的报文数目，从而减轻了网络拥塞。
4. 避免为了单个 HTTP 请求新建 TCP 连接的开销，从而减少了 HTTP 服务的平均延迟。
5. 错误处理更为得体。错误发生时，错误状态可以通过 TCP 连接返回给客户端。

HTTP 与 SMTP 的共同点是都可以在不同主机之间传送文件，都要依赖于 TCP 的传输服务，都支持持续连接。

HTTP 与 SMTP 的不同点：

1. HTTP 基本上是一个 “拉” 的协议——因特网上的大部分万维网应用都是从 Web 服务器上取资料，并由发出数据请求的主机来启动 TCP 连接；而 SMTP 主要是一个 “推” 的协议——由发送方的邮件服务器将数据推给接收方的邮件服务器，由发送方的邮件服务器来启动 TCP 连接。
2. SMTP 所传输的数据必须全部转换成 7 为 ASCII 码，而 HTTP 协议不需要对二进制数据进行转换。
3. 报文结束标志不同。在 SMTP 中，字符串组合`<CRLF>.<CRLF>`是邮件主体的结束标志，所以任何二进制数据的转换过程中不允许 “.” 出现。对非持续连接模式的 HTTP 协议，每次 TCP 连接只传送一个对象，一旦 Web 服务器关闭连接，浏览器就知道一个 HTTP 响应报文已经发送完毕。对持续连接模式的 HTTP 协议，每个响应报文包含一条内容长度的首部行来向浏览器说明响应报文的大小。
4. HTTP 以对象（文件）为单位从 Web 服务器向浏览器传输资料，而 SMTP 以邮件报文为单位从一个邮件服务器传数据到另一个邮件服务器，包含在一个邮件内的所有文件全部封装在一个邮件报文中。

### 7.4.3 Web浏览器的结构

图 7.8 给出了浏览器的主要组成部分和各组成部分之间的关系。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图7.8-浏览器组成.7axgjbbpano0.png">
    <br>
    图7.8 浏览器组成
</div>

一个浏览器通常有一组客户端程序，一组解释器，以及管理这些客户端和解释器的控制模块。控制模块是浏览器的核心部件，它解释鼠标的点击和键盘的输入，并调用有关组件来执行用户指定的操作。

浏览器中的 HTML 解释器是必不可少的，而其他解释器是可选的。HTML 解释器的输入是符合 HTML 语法的文档，将 HTML 元素转换为适合用户显示硬件的命令来处理页面的细节。

浏览器中设有一个缓存，用于保存网页副本。

浏览器的文档类型：

1. 静态文档（static document）：文档的内容不随访问时间而改变。
2. 动态文档（dynamic document）：动态文档的内容是在浏览器访问 Web 服务器时才由应用程序动态创建。由于对浏览器每次请求的响应都是临时生成的，因此动态文档的内容可根据需要不断变化。
3. 活动文档（active document）：活动文档将所有的工作都从 Web 服务器转移给浏览器。每当浏览器请求一个活动文档时，服务器就返回一段程序在浏览器段运行。

### 7.4.4 Web服务器的结构

比较流行的 Web 服务器的结构由 Web 服务器、中间件和数据库组成，如图 7.9 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/images/图7.9-Web服务器的结构.3f1in4xxrdy0.png">
    <br>
    图7.9 Web服务器的结构
</div>

通用网关接口（Common Gateway Interface，CGI）在 HTML 网页与数据库系统之间架起沟通的桥梁。CGI 程序的主要功能有：从 Web 服务器得到用户的访问请求；根据用户的请求对数据库进行访问；根据用户的要求，将结果数据封装在一个 HTML 文档中并通过标准输出返回给 Web 服务器。
