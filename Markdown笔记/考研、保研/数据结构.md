---
title: 数据结构
chrome:
    format: "A4"
    headerTemplate: '<div></div>'
    footerTemplate: '<div style="width:100%; text-align:center; border-top: 1pt solid #eeeeee; margin:  10px 10px 20px; font-size: 8pt;"> 
    <span class=pageNumber></span> / <span class=totalPages></span></div>'
    displayHeaderFooter: true
    margin:
        top: '40px'
        bottom: '80px'
        left: '60px'
        right: '60px'
---

<h1>数据结构</h1>

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [第1章 绪论](#第1章-绪论)
  - [1.1 数据结构的研究内容](#11-数据结构的研究内容)
  - [1.2 基本概念和术语](#12-基本概念和术语)
    - [1.2.1 数据、数据元素、数据项和数据对象](#121-数据-数据元素-数据项和数据对象)
    - [1.2.2 数据结构](#122-数据结构)
      - [1.2.2.1 逻辑结构](#1221-逻辑结构)
      - [1.2.2.2 存储结构](#1222-存储结构)
    - [1.2.3 数据类型和抽象数据类型](#123-数据类型和抽象数据类型)
  - [1.3 抽象数据类型的表示与实现](#13-抽象数据类型的表示与实现)
  - [1.4 算法和算法分析](#14-算法和算法分析)
    - [1.4.1 算法的定义及特性](#141-算法的定义及特性)
    - [1.4.2 评价算法优劣的基本标准](#142-评价算法优劣的基本标准)
    - [1.4.3 算法的时间复杂度](#143-算法的时间复杂度)
      - [1.4.3.1 问题规模和语句频度](#1431-问题规模和语句频度)
      - [1.4.3.2 算法的时间复杂度定义](#1432-算法的时间复杂度定义)
      - [1.4.3.3 算法的时间复杂度分析](#1433-算法的时间复杂度分析)
      - [1.4.3.4 最好、最坏和平均时间复杂度](#1434-最好-最坏和平均时间复杂度)
    - [1.4.4 算法的空间复杂度](#144-算法的空间复杂度)
- [第2章 线性表](#第2章-线性表)
  - [2.1 线性表的定义和特点](#21-线性表的定义和特点)
  - [2.2 案例引入](#22-案例引入)
    - [2.2.1 一元多项式的运算](#221-一元多项式的运算)
    - [2.2.2 稀疏多项式的运算](#222-稀疏多项式的运算)
  - [2.3 线性表的类型定义](#23-线性表的类型定义)
  - [2.4 线性表的顺序表示和实现](#24-线性表的顺序表示和实现)
    - [2.4.1 线性表的顺序存储表示](#241-线性表的顺序存储表示)
    - [2.4.2 顺序表中基本操作的实现](#242-顺序表中基本操作的实现)
      - [2.4.2.1 初始化](#2421-初始化)
      - [2.4.2.2 取值](#2422-取值)
      - [2.4.2.3 查找](#2423-查找)
      - [2.4.2.4 插入](#2424-插入)
      - [2.4.2.5 删除](#2425-删除)
  - [2.5 线性表的链式表示和实现](#25-线性表的链式表示和实现)
    - [2.5.1 单链表的定义和表示](#251-单链表的定义和表示)
    - [2.5.2 单链表基本操作的实现](#252-单链表基本操作的实现)
      - [2.5.2.1 初始化](#2521-初始化)
      - [2.5.2.2 取值](#2522-取值)
      - [2.5.2.3 查找](#2523-查找)
      - [2.5.2.4 插入](#2524-插入)
      - [2.5.2.5 删除](#2525-删除)
      - [2.5.2.6 创建单链表](#2526-创建单链表)
    - [2.5.3 循环链表](#253-循环链表)
    - [2.5.4 双向链表](#254-双向链表)
  - [2.6 顺序表和链表的比较](#26-顺序表和链表的比较)
    - [2.6.1 空间性能的比较](#261-空间性能的比较)
    - [2.6.2 时间性能的比较](#262-时间性能的比较)
  - [2.7 线性表的应用](#27-线性表的应用)
    - [2.7.1 线性表的合并](#271-线性表的合并)
    - [2.7.2 有序表的合并](#272-有序表的合并)
      - [2.7.2.1 顺序有序表的合并](#2721-顺序有序表的合并)
      - [2.7.2.2 链式有序表的合并](#2722-链式有序表的合并)
  - [2.8 案例分析与实现](#28-案例分析与实现)
    - [2.8.1 一元多项式的运算](#281-一元多项式的运算)
    - [2.8.2 稀疏多项式的运算](#282-稀疏多项式的运算)
      - [2.8.2.1 多项式的创建](#2821-多项式的创建)
      - [2.8.2.2 多项式的相加](#2822-多项式的相加)
- [第3章 栈和队列](#第3章-栈和队列)
  - [3.1 栈和队列的定义和特点](#31-栈和队列的定义和特点)
    - [3.1.1 栈的定义和特点](#311-栈的定义和特点)
    - [3.1.2 队列的定义和特点](#312-队列的定义和特点)
  - [3.2 案例引入](#32-案例引入)
  - [3.3 栈的表示和操作的实现](#33-栈的表示和操作的实现)
    - [3.3.1 栈的类型定义](#331-栈的类型定义)
    - [3.3.2 顺序栈的表示和实现](#332-顺序栈的表示和实现)
    - [3.3.3 链栈的表示和实现](#333-链栈的表示和实现)
  - [3.4 栈与递归](#34-栈与递归)
    - [3.4.1 采用递归算法解决的问题](#341-采用递归算法解决的问题)
      - [3.4.1.1 定义是递归的](#3411-定义是递归的)
      - [3.4.1.2 数据结构是递归的](#3412-数据结构是递归的)
      - [3.4.1.3 问题的解法是递归的](#3413-问题的解法是递归的)
    - [3.4.2 递归过程与递归工作栈](#342-递归过程与递归工作栈)
    - [3.4.3 递归算法的效率分析](#343-递归算法的效率分析)
      - [3.4.3.1 时间复杂度的分析](#3431-时间复杂度的分析)
      - [3.4.3.2 空间复杂度的分析](#3432-空间复杂度的分析)
    - [3.4.4 利用栈将递归转换为非递归的方法](#344-利用栈将递归转换为非递归的方法)
  - [3.5 队列的表示和操作的实现](#35-队列的表示和操作的实现)
    - [3.5.1 队列的类型定义](#351-队列的类型定义)
    - [3.5.2 循环队列——队列的顺序表示和实现](#352-循环队列队列的顺序表示和实现)
    - [3.5.3 链队——队列的链式表示和实现](#353-链队队列的链式表示和实现)
  - [3.6 案例分析与实现](#36-案例分析与实现)
    - [3.6.1 数制转换](#361-数制转换)
    - [3.6.2 括号匹配的检验](#362-括号匹配的检验)
    - [3.6.3 表达式求值](#363-表达式求值)
- [第4章 串、数组和广义表](#第4章-串-数组和广义表)
  - [4.1 串的定义](#41-串的定义)
  - [4.2 案例引入](#42-案例引入)
  - [4.3 串的类型定义、存储结构及其运算](#43-串的类型定义-存储结构及其运算)
    - [4.3.1 串的抽象类型定义](#431-串的抽象类型定义)
    - [4.3.2 串的存储结构](#432-串的存储结构)
      - [4.3.2.1 串的顺序存储](#4321-串的顺序存储)
      - [4.3.2.2 串的链式存储](#4322-串的链式存储)
    - [4.3.3 串的模式匹配算法](#433-串的模式匹配算法)
      - [4.3.3.1 BF（Brute-Force）算法](#4331-bfbrute-force算法)
      - [4.3.3.2 KMP算法](#4332-kmp算法)
  - [4.4 数组](#44-数组)
    - [4.4.1 数组的类型定义](#441-数组的类型定义)
    - [4.4.2 数组的顺序存储](#442-数组的顺序存储)
    - [4.4.3 特殊矩阵的压缩存储](#443-特殊矩阵的压缩存储)
      - [4.4.3.1 对称矩阵](#4431-对称矩阵)
      - [4.4.3.2 三角矩阵](#4432-三角矩阵)
      - [4.4.3.3 对角矩阵](#4433-对角矩阵)
  - [4.5 广义表](#45-广义表)
    - [4.5.1 广义表的定义](#451-广义表的定义)
    - [4.5.2 广义表的存储结构](#452-广义表的存储结构)
      - [4.5.2.1 头尾链表的存储结构](#4521-头尾链表的存储结构)
      - [4.5.2.2 扩展线性链表的存储结构](#4522-扩展线性链表的存储结构)
  - [4.6 案例分析与实现](#46-案例分析与实现)
- [第5章 树和二叉树](#第5章-树和二叉树)
  - [5.1 树和二叉树的定义](#51-树和二叉树的定义)
    - [5.1.1 树的定义](#511-树的定义)
    - [5.1.2 树的基本术语](#512-树的基本术语)
    - [5.1.3 二叉树的定义](#513-二叉树的定义)
  - [5.2 案例引入](#52-案例引入)
  - [5.3 树和二叉树的抽象数据类型定义](#53-树和二叉树的抽象数据类型定义)
  - [5.4 二叉树的性质和存储结构](#54-二叉树的性质和存储结构)
    - [5.4.1 二叉树的性质](#541-二叉树的性质)
    - [5.4.2 二叉树的存储结构](#542-二叉树的存储结构)
      - [5.4.2.1 顺序存储结构](#5421-顺序存储结构)
      - [5.4.2.2 链式存储结构](#5422-链式存储结构)
  - [5.5 遍历二叉树和线索二叉树](#55-遍历二叉树和线索二叉树)
    - [5.5.1 遍历二叉树](#551-遍历二叉树)
      - [5.5.1.1 遍历二叉树算法描述](#5511-遍历二叉树算法描述)
      - [5.5.1.2 根据遍历序列确定二叉树](#5512-根据遍历序列确定二叉树)
      - [5.5.1.3 二叉树遍历算法的应用](#5513-二叉树遍历算法的应用)
    - [5.5.2 线索二叉树](#552-线索二叉树)
      - [5.5.2.1 线索二叉树的基本概念](#5521-线索二叉树的基本概念)
      - [5.5.2.2 构造线索二叉树](#5522-构造线索二叉树)
      - [5.5.2.3 遍历线索二叉树](#5523-遍历线索二叉树)
  - [5.6 树和森林](#56-树和森林)
    - [5.6.1 树的存储结构](#561-树的存储结构)
      - [5.6.1.1 双亲表示法](#5611-双亲表示法)
      - [5.6.1.2 孩子表示法](#5612-孩子表示法)
      - [5.6.1.3 孩子兄弟法](#5613-孩子兄弟法)
    - [5.6.2 森林与二叉树的转换](#562-森林与二叉树的转换)
      - [5.6.2.1 森林转换成二叉树](#5621-森林转换成二叉树)
      - [5.6.2.2 二叉树转换成森林](#5622-二叉树转换成森林)
    - [5.6.3 树和森林的遍历](#563-树和森林的遍历)
      - [5.6.3.1 树的遍历](#5631-树的遍历)
      - [5.6.3.2 森林的遍历](#5632-森林的遍历)
  - [5.7 哈夫曼树及其应用](#57-哈夫曼树及其应用)
    - [5.7.1 哈夫曼树的基本概念](#571-哈夫曼树的基本概念)
    - [5.7.2 哈夫曼树的构造算法](#572-哈夫曼树的构造算法)
    - [5.7.3 哈夫曼编码](#573-哈夫曼编码)
  - [5.8 案例分析与实现](#58-案例分析与实现)
- [第6章 图](#第6章-图)
  - [6.1 图的定义和基本术语](#61-图的定义和基本术语)
    - [6.1.1 图的定义](#611-图的定义)
    - [6.1.2 图的基本术语](#612-图的基本术语)
  - [6.2 案例引入](#62-案例引入)
  - [6.3 图的类型定义](#63-图的类型定义)
  - [6.4 图的存储结构](#64-图的存储结构)
    - [6.4.1 邻接矩阵](#641-邻接矩阵)
    - [6.4.2 邻接表](#642-邻接表)
    - [6.4.3 十字链表](#643-十字链表)
    - [6.4.4 邻接多重表](#644-邻接多重表)
  - [6.5 图的遍历](#65-图的遍历)
    - [6.5.1 深度优先搜索](#651-深度优先搜索)
    - [6.5.2 广度有限搜索](#652-广度有限搜索)
  - [6.6 图的应用](#66-图的应用)
    - [6.6.1 最小生成树](#661-最小生成树)
      - [6.6.1.1 普里姆（Prim）算法](#6611-普里姆prim算法)
      - [6.6.1.2 克鲁斯卡尔（Kruskal）算法](#6612-克鲁斯卡尔kruskal算法)
    - [6.6.2 最短路径](#662-最短路径)
      - [6.6.2.1 从某个源点到其余各顶点的最短路径](#6621-从某个源点到其余各顶点的最短路径)

<!-- /code_chunk_output -->

# 第1章 绪论

## 1.1 数据结构的研究内容

数据结构是一门研究非数值计算程序设计中的操作对象，以及这些对象之间的关系和操作的学科。

## 1.2 基本概念和术语

### 1.2.1 数据、数据元素、数据项和数据对象

**数据** （Data）是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。

**数据元素**（Data Element）是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。在有些情况下，数据元素也称为元素、记录等。数据元素用于完整地描述一个对象。

**数据项** （Data Item）是组成数据元素的、有独立含义的、不可分割的最小单位。

**数据对象** （Data Object）是性质相同的数据元素的集合，是数据的一个子集。不论数据元素集合是无限集（如整数集），或是有限集（如字母字符集），还是由多个数据项组成的复合数据元素（如学生表）的集合， 只要集合内元素的性质均相同，都可称之为一个数据对象。

### 1.2.2 数据结构

**数据结构** （Data Structure）是相互之间存在一种或多种特定关系的数据元素的集合。换句话说，数据结构是带＂结构＂的数据元素的集合，＂结构＂就是指数据元素之间存在的关系。

数据结构包括逻辑结构和存储结构两个层次。

#### 1.2.2.1 逻辑结构

数据的**逻辑结构**是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。

数据的逻辑结构有两个要素： 一是数据元素，二是关系。

关系是指数据元素间的逻辑关系。根据数据元素之间关系的不同特性， 通常有四类基本结构：集合结构、线性结构、树结构、图结构。它们的复杂程度依次递进，如图 1.1 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图1.1-基本逻辑结构.7b7sqbouqb80.png">
    <br>
    图1.1 基本逻辑结构
</div>

1. 集合结构：数据元素之间除了 “属于同一集合” 的关系外，别无其他关系。
2. 线性结构：数据元素之间存在一对一的关系。
3. 树结构：数据元素之间存在一对多的关系。
4. 图结构或网状结构：数据元素之间存在多对多的关系。

其中集合结构、树结构和图结构都属于非线性结构。

线性结构包括线性表、栈和队列、字符串、数组、广义表。非线性结构包括树和二叉树、有向图和无向图。这几种逻辑结构可以用一个层次图描述，如图 1.2 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图1.2-逻辑结构层次图.1bkw97q3uirk.png">
    <br>
    图1.2 逻辑结构层次图
</div>

#### 1.2.2.2 存储结构

数据对象在计算机中的存储表示称为数据的**存储结构**，也称为**物理结构**。

数据元素在计算机中有两种基本的存储结构，分别是顺序存储结构和链式存储结构。

1. 顺序存储结构：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述。顺序存储结构要求所有的元素依次存放在一片连续的存储空间中。
2. 链式存储结构：链式存储结构无需占用一整块存储空间，但为了表示结点之间的关系，需要给每个结点附加指针字段，用于存放后继元素的存储地址。所以链式存储结构通常借助于程序设计语言的指针类型来描述。

### 1.2.3 数据类型和抽象数据类型

**数据类型**（Data Type）是一个值的集合和定义在这个值集上的一组操作的总称。

**抽象数据类型** （Abstract Data Type，ADT）一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合。

抽象数据类型的定义格式如下：

```text
ADT 抽象数据类型名 {
    数据对象：<数据对象的定义>
    数据关系：<数据关系的定义>
    基本操作：<基本操作的定义>
} ADT 抽象数据类型名
```

其中，数据对象和数据关系的定义采用数学符号和自然语言描述，基本操作的定义格式为：

```text
基本操作名(参数表)
初始条件：<初始条件描述>
操作结果：<操作结果描述>
```

基本操作有两种参数：赋值参数只为操作提供输入值；引用参数以 "&" 打头，除可提供输入值外，还将返回操作结果。“初始条件” 描述了操作执行之前数据结构和参数应满足的条件，若初始条件为空，则省略。“操作结果” 说明了操作正常完成之后，数据结构的变化状况和应返回的结果。

## 1.3 抽象数据类型的表示与实现

以复数为例，给出一个完整的抽象数据类型的定义、 表示和实现。

定义部分：

```text
ADT Complex { 
    数据对象：D={e1,e2 | e1,e2∈R,R是实数集}
    数据关系：S={<e1,e2> | e1是复数的实部,e2是复数的虚部}
    基本操作：
        Creat (&C, x, y) 
            操作结果：构造复数C, 其实部和虚部分别被赋以参数x和y的值。
        GetReal(C) 
            初始条件：复数C已存在。
            操作结果：返回复数C的实部值。
        GetImag (C) 
            初始条件：复数C已存在。
            操作结果：返回复数C的虚部值。
        Add(C1, C2) 
            初始条件：C1, C2 是复数。
            操作结果：返回两个复数 C1 和 C2 的和。
        Sub(C1, C2) 
            初始条件：C1, C2 是复数。
            操作结果：返回两个复数 C1 和 C2 的差。
} ADT Complex 
```

表示部分：

```C{.line-numbers}
typedef struct // 复数类型
{
    float Realpart; // 实部
    float Imagepart; // 虚部
} Complex; 
```

实现部分：

```C{.line-numbers}
// 构造一个复数
void Create(&Complex C, float x, float y)
{
    C.Realpart = x;
    C.Imagepart = y;
}

// 取复数 C=x+yi 的实部
float GetReal(Complex C)
{
    return C.Realpart;
}

// 取复数 C=x+yi 的虚部
float GetImag(Complex C)
{
    return C.Imagepart;
}

// 求两个复数 C1 和 C2 的和
Complex Add(Complex C1, Complex C2)
{
    Complex sum;
    sum.Realpart = C1.Realpart + C2.Realpart;
    sum.Imagepart = C1.Imagepart + C2.Imagepart;
    return sum;
}

// 求两个复数 C1 和 C2 的差
Complex Sub(Complex C1, Complex C2)
{
    Complex difference; 
    difference.Realpart = C1.Realpart - C2.Realpart; 
    difference.Imagepart = C1.Imagepart - C2.Imagepart; 
    return difference;
}
```

## 1.4 算法和算法分析

### 1.4.1 算法的定义及特性

**算法** （Algorithm）是为了解决某类问题而规定的一个有限长的操作序列。

一个算法必须满足以下五个重要特性：

1. 有穷性。一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。
2. 确定性。对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性，使算法的执行者或阅读者都能明确其含义及如何执行。
3. 可行性。算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。
4. 输入。一个算法有零个或多个输入。
5. 输出。一个算法有一个或多个输出。

### 1.4.2 评价算法优劣的基本标准

1. 正确性。在合理的数据输入下，能够在有限的运行时间内得到正确的结果。
2. 可读性。可读性强的算法有助于人们对算法的理解，而难懂的算法易于隐藏错误，且难于调试和修改。
3. 健壮性。当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。
4. 高效性。高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标。

### 1.4.3 算法的时间复杂度

#### 1.4.3.1 问题规模和语句频度

不考虑计算机的软硬件等环境因素，影响算法时间代价的最主要因素是问题规模。**问题规模**是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数 $n$ 表示。问题规模 $n$ 对不同的问题含义不同，例如，在排序运算中 $n$ 为参加排序的记录数，在矩阵运算中 $n$ 为矩阵的阶数，在多项式运算中 $n$ 为多项式的项数，在集合运算中 $n$ 为集合中元素的个数，在树的有关运算中 $n$ 为树的结点个数，在图的有关运算中 $n$ 为图的顶点数或边数。显然，$n$ 越大算法的执行时间越长。

一个算法的执行时间大致上等于其所有语句执行时间的总和， 而语句的执行时间则为该条语句的重复执行次数 和执行一次所需时间的乘积。

一条语句的重复执行次数称作**语句频度**（Frequency Count）。

设每条语句执行一次所需的时间均是单位时间， 则一个算法的执行时间可用该算法中所有语句频度之和来度量。

#### 1.4.3.2 算法的时间复杂度定义

**基本语句**指的是算法中重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大。

一般情况下，算法中基本语句重复执行的次数是问题规模 $n$ 的某个函数 $f(n)$, 算法的时间量度记作
$$
T(n)=O(f(n))
$$

它表示随问题规模 $n$ 的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，称做算法的**渐近时间复杂度**，简称**时间复杂度**（Time Complexity）。

数学符号 $O$ 的严格定义为：若 $T(n)$ 和 $f(n)$ 是定义在正整数集合上的两个函数，则 $T(n)= O(f(n))$ 表示存在正的常数 $C$ 和 $n_0$，使得当 $n\geqslant n_0$ 时都满足 $0\leqslant T(n)\leqslant Cf(n)$。

该定义说明了函数 $T(n)$ 和 $f(n)$ 具有相同的增长趋势，并且 $T(n)$ 的增长至多趋向于函数 $f(n)$ 的增长。符号 $O$ 用来描述增长率的上限，它表示当问题规模 $n>n_0$ 时，算法的执行时间不会超过 $f(n)$。

#### 1.4.3.3 算法的时间复杂度分析

分析算法时间复杂度的基本方法为：找出所有语句中语句频度最大的那条语句作为基本语句，计算基本语句的频度得到问题规模 $n$ 的某个函数 $f(n)$， 取其数量级用符号 $O$ 表示即可。计算数量级时，可以遵循以下定理。

> **定理 1.1**  若 $f(n)=a_mn^m+a_{m-1}n^{m-1}+\dots+a_1n+a_0$ 是一个 $m$ 次多项式，则 $T(n)=O(n^m)$。

定理 1.1 说明，在计算算法时间复杂度时，可以忽略所有低次幕项和最高次幕的系数，这样可以简化算法分析，也体现出了增长率的含义。

常见的时间复杂度按数量级递增排列依次为：
$$
O(1)<O(\log_2n)<O(n)<O(n\log_2n)<O(n^2)<O(n^3)<\dots<O(n^k)<O(2^n)
$$

#### 1.4.3.4 最好、最坏和平均时间复杂度

称算法在最好情况下的时间复杂度为**最好时间复杂度**，指的是算法计算量可能达到的最小值；称算法在最坏情况下的时间复杂度为**最坏时间复杂度**，指的是算法计算量可能达到的最大值；算法的**平均时间复杂度**是指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。

### 1.4.4 算法的空间复杂度

我们采用**渐近空间复杂度**作为算法所需存储空间的扯度，简称**空间复杂度**（Space Complexity），它也是问题规模 $n$ 的函数，记作：
$$
S(n)=O(f(n))
$$

# 第2章 线性表

## 2.1 线性表的定义和特点

由 $n(n\geqslant0)$ 个数据特性相同的元素构成的有限序列称为**线性表**。线性表中元素的个数 $n(n\geqslant0)$ 定义为线性表的长度，$n=0$ 时称为**空表**。

对于非空的线性表或线性结构，其特点是：

1. 存在唯一的一个被称作 “第一个“ 的数据元素；
2. 存在唯一的一个被称作 “最后一个“ 的数据元素；
3. 除第一个之外，结构中的每个数据元素均只有一个前驱；
4. 除最后一个之外，结构中的每个数据元素均只有一个后继。

## 2.2 案例引入

### 2.2.1 一元多项式的运算

在数学上，一个一元 n 次多项式 $P_n(x)$ 可按升幂写成：
$$
P_n(x)=p_0+p_1x+p_2x^2+\cdots+p_nx^n
$$

一元 n 次多项式可由 $n+1$ 个系数唯一确定，因此，可以将一元 n 次多项式 $P_n(x)$ 抽象为一个由 $n+1$ 个元素组成的有序序列，用一个线性表 $P$ 来表示：
$$
P=(p_0,p_1,p_2,\cdots,p_n)
$$

这时，每一项的指数 $i$ 隐含在其系数 $p_i$ 的序号中。

假设 $Q_m(x)$ 是一元 m 次多项式，同样可以用线性表 $Q$ 来表示：
$$
Q=(q_0,q_1,q_2,\cdots,q_m)
$$

不失一般性，设 $m\leqslant n$，则两个多项式相加的结果 $R_n(x)=P_n(x)+Q_m(x)$ 可用线性表 $R$ 表示：
$$
R=(p_0+q_0,p_1+q_1,p_2+q_2,\cdots,p_m+q_m,p_{m+1},\cdots,p_n)
$$

### 2.2.2 稀疏多项式的运算

例如，在处理形如 $S(x)=1+3x^{10000}+2x^{20000}$ 的多项式时，需要用一个长度为 20001 的线性表来表示，而表中只有 3 个非零元素，此时将会造成存储空间的很大浪费。

一般情况下的一元 n 次多项式可写成
$$
P_n(x)=p_1x^{e_1}+p_2x^{e_2}+\cdots+p_mx^{e_m}
$$

其中，$p_i$ 是指数为 $e_i$ 的项的非零系数，且满足
$$
0\leqslant e_1<e_2<\cdots<e_m=n
$$

若用一个长度为 $m$ 且每个元素有两个数据项（系数项和指数项）的线性表
$$
((p_1,e_1),(p_2,e_2),\cdots,(p_m,e_m))
$$

便可唯一确定多项式 $P_n(x)$。在最坏情况下，$n+1$ 个系数都不为零，则比只存储每项系数的方案要多存储一倍的数据。但是，对于类似 $S(x)$ 的稀疏多项式，这种表示将大大节省空间。

如果多项式属于非稀疏多项式，且只对多项式进行 “求值” 等不改变多项式的系数和指数的运算，可采用数组表示的顺序存储结构。

稀疏多项式采用数组表示法的缺点：

1. 存储空间分配不够灵活。因为事先无法确定多项式的非零项数，所以需要根据预期估计可能的最大值定义数组的大小，这种分配方式可能会带来两种问题：
   （1）实际非零项数比较小，浪费了大量存储空间。
   （2）实际非零项式超过了最大值，存储空间不够。
2. 在实现多项式相加时，需要开辟一个新的数组保存结果多项式，导致算法的空间复杂度较高。

对于稀疏多项式，更好的办法是利用链式存储结构表示多项式的有序序列。

## 2.3 线性表的类型定义

$$
\begin{aligned}
    &\texttt{ADT List \{}\\
    &\texttt{\quad 数据对象：$D=\{a_i\,|\,a_i\in\text{ElemSet},\,i=1,2,\cdots,n,\,n\geqslant 0\}$}\\
    &\texttt{\quad 数据关系：$R=\{\textrm{<}a_{i-1},a_i\textrm{>}|\,a_{i-1},a_i\in D,\,i=1,2,\cdots,n\}$}\\
    &\texttt{\quad 基本操作：}\\
    &\texttt{\qquad InitList(\&L)}\\
    &\texttt{\qquad\quad 操作结果：构造一个空的线性表\,L}\\
    &\texttt{\qquad DestroyList(\&L)}\\
    &\texttt{\qquad\quad 初始条件：线性表\,L\,已存在}\\
    &\texttt{\qquad\quad 操作结果：销毁线性表\,L}\\
    &\texttt{\qquad ClearList(\&L)}\\
    &\texttt{\qquad\quad 初始条件：线性表\,L\,已存在}\\
    &\texttt{\qquad\quad 操作结果：将\,L\,重置为空表}\\
    &\texttt{\qquad ListEmpty(L)}\\
    &\texttt{\qquad\quad 初始条件：线性表\,L\,已存在}\\
    &\texttt{\qquad\quad 操作结果：若\,L为空表，则返回\,true，否则返回\,false}\\
    &\texttt{\qquad ListLength(L)}\\
    &\texttt{\qquad\quad 初始条件：线性表\,L\,已存在}\\
    &\texttt{\qquad\quad 操作结果：返回\,L\,中数据元素个数}\\
    &\texttt{\qquad GetElem(L, i, \&e)}\\
    &\texttt{\qquad\quad 初始条件：线性表\,L\,已存在，且 $1\leqslant i\leqslant \operatorname{ListLength}(L)$}\\
    &\texttt{\qquad\quad 操作结果：用\,e\,返回\,L\,中第\,i\,个数据元素的值}\\
    &\texttt{\qquad LocateElem(L, e)}\\
    &\texttt{\qquad\quad 初始条件：线性表\,L\,已存在}\\
    &\texttt{\qquad\quad 操作结果：返回\,L\,中第一个值与\,e\,相同的元素在\,L\,中的位置。}\\
    &\texttt{\qquad\qquad\qquad\qquad 若这样的数据元素不存在，则返回\,0}\\
    &\texttt{\qquad PriorElem(L, cur\_e, \&pre\_e)}\\
    &\texttt{\qquad\quad 初始条件：线性表\,L\,已存在}\\
    &\texttt{\qquad\quad 操作结果：若\,cur\_e\,是\,L\,的数据元素，且不是第一个，则用\,pre\_e\,返回其前驱；}\\
    &\texttt{\qquad\qquad\qquad\qquad 否则操作失败，pre\_e\,无定义}\\
    &\texttt{\qquad NextElem(L, cur\_e, \&next\_e)}\\
    &\texttt{\qquad\quad 初始条件：线性表\,L\,已存在}\\
    &\texttt{\qquad\quad 操作结果：若\,cur\_e\,是\,L\,的数据元素，且不是最后一个，则用\,next\_e\,返回其后继；}\\
    &\texttt{\qquad\qquad\qquad\qquad 否则操作失败，next\_e\,无定义}\\
    &\texttt{\qquad ListDelete(\&L, i)}\\
    &\texttt{\qquad\quad 初始条件：线性表\,L\,已存在，且 $1\leqslant i\leqslant \operatorname{ListLength}(L)$}\\
    &\texttt{\qquad\quad 操作结果：删除\,L\,的第\,i\,个数据元素，L\,的长度减\,1}\\
    &\texttt{\qquad TraverseList(L)}\\
    &\texttt{\qquad\quad 初始条件：线性表\,L\,已存在}\\
    &\texttt{\qquad\quad 操作结果：对线性表\,L\,进行遍历，在遍历过程中对\,L\,的每个结点访问一次}\\
    &\texttt{\} ADT List}
\end{aligned}
$$

## 2.4 线性表的顺序表示和实现

### 2.4.1 线性表的顺序存储表示

线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。通常，称这种存储结构的线性表为**顺序表**（Sequential List）。其特点是，逻辑上相邻的数据元素，其物理次序也是相邻的。

假设线性表的每个元素需占用 $l$ 个存储单元， 并以所占的第一个单元的存储地址作为数据元素的存储起始位置。则线性表中第 $i+1$ 个数据元素的存储位置 $\text{LOC}(a_{i+1})$ 和第 $i$ 个数据元素的存储位置 $\text{LOC}(a_i)$ 之间满足下列关系：
$$
\text{LOC}(a_{i+1})=\text{LOC}(a_i)+l
$$

一般来说，线性表的第 $i$ 个数据元素 $a_i$ 的存储位置为：
$$
\text{LOC}(a_i)=\text{LOC}(a_1)+(i-1)\times l
$$

式中，$\text{LOC}(a_1)$ 是线性表的第一个数据元素 $a_1$ 的存储位置，通常称作线性表的起始位置或基地址。每一个数据元素的存储位置都和线性表的起始位置相差一个常数，这个常数和数据元素在线性表中的位序成正比。由此，只要确定了存储线性表的起始位置，线性表中任一数据元素都可随机存取，所以线性表的顺序存储结构是一种**随机存取**的存储结构。

在 C 语言中可以用动态分配的一维数组表示线性表，描述如下：

```C{.line-numbers}
//--------顺序表的存储结构---------
#define MAXSIZE 100 // 顺序表可能达到的最大长度

typedef struct
{
    ElemType *elem; // 存储空间的基地址
    int length; // 当前长度
} SqList;
```

### 2.4.2 顺序表中基本操作的实现

#### 2.4.2.1 初始化

顺序表的初始化操作就是构造一个空的顺序表。

> **算法2.1** 顺序表的初始化
>
> 1. 为顺序表`L`动态分配一个预定义大小的数组空间，使`elem`指向这段空间的基地址。
> 2. 将表的当前长度设为 0。

```C{.line-numbers}
// 构造一个空的顺序表 L
Status InitList(SqList &L)
{
    L.elem = new ElemType[MAXSIZE]; // 为顺序表分配一个大小为 MAXSIZE 的数组空间
    if (!L.elem) exit(OVERFLOW); // 存储分配失败
    L.length = 0; // 空表长度为 0
    return OK;
}
```

#### 2.4.2.2 取值

取值操作是根据指定的位置序号 i，获取顺序表中第 i 个数据元素的值。

> **算法2.2** 顺序表的取值
>
> 1. 判断指定的位置序号 $i$ 是否合理（`1 ≤ i ≤ L.length`），若不合理，返回 ERROR。
> 2. 若 $i$ 值合理，则将第 $i$ 个数据元素`L.elem[i - 1]`赋给参数`e`，通过`e`返回第 $i$ 个数据元素的值。

```C{.line-numbers}
Status GetElem(SqList L, int i, ElemType &e)
{
    if (i < 1 || i > L.length) return ERROR; // 判断 i 值是否合理，若不合理，返回 ERROR
    e = L.elem[i - 1];
    return OK;
}
```

顺序表取值算法的时间复杂度为 $O(1)$。

#### 2.4.2.3 查找

查找操作是根据指定的元素值`e`, 查找顺序表中第一个与`e`相等的元素。若查找成功，则返回该元素在表中的位置序号；若查找失败，则返回 0。

> **算法2.3** 顺序表的查找
>
> 1. 从第一个元素起，依次和`e`相比较，若找到与`e`相等的元素`L.elem[i]`，则查找成功，返回该元素的序号`i+1`。
> 2. 若查遍整个顺序表都没有找到，则查找失败，返回 0。

```C{.line-numbers}
// 在顺序表 L 中查找值为 e 的数据元素，返回其序号
int LocateElem(SqList L, ElemType e)
{
    for (int i = 0; i < L.length; i++)
    {
        if (L.elem[i] == e) return i + 1; // 查找成功，返回序号 i+1
    }
    return 0; // 查找失败，返回 0
}
```

在查找时，为确定元素在顺序表中的位置，需和给定值进行比较的数据元素个数的期望值称为查找算法在查找成功时的**平均查找长度** （Average Search Length，ASL）。

假设 $p_i$ 是查找第 $i$ 个元素的概率，$C_i$ 为找到表中其关键字与给定值相等的第 $i$ 个记录时，和给定值已进行过比较的关键字个数，则在长度为 $n$ 的线性表中，查找成功时的平均查找长度为：
$$
ASL=\sum_{i=1}^n p_i C_i
$$

$C_i$ 取决于所查元素在表中的位置，一般情况下 $C_i=i$。假设每个元素的查找概率相等，即 $p_i=\dfrac{1}{n}$，则平均查找长度为：
$$
ASL=\frac{1}{n}\sum_{i=1}^n i=\frac{n+1}{2}
$$

由此可见，顺序表按值查找算法的平均时间复杂度为 $O(n)$。

#### 2.4.2.4 插入

线性表的插入操作是指在表的第 $i$ 个位置插入一个新的数据元素 $e$，使长度为 $n$ 的线性表
$$
(a_1,\cdots,a_{i-1},a_i,\cdots,a_n)
$$

变成长度为 $n+1$ 的线性表
$$
(a_1,\cdots,a_{i-1},e,a_i,\cdots,a_n)
$$

> **算法2.4** 顺序表的插入
>
> 1. 判断插入位置 $i$ 是否合法，若不合法则返回 ERROR。
> 2. 判断顺序表的存储空间是否已满，若满则返回 ERROR。
> 3. 将第 $n$ 个至第 $i$ 个位置的元素依次向后移动一个位置，空出第 $i$ 个位置。
> 4. 将要插入的新元素`e`放入第 $i$ 个位置。
> 5. 表长加 1。

```C{.line-numbers}
// 在顺序表 L 中第 i 个位置之前插入新元素 e
Status ListInsert(SqList &L, int i, ElemType e)
{
    if (i < 1 || i > L.length + 1) return ERROR; // i 值不合法
    if (L.length == MAXSIZE) return ERROR; // 当前存储空间已满

    for (int j = L.length - 1; j >= i - 1; j--)
    {
        L.elem[j + 1] = L.elem[j]; // 插入位置及之后的元素后移
    }
    L.elem[i - 1] = e; // 将新元素放入第 i 个位置
    L.length++; // 表长加 1
    return OK;
}
```

当在顺序表中某个位置上插入一个数据元素时，其时间主要耗费在移动元素上，而移动元素的个数取决于插入元素的位置。

假设 $p_i$ 是在第 $i$ 个元素之前插入一个元素的概率，$E_{\text{ins}}$ 为在长度为 $n$ 的线性表中插入一个元素时所需移动元素次数的期望值，则有
$$
E_{\text{ins}}=\sum_{i=1}^{n+1}p_i(n-i+1)
$$

假设在线性表的任何位置上插入元素都是等概率的，即 $p_i=\dfrac{1}{n+1}$，则有
$$
E_{\text{ins}}=\frac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)=\frac{n}{2}
$$

由此可见，顺序表插入算法的平均时间复杂度为 $O(n)$。

#### 2.4.2.5 删除

线性表的删除操作是指将表的第 $i$ 个元素删去，将长度为 $n$ 的线性表
$$
(a_1,\cdots,a_{i-1},a_i,a_{i+1},\cdots,a_n)
$$

变成长度为 $n-1$ 的线性表
$$
(a_1,\cdots,a_{i-1},a_{i+1},\cdots,a_n)
$$

> **算法2.5** 顺序表的删除
>
> 1. 判断删除位置 $i$ 是否合法，若不合法则返回 ERROR。
> 2. 将第 $i+1$ 个至第 $n$ 个元素依次向前移动一个位置。
> 3. 表长减 1。

```C{.line-numbers}
// 在顺序表 L 中删除第 i 个元素
Status ListDelete(SqList &L, int i)
{
    if (i < 1 || i > L.length + 1) return ERROR; // i 值不合法

    for (int j = i; j <= L.length - 1; j++)
    {
        L.elem[j - 1] = L.elem[j]; // 被删除元素之后的元素前移
    }
    L.length--; // 表长减 1
    return OK;
}
```

当在顺序表中某个位置上删除一个数据元素时，其时间主要耗费在移动元素上，而移动元素的个数取决于删除元素的位置。

假设 $p_i$ 是删除第 $i$ 个元素的概率，$E_{\text{del}}$ 为在长度为 $n$ 的线性表中删除一个元素时所需移动元素次数的期望值，则有
$$
E_{\text{del}}=\sum_{i=1}^n p_i(n-i)
$$

假设在线性表的任何位置上删除元素都是等概率的，即 $p_i=\dfrac{1}{n}$，则有
$$
E_{\text{del}}=\frac{1}{n}\sum_{i=1}^n (n-i)=\frac{n-1}{2}
$$

由此可见，顺序表删除算法的平均时间复杂度为 $O(n)$。

## 2.5 线性表的链式表示和实现

### 2.5.1 单链表的定义和表示

线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。

为了表示每个数据元素 $a_i$ 与其直接后继数据元素 $a_{i+1}$ 之间的逻辑关系，对数据元素 $a_i$ 来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息。这两部分信息组成数据元素 $a_i$ 的存储映像，称为**结点**（node）。它包括两个域：其中存储数据元素信息的域称为**数据域**，存储直接后继存储位置的域称为**指针域**。指针域中存储的信息称作**指针**或**链**。$n$ 个结点链接成一个**链表**，即为线性表 $(a_1,a_2,\cdots,a_n)$ 的链式存储结构。又由于此链表的每个结点中只包含一个指针域，故又称**线性链表**或**单链表**。

在线性表的单链表存储结构中，整个链表的存取必须从头指针开始进行，**头指针**指示链表中第一个结点（即第一个数据元素的存储映像，也称**首元结点**）的存储位置。由于最后一个数据元素没有直接后继，则单链表中最后一个结点的指针为空。

用单链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的。指针为数据元素之间的逻辑关系的映像，则逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻，由此，这种存储结构为非顺序映像或链式映像。

单链表可由头指针唯一确定，在 C 语言中可用 “结构指针” 来描述：

```C{.line-numbers}
//--------------单链表的存储结构------------------
typedef struct LNode
{
    ElemType data; // 结点的数据域
    struct LNode *next; // 结点的指针域
} LNode, *LinkList;
```

单链表是由表头指针唯一确定，因此单链表可以用头指针的名字来命名。若头指针名是 L，则简称该链表为表 L。

为了处理方便，可以在单链表的第一个结点之前附设一个结点，称为**头结点**。链表增加头结点的作用有：

1. 便于首元结点的处理。增加了头结点后，首元结点的地址保存在头结点的指针域中，则对链表的第一个数据元素的操作与其他数据元素相同，无需进行特殊处理。
2. 便于空表和非空表的统一处理。当链表不设头结点时，假设 L 为单链表的头指针，它应该指向首元结点，则当单链表为空时，L 指针为空；增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针。

首元结点、头结点、头指针三个概念容易混淆，说明如下：

1. 首元结点是指链表中存储第一个数据元素 $a_1$ 的结点。
1. 头结点是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以不存储任何信息，也可以存储于数据元素类型相同的其他附加信息。
1. 头指针是指向链表中第一个结点的指针。若链表有头结点，则头指针指向头结点；若链表没有头结点，则头指针指向首元结点。

在单链表中，各个元素的存储位置都是随意的，每个元素的存储位置都包含在其直接前驱结点的信息之中。由此，单链表是非随机存取的存储结构，要取得第 $i$ 个数据元素必须从头指针出发顺链进行寻找，也称为**顺序存取**的存取结构。

### 2.5.2 单链表基本操作的实现

#### 2.5.2.1 初始化

单链表的初始化操作就是构造一个空表。

> **算法2.6** 单链表的初始化
>
> 1. 生成新结点作为头结点，用头指针`L`指向头结点。
> 2. 头结点的指针域置空。

```C++{.line-numbers}
// 构造一个空的单链表 L
Status InitList(LinkList &L)
{
    L = new LNode; // 生成新结点作为头结点，用头指针 L 指向头结点
    L->next = NULL; // 头结点的指针域置空
    return OK;
}
```

#### 2.5.2.2 取值

> **算法2.7** 单链表的取值
>
> 1. 用指针`p`指向首元结点，用`j`做计数器并赋初值为 1。
> 2. 从首元结点开始依次顺着指针域`next`向下访问，只要指向当前结点的指针`p`不为空，并且没有到达序号为`i`的结点，则循环执行以下操作：
>    （1）`p`指向下一个结点。
>    （2）计数器`j`加 1。
> 3. 退出循环时，如果指针`p`为空，或者计数器`j`大于`i`，说明指定的序号`i`不合法，取值失败，返回 ERROR；否则取值成功，此时 $j=i$，`p`所指的结点就是要找的第 $i$ 个结点，用参数`e`保存当前结点的数据域，返回 OK。

```C{.line-numbers}
// 在带头结点的单链表 L 中根据序号 i 获取元素的值，用 e 返回 L 中第 i 个数据元素的值
Status GetElem(LinkList L, int i, ElemType &e)
{
    // 初始化
    LNode *p = L->next; // p 指向首元结点
    int j = 1; // 计数器 j 初值为 1
    
    // 顺着链向后扫描，直到 p 为空或 p 指向第 i 个元素
    while (p && j < i)
    {
        p = p->next; // p 指向下一个结点
        j++; // 计数器加 1
    }
    
    if (!p || j > i) return ERROR;
    e = p->data;
    return OK;
}
```

该算法的基本操作是比较 $j$ 和 $i$ 并后移指针`p`，`while`循环体中的语句频度与位置 $i$ 有关。若 $1\leqslant i \leqslant n$，则频度为 $i-1$，一定能取值成功；若 $i>n$，则频度为 $n$，取值失败。因此算法 2.7 的最坏时间复杂度为 $O(n)$。

假设每个位置上元素的取值概率相等，即 $p_i=\dfrac{1}{n}$，则
$$
ASL=\sum_{i=1}^n p_i(i-1)=\dfrac{1}{n}\sum_{i=1}^n (i-1)=\dfrac{n-1}{2}
$$

由此可见，单链表取值算法的平均时间复杂度为 $O(n)$。

#### 2.5.2.3 查找

> **算法2.8** 单链表的按值查找
>
> 1. 用指针`p`指向首元结点。
> 2. 从首元结点开始依次顺着指针域`next`向下查找，只要指向当前结点的指针`p`不为空，并且`p`所指结点的数据域不等于给定值`e`，则循环执行以下操作：`p`指向下一个结点。
> 3. 返回`p`。若查找成功，`p`此时即为结点的地址；若查找失败，`p`的值为`NULL`。

```C{.line-numbers}
// 在带头结点的单链表 L 中查找值为 e 的元素
LNode* LocateElem(LinkList L, ElemTpe e)
{
    LNode *p = L->next; // 初始化，p 指向首元结点
    while (p && p->data != e) // 顺着链向后扫描，直到 p 为空或 p 所指结点的数据域等于 e
    {
        p = p->next; // p 指向下一个结点
    }
    return p;
}
```

该算法的平均时间复杂度分析类似于算法 2.7，也是 $O(n)$。

#### 2.5.2.4 插入

> **算法2.9** 单链表的插入：将值为`e`的新结点插入到表的第 $i$ 个结点的位置上，即插入到结点 $a_{i-1}$ 与 $a_i$ 之间。
>
> 1. 查找结点 $a_{i-1}$ 并由指针`p`指向该结点。
> 2. 生成一个新结点`*s`。
> 3. 将新结点`*s`的数据域置为`e`。
> 4. 将新结点`*s`的指针域指向结点 $a_i$。
> 5. 将结点`*p`的指针域指向新结点`*s`。

```C++{.line-numbers}
// 在带头结点的单链表 L 中第 i 个位置插入值为 e 的新结点
Status ListInsert(LinkList &L, int i, ElemType e)
{
    LNode *p = L;
    int j = 0;
    
    // 查找第 i-1 个结点，p 指向该结点
    while (p && j < i - 1)
    {
        p = p->next;
        j++;
    }
    if (!p || j > i - 1) return ERROR;
    
    LNode *s = new LNode; // 生成新结点 *s
    s->data = e; // 将结点 *s 的数据域置为 e
    s->next = p->next; // 将结点 *s 的指针域指向结点 ai
    p->next = s; // 将结点 *p 的指针域指向结点 *s
    return OK;
}
```

注意：插入位置可能为链表头部，因此初始化时指针`p`指向头结点而不是首元结点，计数器为 0 而不是 1。

为了在第 $i$ 个结点之前插入一个新结点，必须首先找到第 $i-1$ 个结点，其平均时间复杂度与算法 2.7 相同，为 $O(n)$。

#### 2.5.2.5 删除

> **算法2.10** 单链表的删除：删除单链表的第 $i$ 个结点 $a_i$。
>
> 1. 查找结点 $a_{i-1}$ 并由指针`p`指向该结点。
> 2. 临时保存待删除结点 $a_i$ 的地址在`q`中，以备释放。
> 3. 将结点`*p`的指针域指向 $a_i$ 的直接后继结点。
> 4. 释放结点 $a_i$ 的空间。

```C++{.line-numbers}
// 在带头结点的单链表 L 中，删除第 i 个元素
Status ListDelete(LinkList &L, int i)
{
    LNode *p = L;
    int j = 0;
    
    // 查找第 i-1 个结点，p 指向该结点
    while (p->next && j < i - 1)
    {
        p = p->next;
        j++;
    }
    if (!(p->next) || j > i - 1) return ERROR;
    
    q = p->next; // 临时保存被删结点的地址以备释放
    p->next = q->next;
    delete q; // 释放删除结点的空间
    return OK;
}
```

注意：删除算法中的循环条件（`p->next && j < i - 1`）和插入算法中的循环条件（`p && j < i - 1`）有所区别。因为插入操作中合法的插入位置有 $n+1$ 个，而删除操作中合法的删除位置只有 $n$ 个，如果使用与插入操作相同的循环条件，则会出现引用空指针的情况，使删除操作失败。

删除算法的时间复杂度类似于插入算法，也是 $O(n)$。

#### 2.5.2.6 创建单链表

建立线性表的链式存储结构的过程就是一个动态生成链表的过程，即从空表的初始状态起，依次建立各元素结点，并逐个插入链表。

根据结点插入位置的不同，链表的创建方法可分为前插法和后插法。

前插法是通过将新结点逐个插入链表的头部（头结点之后）来创建链表。

> **算法2.11** 前插法创建单链表
>
> 1. 创建一个只有头结点的空链表。
> 2. 根据待创建链表包括的元素个数 $n$，循环 $n$ 此执行以下操作：
>    （1）生成一个新结点`*p`。
>    （2）输入元素值赋给新结点`*p`的数据域。
>    （3）将新结点`*p`插入到头结点之后。

```C++{.line-numbers}
void CreateList_H(LinkList &L, int n)
{
    L = new LNode;
    L->next = NULL; // 建立一个带头结点的空链表
    
    for (int i = 0; i < n; i++)
    {
        // 生成新结点 *p
        LNode *p = new LNode;

        // 输入元素值赋给新结点 *p 的数据域
        cin >> p->data;

        // 将新结点插入到头结点之后
        p->next = L->next;
        L->next = p;
    }
}
```

后插法是通过将新结点逐个插入到链表的尾部来创建链表。为了使新结点能够插入到表尾，需要增加一个尾指针`r`指向链表的尾结点。

> **算法2.12** 后插法创建单链表
>
> 1. 创建一个只有头结点的空链表。
> 2. 尾指针`r`初始化，指向头结点。
> 3. 根据待创建链表包括的元素个数 $n$，循环 $n$ 此执行以下操作：
>    （1）生成一个新结点`*p`。
>    （2）输入元素值赋给新结点`*p`的数据域。
>    （3）将新结点`*p`插入到尾结点`*r`之后。
>    （4）尾指针`r`指向新的尾结点`*p`。

```C++{.line-numbers}
void CreateList_R(LinkList &L, int n)
{
    L = new LNode;
    L->next = NULL; // 建立一个带头结点的空链表
    LNode *r = L; // 尾指针 r 指向头结点
    
    for (int i = 0; i < n; i++)
    {
        // 生成新结点 *p
        LNode *p = new LNode;

        // 输入元素值赋给新结点 *p 的数据域
        cin >> p->data;

        // 将新结点插入到尾结点之后
        p->next = L->next;
        r->next = p;

        // r 指向新的尾结点 *p
        r = p;
    }
}
```

这两个算法的时间复杂度为 $O(n)$。

### 2.5.3 循环链表

**循环链表**（Circular Linked List）是另一种形式的链式存储结构。其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。由此，从表中任一结点出发均可找到表中其他结点。

循环单链表的操作和单链表基本一致，差别仅在于：当链表遍历时，判别当前指针`p`是否指向表尾结点的终止条件不同。在单链表中，判别条件为`p != NULL`或`p->next != NULL`，而循环单链表的判别条件为`p != L`或`p->next != L`。

在某些情况下，若在循环链表中设立尾指针而不设头指针，可使一些操作简化。例如，将两个线性表合并成一个表时，仅需将第一个表的尾指针指向第二个表的第一个结点， 第二个表的尾指针指向第一个表的头结点， 然后释放第二个表的头结点。假设`A`和`B`分别是两个循环链表的尾指针，则合并操作的主要语句如下：

```C
p = B->next->next; // p 指向 B 链表的首元结点
B->next = A->next; // B 链表的尾指针指向 A 链表的头结点
A->next = p; // A 链表的尾指针指向 B 链表的首元结点
```

### 2.5.4 双向链表

单链表的结点中只有一个指示直接后继的指针域，由此，从某个结点出发只能顺指针向后寻查其他结点。若要寻查结点的直接前驱，则必须从表头指针出发。换句话说，在单链表中，查找直接后继结点的执行时间为 $O(1)$，而查找直接前驱的执行时间为 $O(n)$。为克服单链表这种单向性的缺点，可以使用**双向链表**（Double Linked List）。

在双向链表的结点中有两个指针域，一个指向直接后继，另一个指向直接前驱。双向链表的结点结构在 C 语言中可以描述如下：

```C{.line-numbers}
typedef struct DuLNode
{
    ElemType data; // 数据域
    struct DuLNode *prior; // 直接前驱
    struct DuLNode *next; // 直接后继
} DuLNode, *DuLinkList;
```

和单链的循环表类似， 双向链表也可以有循环表。

在双向链表中，取值和查找操作仅需涉及一个方向的指针，则它们的算法描述和单链表的操作相同。但是在插入、删除时，需要同时修改两个方向上的指针，此时的操作与单链表不同。

> **算法2.13** 双向链表的插入

```C++{.line-numbers}
// 在带头结点的双向链表 L 中第 i 个位置之前插入元素 e
Status ListInsert_DuL(DuLinkList &L, int i, ElemType e)
{
    if (!(p = GetElem_DuL(L, i))) // 在 L 中确定第 i 个元素的位置指针 p
    {
        return ERROR;
    }
    DuLNode *s = new DuLNode; // 生成新结点 *s
    s->data = e; // 将结点 *s 数据域置为 e
    s->prior = p->prior; // s 的前驱是 p 的前驱
    p->prior->next = s; // p 的前驱的后继是 s
    s->next = p; // s 的后继是 p
    p->prior = s; // p 的前驱是 s
    return OK;
}
```

> **算法2.14** 双向链表的删除

```C++{.line-numbers}
// 删除带头结点的双向链表 L 中的第 i 个元素
Status ListDelete_DuL(DuLinkList &L, int i)
{
    if (!(p = GetElem_DuL(L, i))) // 在 L 中确定第 i 个元素的位置指针 p
    {
        return ERROR;
    }
    p->prior->next = p->next; // p 的前驱的后继是 p 的后继
    p->next->prior = p->prior; // p 的后继的前驱是 p 的前驱
    delete p;
    return OK;
}
```

这两个算法的时间复杂度均为 $O(n)$。

单链表、循环链表和双向链表的比较如图 2.1 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图2.1-单链表、循环链表和双向链表的比较.63z6i565ykw0.png">
    <br>
    图2.1 单链表、循环链表和双向链表的比较
</div>

## 2.6 顺序表和链表的比较

### 2.6.1 空间性能的比较

1. 存储空间的分配

顺序表的存储空间必须预先分配，元素个数扩充受一定限制，易造成存储空间浪费或空间溢出现象；而链表不需要为其预先分配空间，只要内存空间允许，链表中的元素个数就没有限制。

2. 存储密度的大小

**存储密度**是指数据元素本身所占用的存储量和整个结点结构所占用的存储量之比，即
$$
存储密度=\dfrac{数据元素本身占用的存储量}{结点结构占用的存储量}
$$

存储密度越大，存储空间的利用率就越高。顺序表的存储密度为 1，而链表的存储密度小于 1。如果每个元素数据域占据的空间较小，则指针的结构性开销就占用了整个结点的大部分空间，这样存储密度较小。

因此，当线性表的长度变化较大，难以预估存储规模时，宜采用链表作为存储结构；线性表的长度变化不大，易于事先确定其大小时，为了节约存储空间，宜采用顺序表作为存储结构。

### 2.6.2 时间性能的比较

1. 存取元素的效率：顺序表是由数组实现的，它是一种随机存取结构，指定任意一个位置序号`i`，都可以在 $O(1)$ 时间内直接存取该位置上的元素，即取值操作的效率高；而链表是一种顺序存储结构，按位置访问链表中第`i`个元素时，只能从表头开始依次向后遍历链表，直到找到第`i`个位置上的元素，时间复杂度为 $O(n)$，即取值操作的效率低。
2. 插入和删除操作的效率：对于链表，在确定插入或删除的位置后，插入或删除操作无需移动数据，只需要修改指针，时间复杂度为 $O(1)$；而对于顺序表，进行插入或删除时，平均要移动表中近一半的结点，时间复杂度为 $O(n)$。尤其是当每个结点的信息量较大时，移动结点的时间开销就相当可观。

因此，若线性表的主要操作是和元素位置紧密相关的这类取值操作，很少做插入或删除时，宜采用顺序表作为存储结构；对于频繁进行插入或删除操作的线性表，宜采用链表作为存储结构。

顺序表和链表的比较如图 2.2 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图2.2-顺序表与链表的比较.3hggm8u93ck0.png">
    <br>
    图2.2 顺序表与链表的比较
</div>

## 2.7 线性表的应用

### 2.7.1 线性表的合并

> **算法2.15** 线性表的合并
>
> 1. 分别获取`LA`表长 $m$ 和`LB`表长 $n$。
> 2. 从`LB`中第 1 个数据元素开始，循环 $n$ 次执行以下操作：
>    （1）从`LB`中查找第 $i$ 个数据元素赋给`e`；
>    （2）在`LA`中查找元素`e`，如果不存在，将`e`插在表`LA`的最后。

```C{.line-numbers}
// 将所有在线性表 LB 中但不在 LA 中的数据元素插入到 LA 中
void MergeList(List &LA, List LB)
{
    // 求线性表的长度
    int m = ListLength(LA);
    int n = ListLength(LB);
    
    for (int i = 1; i <= n; i++)
    {
        ElemType e;
        GetElem(LB, i, e); // 取 LB 中第 i 个数据元素赋给 e
        if (!LocateElem(LA, e)) // LA 中不存在和 e 相同的数据元素
        {
            m++; // LA 长度加 1
            ListInsert(LA, m, e); // 将 e 插在 LA 的最后
        }
    }
}
```

上述算法的时间复杂度取决于抽象数据类型`List`定义中基本操作的执行时间。假设`LA`和`LB`的表长分别为 $m$ 和 $n$，循环执行 $n$ 次，则：

1. 当采用顺序存储结构时，在每次循环中，`GetElem`和`ListInsert`这两个操作的执行时间和表长无关，`LocateElem`的执行时间和表长 $m$ 成正比。因此，算法 2.15 的时间复杂度为 $O(mn)$。
2. 当采用链式存储结构时，在每次循环中，`ListInsert`的执行时间和表长无关，`GetElem`的执行时间和表长 $n$ 成正比，`LocateElem`的执行时间和表长 $m$ 成正比。因此，若假设 $m>n$，算法 2.15 的时间复杂度也为 $O(mn)$。

### 2.7.2 有序表的合并

#### 2.7.2.1 顺序有序表的合并

若线性表中的数据元素相互之间可以比较，并且数据元素在线性表中依值非递减或非递增有序排列，则称该线性表为**有序表**（Ordered List）。

> **算法2.16** 顺序有序表的合并
>
> 1. 创建一个表长为 $m+n$ 的空表`LC`。
> 2. 指针`pc`初始化，指向`LC`的第一个元素。
> 3. 指针`pa`和`pb`初始化，分别指向`LA`和`LB`的第一个元素。
> 4. 当指针`pa`和`pb`均未到达相应表尾时，则依次比较`pa`和`pb`所指向的元素值，从`LA`或`LB`中摘取元素值较小的结点插入到`LC`的最后。
> 5. 如果`pb`已到达`LB`的表尾，依次将`LA`的剩余元素插入`LC`的最后。
> 6. 如果`pa`已到达`LA`的表尾，依次将`LB`的剩余元素插入`LC`的最后。

```C{.line-numbers}
// 已知顺序有序表 LA 和 LB 的元素按值非递减排列
// 合并 LA 和 LB 得到新的顺序有序表 LC，LC 的元素也按值非递减排列
void MergeList_Sq(SqList LA, SqList LB, SqList &LC)
{
    LC.length = LA.length + LB.length; // 新表长度为待合并两表的长度之和
    LC.elem = new ElemType[LC.length]; // 为合并后的新表分配一个数据空间
    ElemType *pc = LC.elem; // 指针 pc 指向新表的第一个元素
    ElemType *pa = LA.elem; // 指针 pa 指向 LA 的第一个元素
    ElemType *pb = LB.elem; // 指针 pb 指向 LB 的第一个元素
    
    ElemType *pa_last = LA.elem + LA.length - 1; // 指针 pa_last 指向 LA 的最后一个元素
    ElemType *pb_last = LB.elem + LB.length - 1; // 指针 pb_last 指向 LB 的最后一个元素
    
    // LA 和 LB 均未到达表尾
    while (pa <= pa_last && pb <= pb_last)
    {
        if (*pa <= *pb) // 摘取两表中值较小的结点插入到 LC 的最后
        {
            *pc = *pa;
            pa++;
        }
        else
        {
            *pc = *pb;
            pb++;
        }
        pc++;
    }
    
    // LB 已到达表尾，依次将 LA 的剩余元素插入 LC 的最后
    while (pa <= pa_last)
    {
        *pc = *pa;
        pa++;
        pc++;
    }
    
    // LA 已到达表尾，依次将 LB 的剩余元素插入 LC 的最后
    while (pb <= pb_last)
    {
        *pc = *pb;
        pb++;
        pc++;
    }
}
```

在算法 2.16 中，由于 LA 和 LB 中元素依值非递减，则对 LB 中的每个元素，不需要在 LA 中从表头至表尾进行全程搜索。如果两个表长分别记为 $m$ 和 $n$，则算法 2.16 循环最多执行的总次数为 $m+n$，所以算法的时间复杂度为 $O(m+n)$。

此算法在合并时，需要开辟新的辅助空间，所以空间复杂度也为 $O(m+n)$，空间复杂度较高。

#### 2.7.2.2 链式有序表的合并

> **算法2.17** 链式有序表的合并
>
> 1. 指针`pa`和`pb`初始化，分别指向`LA`和`LB`的第一个结点。
> 2. `LC`的结点取值为`LA`的头结点。
> 3. 指针`pc`初始化，指向`LC`的头结点。
> 4. 当指针`pa`和`pb`均未到达相应表尾时，则依次比较`pa`和`pb`所指向的元素值，从`LA`或`LB`中摘取元素值较小的结点插入到`LC`的最后。
> 5. 将非空表的剩余段插入到`pc`所指结点之后。
> 6. 释放`LB`的头结点。

```C++{.line-numbers}
// 已知单链表 LA 和 LB 的元素按值非递减排列
// 合并 LA 和 LB 得到新的单链表 LC，LC 的元素也按值非递减排列
void MergeList_L(LinkList &LA, LinkList &LB, LinkList &LC)
{
    // pa 和 pb 的初值分别指向两个表的第一个结点
    LNode *pa = LA->next;
    LNode *pb = LB->next;
    
    LNode *pc = LC; // pc 的初值指向 LC 的头结点
    
    // LA 和 LB 均未到达表尾，依次摘取两表中值较小的结点插入到 LC 的最后
    while (pa && pb)
    {
        if (pa->data <= pb->data) // 摘取 pa 所指结点
        {
            pc->next = pa;
            pc = pa;
            pa = pa->next;
        }
        else // 摘取 pb 所指结点
        {
            pc->next = pb;
            pc = pb;
            pb = pb->next
        }
    }
    
    pc->next = pa ? pa : pb; // 将非空表的剩余段插入到 pc 所指结点之后
    delete LB; // 释放 LB 的头结点
}
```

算法 2.17 的时间复杂度和算法 2.16 相同，但空间复杂度不同。在合并链表时，不需要另建新表的结点空间，而只需将原来两个链表中结点之间的关系解除，重新按元素值非递减的关系将所有结点链接成一个链表即可，所以空间复杂度为 $O(1)$。

## 2.8 案例分析与实现

### 2.8.1 一元多项式的运算

可以采用数组来表示一元多项式。数组`p`中每个分量`p[i]`表示多项式每项的系数 $p_i$，数组分量的下标`i`对应每项的指数。

用数组表示一元多项式时，多项式相加的算法为：把两个数组对应的分量项相加。

### 2.8.2 稀疏多项式的运算

用链表表示多项式时，每个链表结点存储多项式中的一个非零项，包括系数和指数两个数据域以及一个指针域。对应的数据结构定义为：

```C{.line-numbers}
typedef struct PNode
{
    float coef; // 系数
    int expn; // 指数
    struct PNode *next; // 指针域
} PNode, *Polynomial;
```

一个多项式可以表示成由这些结点链接起来的单链表。

#### 2.8.2.1 多项式的创建

> **算法2.18** 多项式的创建
>
> 1. 创建一个只有头结点的空链表。
> 2. 根据多项式的项的个数 $n$，循环 $n$ 次执行以下操作：
>    （1）生成一个新结点`*s`。
>    （2）输入多项式当前项的系数和指数赋给新结点`*s`的数据域。
>    （3）设置一前驱指针`pre`，用于指向待找到的第一个大于输入项指数的结点的前驱。`pre`初值指向头结点。
>    （4）指针`q`初始化，指向首元结点。
>    （5）循链向下逐个比较链表中当前结点与输入项指数，找到第一个大于输入项指数的结点`*q`。
>    （6）将输入项结点`*s`插入到结点`*q`之前。

```C++{.line-numbers}
// 输入 n 项的系数和指数，建立表示多项式的有序链表 P
void CreatePolyn(Polynomial &P, int n)
{
    // 建立一个带头结点的单链表
    P = new PNode;
    P->next = NULL;
    
    // 依次输入 n 个非零项
    for (int i = 1; i <= n; i++)
    {
        PNode *s = new PNode; // 生成新结点
        cin >> s->coef >> s->expn; // 输入系数和指数

        PNode *pre = P; // pre 用于保存 q 的前驱，初值为头结点
        PNode *q = P->next; // q 初始化，指向首元结点
        
        // 通过比较指数找到第一个大于输入项指数的项 *q
        while (q && q->expn < s->expn)
        {
            pre = q;
            q = q->next;
        }
        
        // 将输入项 s 插入到 q 和 pre 之间
        s->next = q;
        pre->next = s;
    }
}
```

创建一个项数为 $n$ 的有序多项式链表，需要执行 $n$ 次循环逐个输入各项，而每次循环又都需要从前向后比较输入项与各项的指数。在最坏情况下，第 $n$ 次循环需要做 $n$ 次比较，因此，时间复杂度为 $O(n^2)$。

#### 2.8.2.2 多项式的相加

> **算法2.19** 多项式的相加
>
> 1. 指针`p1`和`p2`初始化，分别指向`Pa`和`Pb`的首元结点。
> 2. `p3`指向和多项式的当前结点，初值为`Pa`的头结点。
> 3. 当指针`p1`和`p2`均未到达相应表尾时，则循环比较`p1`和`p2`所指结点对应的指数值，有 3 种情况：
>    （1）当`p1->expn == p2->expn`时，将两个结点中的系数相加。若和不为零，则修改`p1`所指结点的系数值，同时删除`p2`所指结点；若和为零，则删除`p1`和`p2`所指结点。
>    （2）当`p1->expn < p2->expn`时，摘取`p1`所指结点插入到和多项式链表中去。
>    （3）当`p1->expn > p2->expn`时，摘取`p2`所指结点插入到和多项式链表中去。
> 4. 将非空多项式的剩余段插入到`p3`所指结点之后。
> 5. 释放`Pb`的头结点。

```C++{.line-numbers}
// 多项式加法：Pa=Pa+Pb，利用两个多项式的结点构成和多项式
void AddPolyn(Polynomial &Pa, Polynomial &Pb)
{
    PNode *p1 = Pa->next; // p1 初值指向 Pa 的首元结点
    PNode *p2 = Pb->bext; // p2 初值指向 Pb 的首元结点
    PNode *p3 = Pa; // p3 指向和多项式的当前结点，初值为 Pa
    
    while (p1 && p2)
    {
        if (p1->expn == p2->expn) // 指数相等
        {
            sum = p1->coef + p2->coef; // sum 保存两项的系数和
            if (sum != 0) // 系数和不为 0
            {
                p1->coef = sum; // 将 Pa 当前结点的系数值修改为系数和
                p3->next = p1; // 将修改后的 Pa 当前结点链在 p3 之后
                p3 = p1; // p3 向后移动
                p1 = p1->next; // p1 向后移动
                // 删除 Pb 当前结点
                PNode *r = p2;
                p2 = p2->next;
                delete r;
            }
            else // 系数和为 0
            {
                // 删除 Pa 当前结点
                PNode *r = p1;
                p1 = p1->next;
                delete r;
                // 删除 Pb 当前结点
                r = p2;
                p2 = p2->next;
                delete r;
            }
        }
        else if (p1->expn < p2->expn) // Pa 当前结点的指数值小
        {
            p3->next = p1; // 将 p1 链在 p3 之后
            p3 = p1; // p3 向后移动
            p1 = p1->next; // p1 向后移动
        }
        else // Pb 当前结点的指数值小
        {
            p3->next = p2; // 将 p2 链在 p3 之后
            p3 = p2; // p3 向后移动
            p2 = p2->next; // p2 向后移动
        }
    }
    
    p3->next = p1 ? p1 : p2; // 插入非空多项式的剩余段
    delete Pb; // 释放 Pb 的头结点
}
```

假设两个多项式的项数分别为 $m$ 和 $n$，该算法的时间复杂度为 $O(m+n)$，空间复杂度为 $O(1)$。

一元多项式的减法和乘法运算可以利用多项式加法的算法来实现。对于减法运算，只需要对要减的多项式的每项系数进行取反，然后再调用加法运算`AddPolyn`即可。

多项式的乘法运算可以分解为一系列的加法运算。假设 $A(x)$ 和 $B(x)$ 为多项式，则
$$
\begin{equation*}
\begin{split}
    M(x)&=A(x)B(x)\\
    &=A(x)\times(b_1x^{e_1}+b_2x^{e_2}+\cdots+b_nx^{e_n})\\
    &=\sum_{i=1}^n b_iA(x)x^{e_i}
\end{split}
\end{equation*}
$$

# 第3章 栈和队列

## 3.1 栈和队列的定义和特点

### 3.1.1 栈的定义和特点

**栈**（stack）是限定仅在表尾进行插入或删除操作的线性表。栈的表尾端称为**栈顶**（top），表头端称为**栈底**（bottom）。不含元素的空表称为**空栈**。

假设栈 $S=(a_1,a_2,\cdots,a_n)$，则称 $a_1$ 为栈底元素，$a_n$ 为栈顶元素。栈中元素按 $a_1,a_2,\cdots,a_n$ 的次序进栈，退栈的第一个元素应为栈顶元素。栈的修改是按后进先出的原则进行的，因此，栈又称为**后进先出**（Last In First Out，LIFO）的线性表。

### 3.1.2 队列的定义和特点

**队列**（queue）是一种**先进先出**（First In First Out，FIFO）的线性表。它只允许在表的一端进行插入，在另一端删除元素。在队列中，允许插入的一端称为**队尾**（rear），允许删除的一端称为**队头**（front）。

假设队列为 $q=(a_1,a_2,\cdots,a_n)$，则 $a_1$ 为队头元素，$a_n$ 为队尾元素。队列中的元素按照 $a_1,a_2,\cdots,a_n$ 的次序入队，退出队列也只能按照这个次序依次退出。

## 3.2 案例引入

## 3.3 栈的表示和操作的实现

### 3.3.1 栈的类型定义

栈的抽象数据类型定义：

$$
\begin{aligned}
    &\texttt{ADT Stack \{}\\
    &\texttt{\quad 数据对象：$D=\{a_i\,|\,a_i\in \text{ElemSet},\,i=1,2,\cdots,n,\,n\geqslant0\}$}\\
    &\texttt{\quad 数据关系：$R=\{\textrm{<}a_{i-1},a_i\textrm{>}|\,a_{i-1},a_i\in D,\,i=2,\cdots,n\}$}\\
    &\texttt{\qquad\qquad\qquad 约定\,$a_n$\,为栈顶，$a_1$\,为栈底}\\
    &\texttt{\quad 基本操作：}\\
    &\texttt{\qquad InitStack(\&S)}\\
    &\texttt{\qquad\quad 操作结果：构造一个空栈\,S}\\
    &\texttt{\qquad DestroyStack(\&S)}\\
    &\texttt{\qquad\quad 初始条件：栈\,S\,已存在}\\
    &\texttt{\qquad\quad 操作结果：栈\,S\,被销毁}\\
    &\texttt{\qquad ClearStack(\&S)}\\
    &\texttt{\qquad\quad 初始条件：栈\,S\,已存在}\\
    &\texttt{\qquad\quad 操作结果：将\,S\,清空}\\
    &\texttt{\qquad StackEmpty(S)}\\
    &\texttt{\qquad\quad 初始条件：栈\,S\,已存在}\\
    &\texttt{\qquad\quad 操作结果：若栈\,S\,为空栈，则返回\,true，否则返回\,false}\\
    &\texttt{\qquad StackLength(S)}\\
    &\texttt{\qquad\quad 初始条件：栈\,S\,已存在}\\
    &\texttt{\qquad\quad 操作结果：返回\,S\,的元素个数，即栈的长度}\\
    &\texttt{\qquad GetTop(S)}\\
    &\texttt{\qquad\quad 初始条件：栈\,S\,已存在且非空}\\
    &\texttt{\qquad\quad 操作结果：返回\,S\,的栈顶元素，不修改栈顶指针}\\
    &\texttt{\qquad Push(\&S, e)}\\
    &\texttt{\qquad\quad 初始条件：栈\,S\,已存在}\\
    &\texttt{\qquad\quad 操作结果：插入元素\,e\,为新的栈顶元素}\\
    &\texttt{\qquad Pop(\&S, \&e)}\\
    &\texttt{\qquad\quad 初始条件：栈\,S\,已存在且非空}\\
    &\texttt{\qquad\quad 操作结果：删除\,S\,的栈顶元素，并用\,e\,返回其值}\\
    &\texttt{\qquad StackTraverse(S)}\\
    &\texttt{\qquad\quad 初始条件：栈\,S\,已存在且非空}\\
    &\texttt{\qquad\quad 操作结果：从栈底到栈顶依次对\,S\,的每个数据元素进行访问}\\
    &\texttt{\} ADT Stack}
\end{aligned}
$$

和线性表类似，栈也有两种存储表示方法，分别称为顺序栈和链栈。

### 3.3.2 顺序栈的表示和实现

顺序栈的定义如下：

```C{.line-numbers}
#define MAXSIZE 100 // 顺序栈存储空间的初始分配量

typedef struct
{
    SElemType *base; // 栈底指针
    SElemType *top; // 栈顶指针
    int stacksize; // 栈可用的最大容量
} SqStack;
```

`base`为栈底指针，初始化完成后，`base`始终指向栈底的位置。若`base`的值为`NULL`，则表明栈结构不存在。`top`为栈顶指针，其初值指向栈底。每当插入新的栈顶元素时，指针`top`增 1；删除栈顶元素时，指针`top`减 1。因此，栈空时，`top`和`base`的值相等，都指向栈底；栈非空时，`top`始终指向栈顶元素的上一个位置。

> **算法3.1** 顺序栈的初始化
>
> 1. 为顺序栈动态分配一个最大容量为`MAXSIZE`的数组空间，使`base`指向这段空间的基地址，即栈底。
> 2. 栈顶指针`top`初始化为`base`，表示栈为空。
> 3. `stacksize`置为栈的最大容量`MAXSIZE`。

```C++{.line-numbers}
// 构造一个空栈 S
Status InitStack(SqStack &S)
{
    S.base = new SElemType[MAXSIZE]; // 为顺序栈动态分配一个最大容量为 MAXSIZE 的数组空间
    if (!S.base) exit(OVERFLOW); // 存储分配失败
    
    S.top = S.base; // top 初始为 base，空栈
    S.stacksize = MAXSIZE; // stacksize 置为栈的最大容量 MAXSIZE
    return OK;
}
```

> **算法3.2** 顺序栈的入栈
>
> 1. 判断栈是否满，若满则返回`ERROR`。
> 2. 将新元素压入栈顶，栈顶指针加 1。

```C{.line-numbers}
// 插入元素 e 为新的栈顶元素
Status Push(SqStack &S, SElemType e)
{
    if (S.top - S.base == S.stacksize) // 栈满
        return ERROR;
    *S.top = e; // 元素 e 压入栈顶
    S.top++; // 栈顶指针加 1
    return OK;
}
```

> **算法3.3** 顺序栈的出栈
>
> 1. 判断栈是否空，若空则返回`ERROR`。
> 2. 栈顶指针减 1，栈顶元素出栈。

```C{.line-numbers}
// 删除 S 的栈顶元素，用 e 返回其值
Status Pop(SqStack &S, SElemType &e)
{
    if (S.top == S.base) // 栈空
        return ERROR;
    S.top--; // 栈顶指针减 1
    e = *S.top; // 将栈顶元素赋给 e
    return
}
```

> **算法3.4** 取顺序栈的栈顶元素

```C{.line-numbers}
// 返回 S 的栈顶元素，不修改栈顶指针
SElemType GetTop(SqStack S)
{
    if (S.top != S.base) // 栈非空
        return *(S.top - 1); // 返回栈顶元素的值
}
```

### 3.3.3 链栈的表示和实现

链栈是指采用链式存储结构实现的栈。通常链栈用单链表来表示。链栈的结点结构与与单链表的结构相同，在此用`StackNode`表示，定义如下：

```C{.line-numbers}
typedef struct StackNode
{
    SElemType data;
    struct StackNode *next;
} StackNode, *LinkStack;
```

由于栈的主要操作是在栈顶插入和删除，因此以链表的头部作为栈顶是最方便的，而且不必要附加头结点。

> **算法3.5** 链栈的初始化

```C{.line-numbers}
// 构造一个空栈 S，栈顶指针置空
Status InitStack(LinkStack &S)
{
    S = NULL;
    return OK;
}
```

> **算法3.6** 链栈的入栈
>
> 1. 为入栈元素`e`分配空间，用指针`p`指向。
> 2. 将新结点数据域置为`e`。
> 3. 将新结点插入栈顶。
> 4. 修改栈顶指针为`p`。

```C++{.line-numbers}
// 在栈顶插入元素 e
Status Push(LinkStack &S, SElemType e)
{
    StackNode *p = new StackNode; // 生成新结点
    p->data = e; // 将新结点数据域置为 e
    p->next = S; // 将新结点插入栈顶
    S = p; // 栈顶指针修改为 p
    return OK;
}
```

> **算法3.7** 链栈的出栈
>
> 1. 判断栈是否为空，若空则返回`ERROR`。
> 2. 将栈顶元素赋给`e`。
> 3. 临时保存栈顶元素的空间，以备释放。
> 4. 修改栈顶指针，指向新的栈顶元素。
> 5. 释放原栈顶元素的空间。

```C++{.line-numbers}
// 删除 S 的栈顶元素，用 e 返回其值
Status Pop(LinkStack &S, SElemType &e)
{
    if (S == NULL) return ERROR; // 栈空
    e = S->data; // 将栈顶元素赋给 e
    StackNode *p = S; // 用 p 临时保存栈顶元素空间，以备释放
    S = S->next; // 修改栈顶指针
    delete p; // 释放原栈顶元素的空间
    return OK;
}
```

> **算法3.8** 取链栈的栈顶元素

```C{.line-numbers}
SElemType GetTop(LinkStack S)
{
    if (S != NULL) // 栈非空
        return S->data; // 返回栈顶元素的值
}
```

## 3.4 栈与递归

### 3.4.1 采用递归算法解决的问题

所谓递归是指，若在一个函数、过程或者数据结构定义的内部又直接（或间接）出现定义本身的应用，则称它们是递归的，或者是递归定义的。在以下三种情况下，常常使用递归的方法。

#### 3.4.1.1 定义是递归的

例如，阶乘函数是递归定义的：
$$
\text{Fact}(n)=\begin{cases}
    1 &n=0\\
    n\times\text{Fact}(n-1) &n>0
\end{cases}
$$

可以使用递归过程来求解阶乘函数。

```C{.line-numbers}
long Fact(long n)
{
    if (n == 0) // 递归终止条件
        return 1;
    else // 递归步骤
        return n * Fact(n - 1);
}
```

又如，二阶 Fibonacci 数列也是递归定义的：
$$
\text{Fib}(n)=\begin{cases}
    1 &n=1\,或\,n=2\\
    \text{Fib}(n-1)+\text{Fib}(n-2) &其他
\end{cases}
$$

Fibonacci 数列的递归程序如下：

```C{.line-numbers}
long Fib(long n)
{
    if (n == 1 || n == 2) // 递归终止条件
        return 1;
    else // 递归步骤
        return Fib(n - 1) + Fib(n - 2);
}
```

对于这类复杂问题，如果能够分解成几个相对简单且解法相同或类似的子问题来求解，便称作递归求解。这种分解-求解的策略叫做 “分治法”。

采取 “分治法” 进行递归求解的问题需要满足一下三个条件：

1. 能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，并且这些处理对象更小且变化有规律。
2. 可以通过上述转化而是问题简化。
3. 必须有一个明确的递归出口，或称递归的边界。

“分治法” 求解递归问题算法的一般形式为：

```C
void p(参数表)
{
    if (递归结束条件成立) // 递归终止条件
        可直接求解;
    else // 递归步骤
        p(较小的参数);
}
```

#### 3.4.1.2 数据结构是递归的

某些数据结构本身具有递归的特性，则它们的操作可以递归地描述。例如，对于链表，其结点`LNode`的定义由数据域`data`和指针域`next`组成，而指针域是一种指向`LNode`类型的指针，即`LNode`的定义中又用到了其自身，所以链表是一种递归的数据结构。

对于递归的数据结构，相应算法采用递归的方法来实现特别方便。例如，遍历链表结点的递归算法如下：

> **算法3.9** 遍历链表结点的递归算法
>
> 1. 如果`p`为`NULL`，递归结束返回。
> 2. 否则输出`p->data`，`p`指向后继结点继续递归。

```C++{.line-numbers}
void TraverseList(LinkList p)
{
    if (p == NULL) // 递归终止
        return;
    else
    {
        cout << p->data << endl;
        TraverseList(p->next); // p 指向后继结点继续递归
    }
}
```

在递归算法中，如果当递归结束条件成立，只执行`return`操作时，“分治法” 求解递归问题算法的一般形式可以简化为：

```C
void p(参数表)
{
    if (递归结束条件不成立)
        p(较小的参数);
}
```

因此，算法 3.9 可以简化为：

```C++{.line-numbers}
void TraverseList(LinkList p)
{
    if (p)
    {
        cout << p->data << endl;
        TraverseList(p->next);
    }
}
```

#### 3.4.1.3 问题的解法是递归的

**【例3.1】** n 阶 Hanoi 塔问题

假设有 3 个分别命名为 A、B 和 C 的塔座，在塔座 A 上插有 $n$ 个直径大小各不相同，从小到大编号为 $1,2,\cdots,n$ 的圆盘（如图 3.1 所示）。要求将塔座 A 上的 $n$ 个圆盘移动到塔座 C 上，并仍按同样顺序叠排。圆盘移动时必须遵循下列规则：

1. 每次只能移动一个圆盘。
2. 圆盘可以插在 A、B 和 C 中的任一塔座上。
3. 任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图3.1-Hanoi塔问题.2bgubikxiysk.png">
    <br>
    图3.1 Hanoi塔问题
</div>

**解：** 设 A 柱上最初的圆盘总数为 $n$，则当 $n=1$ 时，只要将编号为 1 的圆盘从塔座 A 直接移至塔座 C 上即可；否则，执行以下三步：

1. 用 C 柱做过渡，将 A 柱上的 $n-1$ 个圆盘移到 B 柱上；
2. 将 A 柱上最后一个圆盘直接移到 C 柱上；
3. 用 A 柱做过渡，将 B 柱上的 $n-1$ 个圆盘移到 C 柱上。

具体移动过程如图 3.1 所示，图中 $n=4$。

根据这种解法，如何将 $n-1$ 个圆盘从一个塔座移至另一个塔座的问题是一个和原问题具有相同特征属性的问题，只是问题的规模小 1，因此可以用同样的方法求解。

> **算法3.10** Hanoi 塔问题的递归算法
>
> 1. 如果 $n=1$，则直接将编号为 1 的圆盘从 A 移到 C，递归结束。
> 2. 否则：
>    （1）递归，将 A 上编号为 1 至 $n-1$ 的圆盘移到 B，C 做辅助塔。
>    （2）直接将编号为 $n$ 的圆盘从 A 移到 C。
>    （3）递归，将 B 上编号为 1 至 $n-1$ 的圆盘移到 C，A 做辅助塔。
>
> 为了便于描述算法，将搬动操作定义为`move(A, n, C)`，是指将编号为 n 的圆盘从 A 移到 C。同时设置一个初值为 0 的全局变量`m`，对搬动进行计数。

```C++{.line-numbers}
int m = 0;

void move(char A, int n, char C)
{
    m++;
    cout << m << "," << n << "," << A << "," << C << endl;
}

// 将塔座 A 上的 n 个圆盘按规则搬到 C 上，B 做辅助塔
void Hanoi(int n, char A, char B, char C)
{
    if (n == 1)
    {
        move(A, 1, C); // 将编号为 1 的圆盘从 A 移到 C
    }
    else
    {
        Hanoi(n - 1, A, C, B); // 将 A 上编号为 1 至 n-1 的圆盘搬到 B 上，C 做辅助塔
        move(A, n, C); // 编号为 n 的圆盘从 A 移到 C
        Hanoi(n - 1, B, A, C); // 将 B 上编号为 1 至 n-1 的圆盘搬到 C 上，A 做辅助塔
    }
}
```

### 3.4.2 递归过程与递归工作栈

在高级语言编制的程序中，调用函数和被调用函数之间的链接及信息交换需要通过栈来进行。

当在一个函数的运行期间调用另一个函数时，在运行被调用函数之前，系统需先完成 3 件事：

1. 将所有的实参、返回地址等信息传递给被调用函数保存。
2. 为被调用函数的局部变量分配存储区。
3. 将控制转移到被调函数的入口。

从被调用函数返回调用函数之前，系统也应完成 3 件工作：

1. 保存被调用函数的计算结果。
2. 释放被调用函数的数据区。
3. 依照被调用函数保存的返回地址将控制转移到调用函数。

当有多个函数构成嵌套调用时，按照 “后调用先返回” 原则，上述函数之间的信息传递和控制转移必须通过栈来实现。系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就为它在栈顶分配一个存储区；每当从一个函数退出时，就释放它的存储区。当前正在运行的函数的数据区必在栈顶。

一个递归函数的运行过程类似于多个函数的嵌套调用，只是调用函数和被调用函数是同一个函数。假设调用该递归函数的主函数为第 0 层，则从主函数调用递归函数为进入第 1 层；从第 $i$ 层递归调用本函数为进入下一层，即第 $i+1$ 层；退出第 $i$ 层递归应返回至上一层，即第 $i$ 层。

为了保证递归函数正确执行，系统需设立一个**递归工作栈**作为整个递归函数运行期间使用的数据存储区。每一层递归所需信息构成一个**工作记录**，其中包括所有的实参、所有的局部变量，以及上一层的返回地址。每进入一层递归，就产生一个新的工作记录压入栈顶；每退出一层递归，就从栈顶弹出一个工作记录。当前执行层的工作记录必是递归工作栈栈顶的工作记录，称这个记录为**活动记录**。

### 3.4.3 递归算法的效率分析

#### 3.4.3.1 时间复杂度的分析

当一个算法中包含递归调用时，其时间复杂度的分析可以转化为一个递归方程求解。迭代法是求解递归方程的一种常用方法，其基本步骤是迭代地展开递归方程的右端，使之成为一个非递归的和式，然后通过对和式的估计来达到对方程左端的估计。

下面以阶乘函数`Fact(n)`为例，说明通过迭代法求解递归方程来计算时间复杂度的方法。

设`Fact(n)`的执行时间是 $T(n)$。此递归函数中语句`if (n == 0) return 1;`的执行时间是 $O(1)$，递归调用`Fact(n - 1)`的执行时间是 $T(n-1)$，所以`else return n * Fact(n - 1);`的执行时间是 $O(1)+T(n-1)$。其中，设两数相乘和赋值操作的执行时间为 $O(1)$，则对某常数 $C$、$D$ 有如下递归方程：
$$
T(n)=\begin{cases}
    D & n=0\\
    C+T(n-1) & n\geqslant 1
\end{cases}
$$

设 $n>2$，利用上式对 $T(n-1)$ 展开，即在上式中用 $n-1$ 代替 $n$ 得到
$$
T(n-1)=C+T(n-2)
$$

再代入 $T(n)=C+T(n-1)$ 中，有
$$
T(n)=2C+T(n-2)
$$

同理，当 $n>3$ 时有
$$
T(n)=3C+T(n-3)
$$

以此类推，当 $n>i$ 时有
$$
T(n)=iC+T(n-i)
$$

最后，当 $i=n$ 时有
$$
T(n)=nC+T(0)=Cn+D
$$

求得递归方程的解为：$T(n)=O(n)$。

采用这种方法计算 Fibonacci 数列和 Hanoi 塔问题递归算法的时间复杂度均为 $O(2^n)$。

#### 3.4.3.2 空间复杂度的分析

递归函数在执行时，系统需设立一个递归工作栈存储每一层递归所需的信息，此工作栈是递归函数执行的辅助空间。因此，分析递归算法的空间复杂度需要分析工作栈的大小。

对于递归算法，空间复杂度为
$$
S(n)=O(f(n))
$$

其中，$f(n)$ 为递归工作栈中工作记录的个数与问题规模 $n$ 的函数关系。

根据这种分析方法可得，阶乘函数、Fibonacci 数列、Hanoi 塔问题的递归算法的空间复杂度均为 $O(n)$。

### 3.4.4 利用栈将递归转换为非递归的方法

递归程序在执行时需要系统提供隐式栈来实现。对于一般的递归过程，仿照递归算法执行过程中递归工作栈的状态变化可直接写出相应的非递归算法。这种利用栈消除递归过程的步骤如下：

1. 设置一个工作栈存放递归工作记录（包括实参、返回地址及局部变量等）。
2. 进入非递归调用入口，将调用程序传来的实参和返回地址入栈。
3. 进入递归调用入口：当不满足递归结束条件时，逐层递归，将实参、返回地址即局部变量入栈。这一过程可用循环语句来实现——模拟递归分解的过程。
4. 递归结束条件满足，将达到递归出口的给定常数作为当前的函数值。
5. 返回处理：在栈不空的情况下，反复退出栈顶记录，根据记录中的返回地址进行题意规定的操作。即逐层计算当前函数值，直至栈空为止——模拟递归求值过程。

通过以上步骤，可将任何递归算法改写成非递归算法。但改写后的非递归算法和原来比较起来，结构不够清晰，可读性差，有的还需要经过一系列的优化。

## 3.5 队列的表示和操作的实现

### 3.5.1 队列的类型定义

$$
\begin{aligned}
    &\texttt{ADT Queue \{}\\
    &\texttt{\quad 数据对象：$D=\{a_i\,|\,a_i\in \text{ElemSet},\,i=1,2,\cdots,n,\,n\geqslant0\}$}\\
    &\texttt{\quad 数据关系：$R=\{\textrm{<}a_{i-1},a_i\textrm{>}|\,a_{i-1},a_i\in D,\,i=2,\cdots,n\}$}\\
    &\texttt{\qquad\qquad\qquad 约定\,$a_1$\,为队列头，$a_n$\,为队列尾}\\
    &\texttt{\quad 基本操作：}\\
    &\texttt{\qquad InitQueue(\&Q)}\\
    &\texttt{\qquad\quad 操作结果：构造一个空队列\,Q}\\
    &\texttt{\qquad DestroyQueue(\&Q)}\\
    &\texttt{\qquad\quad 初始条件：队列\,Q\,已存在}\\
    &\texttt{\qquad\quad 操作结果：队列\,Q\,被销毁}\\
    &\texttt{\qquad ClearQueue(\&Q)}\\
    &\texttt{\qquad\quad 初始条件：队列\,Q\,已存在}\\
    &\texttt{\qquad\quad 操作结果：将\,Q\,清空}\\
    &\texttt{\qquad QueueEmpty(Q)}\\
    &\texttt{\qquad\quad 初始条件：队列\,Q\,已存在}\\
    &\texttt{\qquad\quad 操作结果：若\,Q\,为空栈，则返回\,true，否则返回\,false}\\
    &\texttt{\qquad QueueLength(Q)}\\
    &\texttt{\qquad\quad 初始条件：队列\,Q\,已存在}\\
    &\texttt{\qquad\quad 操作结果：返回\,Q\,的元素个数，即队列的长度}\\
    &\texttt{\qquad GetHead(Q)}\\
    &\texttt{\qquad\quad 初始条件：队列\,Q\,已存在且非空}\\
    &\texttt{\qquad\quad 操作结果：返回\,Q\,的队头元素}\\
    &\texttt{\qquad EnQueue(\&Q, e)}\\
    &\texttt{\qquad\quad 初始条件：队列\,Q\,已存在}\\
    &\texttt{\qquad\quad 操作结果：插入元素\,e\,为新的队尾元素}\\
    &\texttt{\qquad DeQueue(\&Q, \&e)}\\
    &\texttt{\qquad\quad 初始条件：队列\,Q\,已存在且非空}\\
    &\texttt{\qquad\quad 操作结果：删除\,Q\,的队头元素，并用\,e\,返回其值}\\
    &\texttt{\qquad QueueTraverse(Q)}\\
    &\texttt{\qquad\quad 初始条件：队列\,Q\,已存在且非空}\\
    &\texttt{\qquad\quad 操作结果：从队头到队尾依次对\,Q\,的每个数据元素进行访问}\\
    &\texttt{\} ADT Queue}
\end{aligned}
$$

### 3.5.2 循环队列——队列的顺序表示和实现

队列的顺序存储结构表示如下：

```C{.line-numbers}
#define MAXQSIZE 100 // 队列可能达到的最大长度

typedef struct
{
    QElemType *base; // 存储空间的基地址
    int front; // 头指针
    int rear; // 尾指针
} SqQueue;
```

为了在 C 语言中描述方便起见，在此约定：初始化创建空队列时，令`front = rear = 0`；每当插入新的队尾元素时，尾指针`rear`增 1；每当删除队头元素时，头指针`front`增 1。因此，在非空队列中，头指针始终指向队头元素，尾指针始终指向队尾元素的下一个位置，如图 3.2 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图3.2-顺序分配的队列中头、尾指针和元素之间的关系.1pm44tbltc00.png">
    <br>
    图3.2 顺序分配的队列中头、尾指针和元素之间的关系
</div>

当队列处于图 3.2(d) 所示的状态时不可再继续插入新的队尾元素，否则会出现溢出现象。事实上，此时队列的实际可用空间并未占满，所以这种现象称为 “假溢出”。这是由 “队尾入队，队头出队” 这种受限制的操作造成的。

解决 “假溢出” 问题的办法是将顺序队列变为一个环状的空间，称之为**循环队列**，如图 3.3 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图3.3-循环队列.4rcsaqpyjx40.png">
    <br>
    图3.3 循环队列
</div>

头、尾指针以及队列元素之间的关系不变，只是在循环队列中，头、尾指针 “依环状增 1” 的操作可用模运算来实现。通过取模，头指针和尾指针就可以在顺序表空间内以头尾衔接的方式循环移动。

对于循环队列，不能以头、尾指针的值是否相同来判别队列空间是满还是空。如图 3.4 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图3.4-循环队列中头、尾指针和元素之间的关系.6lydueg0tuo0.png">
    <br>
    图3.4 循环队列中头、尾指针和元素之间的关系
</div>

在图 3.4(b) 中，队列空间被占满，此时头、尾指针相同。在图 3.4(c) 中，队列为空，此时头、尾指针也是相同的。因此，不能以头、尾指针的值是否相同来判别循环队列是满还是空。

判断循环队列是满还是空的方法有两种：

1. 少用一个元素空间，即队列空间大小为 $m$ 时，有 $m-1$ 个元素就认为是队满，如图 3.4(d) 所示。此时判断队空的条件为`Q.front == Q.rear`，判断队满的条件为`(Q.rear + 1) % MAXSIZE == Q.front`。
2. 另设一个标志位以区别队列是空还是满。

下面给出用第一种方法实现循环队列的操作。

> **算法3.11** 循环队列的初始化
>
> 1. 为队列分配数组空间，`base`指向数组空间的首地址。
> 2. 头指针和尾指针置为零，表示队列为空。

```C++{.line-numbers}
// 构造一个空队列
Status InitQueue(SqQueue &Q)
{
    Q.base = new QElemType[MAXSIZE]; // 为队列分配数组空间
    if (!Q.base) // 存储分配失败
        exit(OVERFLOW);
    
    Q.front = 0; // 头指针置为 0
    Q.rear = 0; // 尾指针置为 0
    return OK;
}
```

> **算法3.12** 求循环队列的长度

```C{.line-numbers}
int QueueLength(SqQueue Q)
{
    return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
}
```

> **算法3.13** 循环队列的入队
>
> 1. 判断队列是否满，若满则返回`ERROR`。
> 2. 将新元素插入队尾。
> 3. 尾指针加 1。

```C{.line-numbers}
// 将元素 e 插入 Q 的队尾
Status EnQueue(SqQueue &Q, QElemType e)
{
    if ((Q.rear + 1) % MAXSIZE == Q.front) // 队满
        return ERROR;
    
    Q.base[Q.rear] = e; // 将新元素插入队尾
    Q.rear = (Q.rear + 1) % MAXSIZE; // 尾指针加 1
    return OK;
}
```

> **算法3.14** 循环队列的出队
>
> 1. 判断队列是否为空，若为空则返回`ERROR`。
> 2. 保存队头元素。
> 3. 头指针加 1。

```C{.line-numbers}
// 删除 Q 的队头元素，用 e 返回其值
Status DeQueue(SqQueue &Q, QElemType &e)
{
    if (Q.front == Q.rear) // 队空
        return ERROR;
    
    e = Q.base[Q.front]; // 保存队头元素
    Q.front = (Q.front + 1) % MAXSIZE; // 头指针加 1
    return OK;
}
```

> **算法3.15** 取循环队列的队头元素

```C{.line-numbers}
// 返回 Q 的队头元素，不修改头指针
QElemType GetHead(SqQueue Q)
{
    if (Q.front != Q.rear) // 队列非空
        return Q.base[Q.front]; // 返回队头元素
}
```

### 3.5.3 链队——队列的链式表示和实现

链队是指采用链式存储结构实现的队列。通常链队用单链表来表示。

一个链队需要两个分别指示队头和队尾的指针才能唯一确定。为了操作方便起见，给链队添加一个头结点，并令头指针始终指向头结点。队列的链式存储结构表示如下：

```C{.line-numbers}
typedef struct QNode
{
    QElemType data;
    struct QNode *next;
} QNode, *QueuePtr;

typedef struct
{
    QueuePtr front; // 头指针
    QueuePtr rear; // 尾指针
} LinkQueue;
```

> **算法3.16** 链队的初始化
>
> 1. 生成新结点作为头结点，队头和队尾指针指向此结点。
> 2. 头结点的指针域置空。

```C++{.line-numbers}
// 构造一个空队列 Q
Status InitQueue(LinkQueue &Q)
{
    Q.front = new QNode; // 生成新结点作为头结点
    Q.rear = Q.front; // 队尾指针指向头结点
    Q.front->next = NULL; // 头结点的指针域置空
    return OK;
}
```

> **算法3.17** 链队的入队
>
> 1. 为入队元素分配结点空间，用指针`p`指向。
> 2. 将新结点数据域置为`e`。
> 3. 将新结点插入到队尾。
> 4. 修改队尾指针为`p`。

```C++{.line-numbers}
// 将元素 e 插入 Q 的队尾
Status EnQueue(LinkQueue &Q, QElemType e)
{
    QNode *p = new QNode; // 为入队元素分配结点空间
    p->data = e; // 设置新结点的数据域
    p->next = NULL; // 新结点的指针域设置为空
    Q.rear->next = p; // 将新结点插入到队尾
    Q.rear = p; // 修改队尾指针
    return OK;
}
```

> **算法3.18** 链队的出队
>
> 1. 判断队列是否为空，若空则返回`ERROR`。
> 2. 临时保存队头元素的空间，以备释放。
> 3. 修改队头指针，指向下一个结点。
> 4. 判断出队元素是否为最后一个元素，若是，则将队尾指针指向头结点。
> 5. 释放原队头元素的空间。

```C++{.line-numbers}
// 删除 Q 的队头元素，用 e 返回其值
Status DeQueue(LinkQueue &Q, QElemType &e)
{
    if (Q.front == Q.rear) // 若队列为空，则返回 ERROR
        return ERROR;
    
    QNode *p = Q.front->next; // p 指向队头元素
    e = p->data; // e 保存队头元素的值
    Q.front->next = p->next; // 修改头指针
    
    if (Q.rear == p) // 如果是最后一个元素，则将队尾指针指向头结点
        Q.rear = Q.front;
    delete p; // 释放原队头元素的空间
    return OK;
}
```

> **算法3.19** 取链队的队头元素

```C{.line-numbers}
// 返回 Q 的队头元素
QElemType GetHead(LinkQueue Q)
{
    if (Q.front != Q.rear) // 队列非空
        return Q.front->next->data; // 返回队头元素的值
}
```

## 3.6 案例分析与实现

### 3.6.1 数制转换

十进制数 $N$ 到其他 $d$ 进制数的转换算法基于下列原理：
$$
N=(N\space\text{div}\space d)\times d+N\bmod d
$$

其中，$\text{div}$ 为整除运算，$\bmod$ 为求余运算。

例如，$(1348)_{10}=(2504)_8$，计算过程如下：

| $N$  | $N\space\text{div}\space 8$ | $N\bmod 8$ |
| :--: | :-------------------------: | :--------: |
| 1348 |             168             |     4      |
| 168  |             21              |     0      |
|  21  |              2              |     5      |
|  2   |              0              |     2      |

上述计算过程是从低位到高位顺序产生 $d$ 进制数的各个数位，而输出过程应从高位到低位进行，恰好和计算过程相反，因此可以使用栈来解决这个问题。在计算过程中依次将得到的余数压入栈中，计算完毕后，再依次弹出栈中的余数并输出。

> **算法3.20** 数制的转换
>
> 1. 初始化一个空栈`S`。
> 2. 当十进制数 $N$ 非零时，循环执行以下操作：
>    （1）把 $N$ 与 $d$ 求余得到的余数压入栈`S`。
>    （2）$N$ 更新为 $N$ 与 $d$ 的商。
> 3. 当栈`S`非空时，循环执行以下操作：
>    （1）弹出栈顶元素`e`。
>    （2）输出`e`。

```C++{.line-numbers}
// 对于任意一个非负十进制整数，打印输出与其等值的 d 进制数
void conversion(int N, int d)
{
    InitStack(S); // 初始化空栈 S
    
    while (N != 0) // 当 N 非零时，循环
    {
        Push(S, N % d); // 把 N 与 d 求余得到的余数压入栈 S
        N = N / d; // N 更新为 N 与 d 的商
    }
    
    while (!StackEmpty(S)) // 当栈 S 非空时，循环
    {
        Pop(S, e); // 弹出栈顶元素 e
        cout << e; // 输出 e
    }
}
```

该算法的时间和空间复杂度均为 $O(\log_d N)$。

### 3.6.2 括号匹配的检验

假设表达式中允许包含两种括号：圆括号和方括号，其嵌套的顺序随意。检验括号是否匹配时，每当读入一个左括号，则直接入栈，等待相匹配的同类右括号；每当读入一个右括号，若与当前栈顶的左括号类型相同，则二者匹配，将栈顶的左括号出栈，直到表达式扫描完毕。

当读入右括号时，如果栈为空或栈顶的左括号与当前右括号类型不同，则匹配失败。如果表达式扫描结束时栈不为空，说明匹配失败。

> **算法3.21** 括号的匹配
>
> 1. 初始化一个空栈`S`。
> 2. 设置一个标记性变量`flag`，用来标记匹配结果以控制循环及返回结果，`true`表示正确匹配，`false`表示错误匹配。`flag`初值为`true`。
> 3. 扫描表达式，依次读入字符`ch`，如果表达式没有扫描完毕或`flag`非零，则循环执行以下操作：
>    - 若`ch`是左括号`[`或`(`，则将其压入栈。
>    - 若`ch`是右括号`)`，则根据当前栈顶元素的值分情况考虑：若栈非空且栈顶元素是`(`，则正确匹配；否则错误匹配，`flag`置为`false`。
>    - 若`ch`是右括号`]`，则根据当前栈顶元素的值分情况考虑：若栈非空且栈顶元素是`[`，则正确匹配；否则错误匹配，`flag`置为`false`。
> 4. 退出循环后，如果栈空且`flag`值为`true`，则匹配成功，返回`true`，否则返回`false`。

```C{.line-numbers}
// 检验表达式中所含括号是否正确匹配，如果匹配则返回 true，否则返回 false
// 表达式以 # 结束
Status Matching()
{
    InitStack(S); // 初始化空栈
    bool flag = true; // 设置标记变量
    
    char ch;
    cin >> ch; // 读入第一个字符
    while(ch != '#' && flag)
    {
        switch (ch)
        {
            case '[':
            case '(':
                Push(S, ch); // 若是左括号，则将其压入栈
                break;
            case ')':
                if (!StackEmpty(S) && GetTop(S) == '(')
                    Pop(S, x); // 若栈非空且栈顶元素是'('，则正确匹配
                else
                    flag = false; // 否则，错误匹配
                break;
            case ']':
                if (!StackEmpty(S) && GetTop(S) == '[')
                    Pop(S, x); // 若栈非空且栈顶元素是'['，则正确匹配
                else
                    flag = false; // 否则，错误匹配
                break;
        }
        cin >> ch;
    }
    
    if (StackEmpty(S) && flag) // 若栈为空且 flag 为 true，则匹配成功
        return true;
    else
        return false;
}
```

此算法从头到尾扫描表达式中每个字符，若表达式的字符串长度为 $n$，则此算法的时间复杂度为 $O(n)$。算法在运行时所占用的辅助空间主要取决于栈的大小，而栈的空间大小不会超过 $n$，所以此算法的空间复杂度为 $O(n)$。

### 3.6.3 表达式求值

任何一个表达式都是由操作数（operand）、运算符（operator）和界限符（delimiter）组成的，统称它们为单词。一般地，操作数既可以是常数，也可以是被说明为变量或常量的标识符；运算符可以分为算术运算符、关系运算符和逻辑运算符 3 类；基本界限符有左右括号和表达式结束符等。

这里仅讨论简单算数表达式的求值问题，这种表达式只含加、减、乘、除 4 种运算符。下面把运算符和界限符统称为算符。

算符优先法根据算术四则运算规则确定的运算优先关系，实现对表达式的编译或解释执行。在表达式计算中先出现的运算符不一定先运算，具体运算顺序需要通过运算符优先关系的比较，确定合适的运算时机，而运算时机的确定可以借助栈来完成。将扫描到的不能进行运算的运算数和运算符先分别压入运算数栈和运算符栈中，在满足条件时再分别从栈中弹出进行运算。

算术四则运算遵循以下 3 条规则：

1. 先乘除，后加减。
2. 从左到右。
3. 先括号内，后括号外。

根据上述 3 条运算规则，在运算的每一步中，任意两个相继出现的算符 $\theta_1$ 和 $\theta_2$ 之间的优先关系，至多是下面 3 种关系之一：

1. $\theta_1<\theta_2$，$\theta_1$ 的优先权低于 $\theta_2$。
2. $\theta_1=\theta_2$，$\theta_1$ 的优先权等于 $\theta_2$。
3. $\theta_1>\theta_2$，$\theta_1$ 的优先权高于 $\theta_2$。

表 3.1 定义了算符之间的这种优先关系。

![算符间的优先关系](https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/表3.1-算符间的优先关系.6j7iymcab8w0.png)

由规则 1，先乘除后加减，所以有 $“+”<“*”$、$“+”<“/”$、$“*”>“+”$、$“/”>“+”$ 等。

由规则 2，运算遵循左结合性，当两个运算符相同时，先出现的运算符优先级高，所以有 $“+”>“+”$、$“-”>“-”$、$“*”>“*”$、$“/”>“/”$。

由规则 3，括号内的优先级高，$+$、$-$、$*$ 和 $/$ 为 $\theta_1$ 时的优先级均低于 $($ 但高于 $)$。

表中的 $“(”=“)”$ 表示当左右括号相遇时，括号内的运算已经完成。为了便于实现，假设每个表达式均以 “#” 开始，以 “#” 结束，所以 $“\#”=“\#”$ 表示整个表达式求值完毕。$“)”$ 与 $“(”$、$“\#”$ 与 $“)”$ 以及 $“(”$ 与 $“\#”$ 之间无优先关系，这是因为表达式中不允许它们相继出现，一旦遇到这种情况，则可以认为出现了语法错误。

为实现算符优先算法，可以使用两个工作栈，一个称作`OPTR`，用以寄存运算符；另一个称作`OPND`，用以寄存操作数或运算结果。

> **算法3.22** 表达式求值
>
> 1. 初始化`OPTR`栈和`OPND`栈，将表达式起始符 “#” 压入`OPTR`栈。
> 2. 扫描表达式，读入第一个字符`ch`，如果表达式没有扫描完毕至 “#” 或`OPTR`的栈顶元素不为 “#” 时，则循环执行以下操作：
>    - 若`ch`不是运算符，则压入`OPND`栈，读入下一个字符`ch`。
>    - 若`ch`是运算符，则根据`OPTR`的栈顶元素和`ch`的优先级比较结果，做不同的处理：
>      - 若是`ch`优先级更高，则`ch`压入`OPTR`栈，读入下一字符`ch`。
>      - 若是栈顶元素优先级更高，则弹出`OPTR`栈顶的运算符，从`OPND`栈弹出两个数，进行相应运算，结果压入`OPND`栈。
>      - 若是等于，则`OPTR`的栈顶元素是 “(” 且`ch`是 “)”，这时弹出`OPTR`栈顶的 “(”，相当于括号匹配成功，然后读入下一字符`ch`。
> 3. `OPND`栈顶元素即为表达式求值结果，返回此元素。

```C++{.line-numbers}
// 算术表达式求值的算符优先算法，设 OPTR 和 OPND 分别为运算符栈和操作数栈
char EvaluateExpression()
{
    InitStack(OPND); // 初始化 OPND 栈
    InitStack(OPTR); // 初始化 OPTR 栈
    Push(OPTR, '#'); // 将表达式起始符 '#' 压入 OPTR 栈
    
    char ch;
    cin >> ch;
    while (ch != '#' || GetTop(OPTR) != '#')
    {
        if (!In(ch)) // ch 不是运算符则进 OPND 栈
        {
            Push(OPND, ch);
            cin >> ch;
        }
        else
        {
            switch (Precede(GetTop(OPTR), ch)) // 比较 OPTR 的栈顶元素和 ch 的优先级
            {
                case '<':
                    Push(OPTR, ch); // 当前字符 ch 压入 OPTR 栈
                    cin >> ch; // 读入下一字符
                    break;
                case '>':
                    Pop(OPTR, theta); // 弹出 OPTR 栈顶的运算符
                    Pop(OPND, b); // 弹出 OPND 栈顶的两个运算数
                    Pop(OPND, a);
                    Push(OPND, Operate(a, theta, b)); // 将运算结果压入 OPND 栈
                    break;
                case '=': // OPTR 的栈顶元素是 '('，且 ch 是 ')'
                    Pop(OPTR, x); // 弹出 OPTR 栈顶的 '('
                    cin >> ch; // 读入下一字符
                    break;
            }
        }
    }
    return GetTop(OPND); // OPND 栈顶元素即为表达式求值结果
}
```

算法中用到了 3 个自定义函数。`In`用于判定读入的字符`ch`是否为运算符，`Precede`用于判定`OPTR`栈顶元素与读入的运算符之间的优先关系，`Operate`用于进行二元运算。

上述算法中的操作数只能是一位数，因为这里使用的`OPND`栈是字符栈。如果要进行多位数的运算，需要将`OPND`栈改为数栈，读入的数字字符拼成数之后再入栈。

此算法从头到尾扫描表达式中每个字符，若表达式的字符串长度为 $n$，则此算法的时间复杂度为 $O(n)$。算法在运行时所占用的辅助空间主要取决于`OPTR`栈和`OPND`栈的大小，它们的空间大小之和不会超过 $n$，所以此算法的空间复杂度为 $O(n)$。

# 第4章 串、数组和广义表

## 4.1 串的定义

**串**（string）（或**字符串**）是由零个或多个字符组成的有限序列，一般记为
$$
s=“a_1\ a_2\cdots a_n”\quad(n\geqslant 0)
$$

其中，$s$ 是串的名，用双引号括起来的字符序列是串的值，$a_i(1\leqslant i\leqslant n)$ 可以是字母、数字或其他字符，串中字符的数目 $n$ 称为串的长度。零个字符的串称为**空串**（null string），其长度为零。

串中任意个连续的字符组成的子序列称为该串的**子串**，包含子串的串相应地称为**主串**。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置以子串的第一个字符在主串中的位置来表示。

称两个串是相等的，当且仅当这两个串的值相等。也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。

由一个或多个空格组成的串称为**空格串**（blank string），其长度为串中空格字符的个数。为了清楚起见，使用符号 $\varnothing$ 来表示空串。

## 4.2 案例引入

## 4.3 串的类型定义、存储结构及其运算

### 4.3.1 串的抽象类型定义

$$
\begin{aligned}
    &\texttt{ADT String \{}\\
    &\texttt{\quad 数据对象：$D=\{a_i\,|\,a_i\in\text{CharacterSet},\,i=1,2,\cdots,n,\,n\geqslant 0\}$}\\
    &\texttt{\quad数据关系：$Rl=\{\textrm{<}a_{i-1},a_i\textrm{>}|\,a_{i-1},a_i\in D,\,i=1,2,\cdots,n\}$}\\
    &\texttt{\quad 基本操作：}\\
    &\texttt{\qquad StrAssign(\&T, chars)}\\
    &\texttt{\qquad\quad 初始条件：chars\,是字符串常量}\\
    &\texttt{\qquad\quad 操作结果：生成一个其值等于\,chars\,的串\,T}\\
    &\texttt{\qquad StrCopy(\&T, S)}\\
    &\texttt{\qquad\quad 初始条件：串\,S\,存在}\\
    &\texttt{\qquad\quad 操作结果：由串\,S\,复制得串\,T}\\
    &\texttt{\qquad StrEmpty(S)}\\
    &\texttt{\qquad\quad 初始条件：串\,S\,存在}\\
    &\texttt{\qquad\quad 操作结果：若\,S\,为空串，则返回\,true，否则返回\,false}\\
    &\texttt{\qquad StrCompare(S, T)}\\
    &\texttt{\qquad\quad 初始条件：串\,S\,和\,T\,存在}\\
    &\texttt{\qquad\quad 操作结果：若\,S$>$T，则返回值大于\,0；若\,S$=$T，则返回值为\,0；}\\
    &\texttt{\qquad\qquad\qquad\qquad 若\,S$<$T，则返回值小于\,0}
    &\texttt{\qquad StrLength(S)}\\
    &\texttt{\qquad\quad 初始条件：串\,S\,存在}\\
    &\texttt{\qquad\quad 操作结果：返回\,S\,的元素个数，称为串的长度}\\
    &\texttt{\qquad ClearString(\&S)}\\
    &\texttt{\qquad\quad 初始条件：串\,S\,存在}\\
    &\texttt{\qquad\quad 操作结果：将\,S\,清为空串}\\
    &\texttt{\qquad Concat(\&T, S1, S2)}\\
    &\texttt{\qquad\quad 初始条件：串\,S1\,和\,S2\,存在}\\
    &\texttt{\qquad\quad 操作结果：用\,T\,返回由\,S1\,和\,S2\,连接而成的新串}\\
    &\texttt{\qquad SubString(\&Sub, S, pos, len)}\\
    &\texttt{\qquad\quad 初始条件：串\,S\,存在，$1\leqslant\text{pos}\leqslant\text{StrLength(S)}$且$\,0\leqslant\text{len}\leqslant\text{StrLength(S)}-\text{pos}+1$}\\
    &\texttt{\qquad\quad 操作结果：用\,Sub\,返回串\,S\,的第\,pos\,个字符起长度为\,len\,的子串}\\
    &\texttt{\qquad Index(S, T, pos)}\\
    &\texttt{\qquad\quad 初始条件：串\,S\,和\,T\,存在，T\,是非空串，$1\leqslant\text{pos}\leqslant\text{StrLength(S)}$}\\
    &\texttt{\qquad\quad 操作结果：若主串\,S\,中存在和串\,T\,值相同的子串，则返回它在主串\,S\,中第\,pos}\\
    &\texttt{\qquad\qquad\qquad\qquad 个字符之后第一次出现的位置；否则返回值为\,0}\\
    &\texttt{\qquad Replace(\&S, T, V)}\\
    &\texttt{\qquad\quad 初始条件：串\,S、T\,和\,V\,存在，T\,是非空串}\\
    &\texttt{\qquad\quad 操作结果：用\,V\,替换主串\,S\,中出现的所有与\,T\,相等的不重叠的子串}\\
    &\texttt{\qquad StrInsert(\&S, pos, T)}\\
    &\texttt{\qquad\quad 初始条件：串\,S\,和\,T\,存在，$1\leqslant\text{pos}\leqslant\text{StrLength(S)}+1$}\\
    &\texttt{\qquad\quad 操作结果：在串\,S\,的第\,pos\,个字符之前插入串\,T}\\
    &\texttt{\qquad StrDelete(\&S, pos, len)}\\
    &\texttt{\qquad\quad 初始条件：串\,S\,存在，$1\leqslant\text{pos}\leqslant\text{StrLength(S)}-\text{len}+1$}\\
    &\texttt{\qquad\quad 操作结果：从串\,S\,中删除第\,pos\,个字符起长度为\,len\,的子串}\\
    &\texttt{\qquad DestroyString(\&S)}\\
    &\texttt{\qquad\quad 初始条件：串\,S\,存在}\\
    &\texttt{\qquad\quad 操作结果：串\,S\,被销毁}\\
    &\texttt{\} ADT String}
\end{aligned}
$$

### 4.3.2 串的存储结构

与线性表类似，串也有两种基本存储结构：顺序存储和链式存储。但考虑到存储效率和算法的方便性，串多采用顺序存储结构。

#### 4.3.2.1 串的顺序存储

类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。

按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述：

```C{.line-numbers}
//-------串的定长顺序存储结构-------
#define MAXLEN 255 // 串的最大长度

typedef struct
{
    char ch[MAXLEN + 1]; // 存储串的一维数组
    int length; // 串的当前长度
} SString;
```

这种定义方式是静态的，在编译时刻就确定了串空间的大小。但多数情况下，串的操作是以串的整体形式参与的，串变量之间的长度相差较大，在操作中串值长度的变化也较大，这样为串变量设定固定大小的空间不尽合理。最好是根据实际需要，在程序执行过程中动态地分配和释放字符数组空间。在 C 语言中，存在一个称之为 “堆”（heap） 的自由存储区，可以为每个新产生的串动态分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址。这种字符串的存储方式也称为串的堆式顺序存储结构，定义如下：

```C{.line-numbers}
//-----串的堆式顺序存储结构-----
typedef struct
{
    char *ch; // 若是非空串，则按串长分配存储区，否则 ch 为 NULL
    int length; // 串的当前长度
} HString;
```

为了便于说明问题，本章后面算法描述当中所用到的顺序存储的字符串都是从下标为 1 的数组分量开始存储的，下标为 0 的分量闲置不用。

#### 4.3.2.2 串的链式存储

顺序串的插入和删除操作不方便，需要移动大量的字符。因此，可以采用单链表方式存储串。

在用链表存储串时，每个结点可以存放一个字符，也可以存放多个字符。当结点大小大于 1 时，由于串长不一定是结点大小的整数倍，则链表中的最后一个结点不一定全被串值占满，此时通常补上 “#” 或其他的非串值字符。

为了便于进行串的操作，当以链表存储串值时，除头指针外，还可附设一个尾指针表示链表中的最后一个结点，并给出当前串的长度。称如此定义的串存储结构为块链结构，说明如下：

```C{.line-numbers}
//-----串的链式存储结构-----
#define CHUNKSIZE 80 // 可由用户定义的块大小

typedef struct Chunk
{
    char ch[CHUNKSIZE];
    struct Chunk *next;
} Chunk;

typedef struct
{
    Chunk *head; // 头指针
    Chunk *tail; // 尾指针
    int length; // 串的当前长度
} LString;
```

在链式存储方式中，结点大小的选择直接影响着串处理的效率。存储密度小（如结点大小为 1 时），运算处理方便，但存储占用量大。

串的字符集大小也是一个重要因素。一般来说，字符集小，则字符的机内编码就短，这也影响串值存储方式的选取。

串的链式存储结构对某些串操作（如连接操作等）有一定方便之处，但不如顺序存储结构灵活，占用存储量大且操作复杂。

### 4.3.3 串的模式匹配算法

子串的定位运算通常称为串的**模式匹配**或**串匹配**。

设有两个字符串 S 和 T。设 S 为主串，也称正文串；设 T 为子串，也称为模式。在主串 S 中查找与模式 T 相匹配的子串，如果匹配成功，确定相匹配的子串中的第一个字符在主串 S 中出现的位置。

#### 4.3.3.1 BF（Brute-Force）算法

> **算法4.1** BF算法：从主串`S`的第`pos`个字符开始查找子串`T`
>
> 1. 分别用计数指针`i`和`j`指示主串`S`和模式`T`中当前正待比较的字符位置，`i`初值为`pos`，`j`初值为 1。
> 2. 如果两个串均未比较到末尾，则对`S.ch[i]`与`T.ch[j]`进行比较：
>    - 若相等，则`i`和`j`分别指示串中下一个位置，继续比较后续字符。
>    - 若不等，指针后退重新开始匹配。`i`后退到主串的下一个字符（`i = i - j + 2`），`j`后退到模式的第一个字符（`j = 1`）。
> 3. 如果`j > T.length`，说明模式`T`中的每个字符依次和主串`S`中的一个连续的字符序列相等，则匹配成功，返回和模式`T`中第一个字符相等的字符在主串`S`中的序号（`i - T.length`）；否则匹配不成功，返回 0。

```C{.line-numbers}
// 返回模式 T 在主串 S 中第 pos 个字符开始第一次出现的位置。若不存在，则返回 0
// 其中，T 非空，1 <= pos <= S.length
int Index_BF(SString S, SString T, int pos)
{
    // 初始化
    int i = pos;
    int j = 1;
    
    while (i <= S.length && j <= T.length) // 两个串均未比较到串尾
    {
        if (S.ch[i] == T.ch[j]) // 当前位置匹配成功，继续比较后续字符
        {
            i++;
            j++;
        }
        else // 当前位置匹配失败，指针后退重新开始匹配
        {
            i = i - j + 2; // i 后退到上次起始字符的下一个位置
            j = 1;
        }
    }
    
    if (j > T.length) // 匹配成功
        return i - T.length;
    else // 匹配失败
        return 0;
}
```

最好情况下，每趟不成功的匹配都发生在模式串的第一个字符与主串中相应字符的比较。设主串的长度为 $n$，子串的长度为 $m$。假设从主串的第 $i$ 个位置开始与模式串匹配成功，则在前 $i-1$ 趟匹配中字符总共比较了 $i-1$ 次。若第 $i$ 趟成功的字符比较次数为 $m$，则总比较次数为 $i-1+m$。对于成功匹配的主串，其起始位置由 1 到 $n-m+1$，假定这 $n-m+1$ 个起始位置上的匹配成功概率相等，则最好情况下匹配成功的平均比较次数为
$$
\sum_{i=1}^{n-m+1} p_i(i-1+m)=\dfrac{1}{n-m+1}\sum_{i=1}^{n-m+1}(i-1+m)=\dfrac{1}{2}(n+m)
$$

即最好情况下的平均时间复杂度是 $O(n+m)$。

最坏情况下，每趟不成功的匹配都发生在模式串的最后一个字符与主串中相应字符的比较。假设从主串的第 $i$ 个位置开始与模式串匹配成功，则在前 $i-1$ 趟匹配中字符总共比较了 $(i-1)m$ 次。若第 $i$ 趟成功的字符比较次数为 $m$，则总比较次数为 $im$。因此最坏情况下匹配成功的平均比较次数为
$$
\sum_{i=1}^{n-m+1} p_i im=\dfrac{1}{n-m+1}\sum_{i=1}^{n-m+1} im=\dfrac{m}{2}(n-m+2)
$$

即最坏情况下的平均时间复杂度是 $O(nm)$。

BF 算法思路直观简明。但当匹配失败时，主串的指针`i`总是回溯到`i-j+2`位置，模式串的指针总是恢复到首字符位置，因此算法时间复杂度高。

#### 4.3.3.2 KMP算法

KMP 算法是对 BF 算法的改进。其改进在于：每当一趟匹配中出现字符比较不等时，不需回溯`i`指针，而是利用已经得到的部分匹配的结果将模式串向右滑动尽可能远的距离后，继续进行比较。

假设主串为 $“s_1s_2\cdots s_n”$，模式串为 $“t_1t_2\cdots t_m”$。当匹配过程中产生 “失配”（即 $s_i\not=t_j$）时，前 $j-1$ 个字符匹配成功，即满足下列等式：
$$
\tag{4-1} “t_1t_2\cdots t_{j-1}”=“s_{i-j+1}s_{i-j+2}\cdots s_{i-1}”
$$

假设此时应从模式串中第 $k(k<j)$ 个字符开始继续比较，而 $i$ 指针不回溯，即主串中第 $i$ 个字符与模式中第 $k$ 个字符再比较，则模式中前 $k-1$ 个字符的子串必须满足下列关系式 $(4\text{-}2)$，且不可能存在 $k'>k$ 满足下列关系式 $(4\text{-}2)$。
$$
\tag{4-2} “t_1t_2\cdots t_{k-1}”=“s_{i-k+1}s_{i-k+2}\cdots s_{i-1}”
$$

根据式 $(4\text{-}1)$ 可得
$$
\tag{4-3} “t_{j-k+1}t_{j-k+2}\cdots t_{j-1}”=“s_{i-k+1}s_{i-k+2}\cdots s_{i-1}”
$$

由式 $(4\text{-}2)$ 和式 $(4\text{-}3)$ 推得下列等式
$$
\tag{4-4} “t_1t_2\cdots t_{k-1}”=“t_{j-k+1}t_{j-k+2}\cdots t_{j-1}”
$$

反之，若模式串中存在满足式 $(4\text{-}4)$ 的两个子串，则当匹配过程中主串第 $i$ 个字符与模式串第 $j$ 个字符比较不等时，仅需将模式向右滑动至模式中第 $k$ 个字符和主串中第 $i$ 个字符对齐。此时，模式中前 $k-1$ 个字符的子串 $“t_1t_2\cdots t_{k-1}”$ 必定与主串中第 $i$ 个字符之前长度为 $k-1$ 的子串 $“s_{i-k+1}s_{i-k+2}\cdots s_{i-1}”$ 相等。由此，匹配仅需从模式中第 $k$ 个字符与主串中第 $i$ 个字符开始，依次向后进行比较。

若令 $\text{next}[j]=k$，则 $\text{next}[j]$ 表明当模式中第 $j$ 个字符与主串中相应字符 “失配” 时，在模式中需重新和主串中该字符进行比较的字符的位置。由此可引出模式串的 $\text{next}$ 函数的定义：
$$
\text{next}[j]=\begin{cases}
    0 & j=1\\
    \max\{k\,|\,1<k<j\,且有\,“t_1t_2\cdots t_{k-1}”=“t_{j-k+1}t_{j-k+2}\cdots t_{j-1}”\} & 其他
\end{cases}
$$

在求得模式的 $\text{next}$ 函数之后，匹配可如下进行：假设以指针`i`和`j`分别指示主串和模式中正待比较的字符，令`i`的初值为`pos`，`j`的初值为 1。若在匹配过程中 $s_i=t_j$，则`i`和`j`分别增 1；否则，`i`不变，而`j`退到`next[j]`的位置再比较，若相等，则指针各自增 1，否则`j`再退到下一个`next`值的位置，以此类推，直至下列两种可能：一种是`j`退到某个`next`值时字符比较相等，则指针各自增 1，继续进行匹配；另一种是`j`退到值为零（即模式的第一个字符 “失配”），则此时需将模式继续向右滑动一个位置，即从主串的下一个字符 $s_{i+1}$ 起和模式重新开始匹配。

> **算法4.2** KMP算法

```C{.line-numbers}
// 利用模式串 T 的 next 函数求 T 在主串 S 中第 pos 个字符之后的位置
// 其中，T 非空，1 <= pos <= S.length
int Index_KMP(SString S, SString T, int pos)
{
    int i = pos;
    int j = 1;
    while (i <= S.length && j <= T.length) // 两个串均未比较到串尾
    {
        if (j == 0 || S.ch[i] == T.ch[j])
        {
            i++;
            j++;
        }
        else
        {
            j = next[j];
        }
    }
    
    if (j > T.length) // 匹配成功
        return i - T.length;
    else // 匹配失败
        return 0;
}
```

$\text{next}$ 函数值仅取决于模式串本身，而和主串无关，可从分析其定义出发用递推的方法求得 $\text{next}$ 函数值。

由定义得知：
$$
\tag{4-5} \text{next}[1]=0
$$

设 $\text{next}[j]=k$，这表明在模式串中存在下列关系：
$$
\tag{4-6} “t_1t_2\cdots t_{k-1}”=“t_{j-k+1}t_{j-k+2}\cdots t_{j-1}”
$$

其中 $k$ 为满足 $1<k<j$ 的某个值，并且不可能存在 $k'>k$ 满足等式 $(4\text{-}6)$。根据 $\text{next}[j]$ 的值递推求取 $\text{next}[j+1]$，可能有以下两种情况。

1. 若 $t_k=t_j$，则表明在模式串中有
$$
\tag{4-7} “t_1t_2\cdots t_{k}”=“t_{j-k+1}t_{j-k+2}\cdots t_{j}”
$$
并且不可能存在 $k'>k$ 满足等式 $(4\text{-}7)$，因此 $\text{next}[j+1]=k+1$，即
$$
\tag{4-8} \text{next}[j+1]=\text{next}[j]+1
$$
2. 若 $t_k\not=t_j$，则表明在模式串中
$$
“t_1t_2\cdots t_{k}”\not=“t_{j-k+1}t_{j-k+2}\cdots t_{j}”
$$
此时可把求 $\text{next}$ 函数值的问题看成是一个模式匹配的问题，整个模式串既是主串又是模式串。当前在匹配的过程中，已有 $t_{j-k+1}=t_1,t_{j-k+2}=t_2,\cdots,t_{j-1}=t_{k-1}$，则当 $t_j\not=t_k$ 时应将模式向右滑动至以模式中的第 $\text{next}[k]$ 个字符和主串中的第 $j$ 个字符相比较。若 $\text{next}[k]=k'$，且 $t_j=t_{k'}$，则有
$$
\tag{4-9} “t_1t_2\cdots t_{k'}”=“t_{j-k'+1}t_{j-k'+2}\cdots t_{j}” \quad(1<k'<k<j)
$$
这就是说 $\text{next}[j+1]=k'+1$，即
$$
\tag{4-10} \text{next}[j+1]=\text{next}[k]+1
$$
若 $t_j\not=t_{k'}$，则将模式继续向右滑动直至将模式中第 $\text{next}[k']$ 个字符和 $t_j$ 对齐，$\cdots$，以此类推，直至 $t_j$ 和模式中某个字符匹配成功或者不存在任何 $k'(1<k'<j)$ 满足等式 $(4\text{-}9)$，则
$$
\tag{4-11} \text{next}[j+1]=1
$$

根据式 $(4\text{-}5)$、式 $(4\text{-}8)$、式 $(4\text{-}10)$ 和式 $(4\text{-}11)$，仿照 KMP 算法，可得到求 $\text{next}$ 函数值的算法，如算法 4.3 所示。

> **算法4.3** 计算 next 函数值

```C{.line-numbers}
// 求模式串 T 的 next 函数值并存入数组 next
void get_next(SString T, int next[])
{
    int i = 1; // 主串指针
    int j = 0; // 模式串指针
    next[1] = 0;
    while (i < T.length)
    {
        if (j == 0 || T.ch[i] == T.ch[j])
        {
            i++;
            j++;
            next[i] = j;
        }
        else
        {
            j = next[j];
        }
    }
}
```

算法 4.3 的时间复杂度为 $O(m)$。

虽然 BF 算法的时间复杂度是 $O(nm)$，但在一般情况下，其实际的执行时间近似于 $O(n+m)$。KMP 算法仅当模式与主串之间存在许多 “部分匹配” 的情况下才显得比 BF 算法快得多。但 KMP 算法的最大特点是指示主串的指针不需回溯，整个匹配过程中，对主串仅需从头至尾扫描一遍，这对处理从外设输入的庞大文件很有效，可以边读入边匹配，而无需回头重读。

前面定义的 $\text{next}$ 函数还可以优化。若按上述定义得到 $\text{next}[j]=k$，而模式中 $t_j=t_k$，则当匹配过程中 $s_i\not=t_j$ 时，不需要再和 $t_k$ 进行比较，而直接和 $t_{\text{next}[k]}$ 进行比较，此时应有 $\text{next}[j]=\text{next}[k]$。由此可得计算 $\text{next}$ 函数修正值的算法，如算法 4.4 所示。

> **算法4.4** 计算 next 函数修正值

```C{.line-numbers}
// 求模式串 T 的 next 函数修正值并存入数组 nextval
void get_nextval(SString T, int nextval[])
{
    int i = 1;
    int j = 0;
    nextval[1] = 0;
    while (i < T.length)
    {
        if (j == 0 || T.ch[i] == T.ch[j])
        {
            i++;
            j++;
            
            if (T.ch[i] != T.ch[j])
                nextval[i] = j;
            else
                nextval[i] = nextval[j];
        }
        else
        {
            j = nextval[j];
        }
    }
}
```

## 4.4 数组

### 4.4.1 数组的类型定义

**数组**是由类型相同的数据元素构成的有序集合，每个元素称为**数组元素**，每个元素受 $n(n\geqslant 1)$ 个线性关系的约束，每个元素在 $n$ 个线性关系中的序号 $i_1,i_2,\cdots,i_n$ 称为该元素的**下标**，可以通过下标访问该数据元素。因为数组中每个元素处于 $n$ 个关系中，故称该数组为 $n$ 维数组。

例如，一维数组可以看成是一个线性表，二维数组可以看成数据元素是线性表的线性表，$n$ 维数组可以看成数据元素是 $n-1$ 维数组的一维数组。

抽象数据类型数组可形式地定义为：
$$
\begin{aligned}
    & \texttt{ADT Array \{}\\
    & \quad\texttt{数据对象：$D=\{a_{j_1j_2\cdots j_n}|\,a_{j_1j_2\cdots j_n}\in \texttt{ElemSet},\,j_i=0,\cdots,b_i-1,\,i=1,2,\cdots,n\}$}\\
    & \quad\texttt{\qquad\qquad$n$\,称为数组的维度，$b_i$\,是数组第\,$i$\,维的长度，$j_i$\,是数组元素的第\,$j$\,维下标}\\
    & \quad\texttt{数据关系：}R=\{R_1,R_2,\cdots,R_n\}\\
    & \quad\texttt{基本操作：}\\
    & \qquad\texttt{InitArray(\&A, n, boundi, ..., boundn)}\\
    & \qquad\quad\texttt{操作结果：若维数\,n\,和各维长度合法，则构造相应的数组\,A，并返回\,OK}\\
    & \qquad\texttt{DestroyArray(\&A)}\\
    & \qquad\quad\texttt{操作结果：销毁数组\,A}\\
    & \qquad\texttt{Value(A, \&e,index1,..., indexn)}\\
    & \qquad\quad\texttt{初始条件：A\,是\,$n$\,维数组，e\,为元素变量，随后是\,$n$\,个下标值}\\
    & \qquad\quad\texttt{操作结果：若各下标不越界，则\,e\,赋值为所指定的\,A\,的元素值，并返回\,OK}\\
    & \qquad\texttt{Assign(\&A, e, index1,..., indexn)}\\
    & \qquad\quad\texttt{初始条件：A\,是\,$n$\,维数组，e\,为元素变量，随后是\,$n$\,个下标值}\\
    & \qquad\quad\texttt{操作结果：若各下标不越界，则将\,e\,的值赋给所指定的\,A\,的元素，并返回\,OK}\\
    & \texttt{\} ADT Array}
\end{aligned}
$$

### 4.4.2 数组的顺序存储

数组一般不做插入或删除操作，一旦建立了数组，则结构中的数据元素个数和元素之间的关系就不再发生变动。因此，采用顺序存储结构表示数组比较合适。

由于存储单元是一维的结构，而数组可能是多维的结构，则用一组连续存储单元存放数组的数据元素就有次序约定问题。对二维数组有两种存储方式：一种是以列序为主序的存储方式，一种是以行序为主序的存储方式。

对于数组，一旦规定了其维数和各维的长度，便可为它分配存储空间。反之，只要给出一组下标便可求得相应数组元素的存储位置。下面仅用以行序为主序的存储结构为例予以说明。

假设每个数据元素占 $L$ 个存储单元，则二维数组 $A[0\dots m-1,0\dots n-1]$（即下标从 0 开始，共有 $m$ 行 $n$ 列）中任一元素 $a_{ij}$ 的存储位置可由下式确定
$$
\tag{4-12} \text{LOC}(i,j)=\text{LOC}(0,0)+(ni+j)L
$$

式中，$\text{LOC}(i,j)$ 是 $a_{ij}$ 的存储位置；$\text{LOC}(0,0)$ 是 $a_{00}$ 的存储位置，即二维数组 $A$ 的起始存储位置，也称为基地址或基址。

将式 $(4\text{-}12)$ 推广到一般情况，可得到 $n$ 维数组 $A[0\dots b_1-1,0\dots b_2-1,\cdots,0\dots b_n-1]$ 的数据元素存储位置的计算公式：
$$
\begin{aligned}
    \text{LOC}(j_1,j_2,\cdots,j_n)&=\text{LOC}(0,0,\cdots,0)+(b_2b_3\cdots b_nj_1+b_3b_4\cdots b_nj_2
    +\cdots+b_nj_{n-1}+j_n)L\\
    &=\text{LOC}(0,0,\cdots,0)+\Bigg(\sum_{i=1}^{n-1}\bigg(j_i\prod_{k=i+1}^n b_k\bigg)+j_n\Bigg)L
\end{aligned}
$$

可缩写成
$$
\tag{4-13} \text{LOC}(j_1,j_2,\cdots,j_n)=\text{LOC}(0,0,\cdots,0)+\sum_{i=1}^n c_ij_i
$$

其中，$c_n=L,c_{i-1}=b_ic_i,1<i\leqslant n$。

式 $(4\text{-}13)$ 称为 $n$ 维数组的映像函数。数组元素的存储位置是其下标的线性函数，一旦确定了数组各维的长度，$c_i$ 就是常数。由于计算各个元素存储位置的时间相等，所以存取数组中任一元素的时间也相等，即数组是一种随机存取结构。

### 4.4.3 特殊矩阵的压缩存储

所谓**压缩存储**，是指为多个值相同的元只分配一个存储空间，对零元不分配空间。

假若值相同的元素或者零元素在矩阵中的分布有一定规律，则称此类矩阵为**特殊矩阵**。特殊矩阵主要包括对称矩阵、三角矩阵和对角矩阵等。

#### 4.4.3.1 对称矩阵

若 $n$ 阶矩阵 $\boldsymbol{A}$ 中的元满足下列性质
$$
a_{ij}=a_{ji}\quad 1\leqslant i,j\leqslant n
$$

则称为 $n$ 阶对称矩阵。

对于对称矩阵，可以为每一对对称元分配一个存储空间，则可将 $n^2$ 个元压缩存储到 $\dfrac{n(n+1)}{2}$ 个元的空间中。不失一般性，可以以行序为主序存储其下三角（包括对角线）中的元。

假设以一维数组 $sa[n(n+1)/2]$ 作为 $n$ 阶对称矩阵 $\boldsymbol{A}$ 的存储结构，则 $sa[k]$ 和矩阵元 $a_{ij}$ 之间存在着一一对应的关系：

$$
k=\begin{cases}
    \dfrac{i(i-1)}{2}+j-1 & i\geqslant j\\
    \dfrac{j(j-1)}{2}+i-1 & i<j
\end{cases}
$$

对于任意给定的一组下标 $(i,j)$，均可在 $sa$ 中找到矩阵元 $a_{ij}$；反之，对所有的 $k=0,1,2,\cdots,\dfrac{n(n+1)}{2}-1$，都能确定 $sa[k]$ 中的元在矩阵中的位置 $(i,j)$。由此，称 $sa[n(n+1)/2]$ 为 $n$ 阶对称矩阵 $\boldsymbol{A}$ 的压缩存储。

#### 4.4.3.2 三角矩阵

以主对角线划分，三角矩阵有上三角矩阵和下三角矩阵两种。上三角矩阵是指矩阵下三角（不包括对角线）中的元均为常数或零的 $n$ 阶矩阵，下三角矩阵与之相反。

对三角矩阵进行压缩存储，除了和对称矩阵一样，只存储其上（下）三角中的元素之外，再加一个存储常数的存储空间即可。

对于上三角矩阵，$sa[k]$ 和矩阵元 $a_{ij}$ 之间的对应关系为
$$
k=\begin{cases}
    \dfrac{(i-1)(2n-i+2)}{2}+j-i & i\leqslant j\\
    \dfrac{n(n+1)}{2} & i>j
\end{cases}
$$

对于下三角矩阵，$sa[k]$ 和矩阵元 $a_{ij}$ 之间的对应关系为
$$
k=\begin{cases}
    \dfrac{i(i-1)}{2}+j-1 & i\geqslant j\\
    \dfrac{n(n+1)}{2} & i<j
\end{cases}
$$

#### 4.4.3.3 对角矩阵

对角矩阵所有的非零元素都集中在以主对角线为中心的带状区域中，除了主对角线上和直接在对角线上、下方若干条对角线上的元之外，所有其他的元皆为零，如图 4.1 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图4.1-对角矩阵.2znurtxxejq0.png">
    <br>
    图4.1 对角矩阵
</div>

## 4.5 广义表

### 4.5.1 广义表的定义

广义表是线性表的推广，也称为列表。广义表一般记作
$$
LS=(a_1,a_2,\cdots,a_n)
$$

其中，$LS$ 是广义表的名称，$n$ 是其长度。

在线性表的定义中，$a_i(1\leqslant i \leqslant n)$ 只限于单个元素。而在广义表的定义中，$a_i$ 可以是单个元素，也可以是广义表，分别称为广义表 $LS$ 的原子和子表。习惯上，用大写字母表示广义表的名称，用小写字母表示原子。

广义表的定义是一个递归的定义，因为在描述广义表时又用到了广义表的概念。

广义表的例子：

1. $A=()$——$A$ 是一个空表，其长度为零。
2. $B=(e)$——$B$ 只有一个原子 $e$，其长度为 1。
3. $C=(a,(b,c,d))$——$C$ 的长度为 2，两个元素分别为原子 $a$ 和子表 $(b,c,d)$。
4. $D=(A,B,C)$——$D$ 的长度为 3，3 个元素都是广义表。将子表的值代入后，则有 $D=((),(e),(a,(b,c,d)))$。
5. $E=(a,E)$——这是一个递归的表，其长度为 2。$E$ 相当于一个无限的广义表 $E=(a,(a,(a,\cdots)))$。

广义表的 3 个重要结论：

1. 广义表的元素可以是子表，而子表的元素还可以是子表，由此，广义表是一个多层次的结构，可以用图形象地表示。例如，图 4.2 表示的是广义表 $D$，图中以圆圈表示广义表，以方块表示原子。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图4.2-广义表的图形表示.1vs1warg0dc0.png">
    <br>
    图4.2 广义表的图形表示
</div>

2. 广义表可为其他广义表所共享。在广义表中可以不必列出子表的值，而是通过子表的名称来引用。
3. 广义表可以是一个递归的表，即广义表也可以是其本身的一个子表。例如，$E$ 就是一个递归的表。

广义表最重要的两个运算如下：

1. 取表头`GetHead(LS)`：取出的表头为非空广义表的第一个元素，它可以是一个单原子，也可以是一个子表。
2. 取表尾`GetTail(LS)`：取出的表尾为除去表头之外，由其余元素构成的表。即表尾一定是一个广义表。

### 4.5.2 广义表的存储结构

由于广义表中的数据元素可以有不同的结构，因此难以用顺序存储结构表示，通常采用链式存储结构。常用的链式存储结构有两种：头尾链表的存储结构、扩展线性链表的存储结构。

#### 4.5.2.1 头尾链表的存储结构

由于广义表中的数据元素可能为原子或广义表，由此需要两种结构的结点：一种是表结点，用以表示广义表；一种是原子结点，用以表示原子。一个表结点可由 3 个域组成：标志域、指示表头的指针域和指示表尾的指针域。原子结点只需 2 个域：标志域和值域。如图 4.3 所示，其中 tag 是标志域，值为 1 时表明结点是子表，值为 0 时表明结点是原子。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图4.3-头尾链表表示的结点结构.69948lcrkv80.png">
    <br>
    图4.3 头尾链表表示的结点结构
</div>

若广义表不空，则可分解成表头和表尾，因此，一对确定的表头和表尾可唯一确定广义表。

广义表的头尾链表存储表示的形式定义说明如下：

```C{.line-numbers}
typedef enum
{
    ATOM, // 原子
    LIST // 子表
} ElemTag;

typedef struct GLNode
{
    ElemTag tag; // 标志域，用于区分原子结点和表结点
    union
    {
        AtomType atom; // 原子结点的值域，AtomType 由用户定义
        struct
        {
            struct GLNode *hp; // 表头指针
            struct GLNode *tp; // 表尾指针
        } ptr; // 表结点的指针域
    };
} *GList;
```

上面列举了 5 个广义表的例子，它们的存储结构如图 4.4 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图4.4-头尾链表表示的存储结构示例.21eht4dco6io.png">
    <br>
    图4.4 头尾链表表示的存储结构示例
</div>

头尾链表存储结构的特点：

1. 除空表的表头指针为空外，对任何非空广义表，其表头指针均指向一个表结点，且该表结点中的`hp`域指示广义表表头（或为原子结点，或为表结点），`tp`域指向广义表表尾（当表尾为空时指针为空，否则必为表结点）。
2. 容易分清列表中原子和子表所在层次。例如在广义表 $D$ 中，原子 $a$ 和 $e$ 在同一层次上，而 $b$、$c$ 和 $d$ 在同一层次且比 $a$ 和 $e$ 低一层，$B$ 和 $C$ 是同一层的子表。
3. 最高层的表结点个数即为广义表的长度。

#### 4.5.2.2 扩展线性链表的存储结构

在扩展线性链表的存储结构中，无论是原子结点还是表结点均由三个域组成，其结点结构如图 4.5 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图4.5-扩展线性链表表示的结点结构.1lpwh40rrxuo.png">
    <br>
    图4.5 扩展线性链表表示的结点结构
</div>

4.5.1 小节中广义表例子所对应的扩展线性链表表示的存储结构，如图 4.6 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图4.6-扩展线性链表表示的存储结构示例.1ebcylp6lctc.png">
    <br>
    图4.6 扩展线性链表表示的存储结构示例
</div>

## 4.6 案例分析与实现

在模式匹配中，如果模式串是环状的，就需要对 BF 算法或 KMP 算法进行改进。

假设模式串的长度是 $m$。因为模式串是环状的，为了线性取到每个可行的长度为 $m$ 的模式串，可将存储模式串的字符串长度扩大为 $2m$，将模式串连续存储两次。然后循环 $m$ 次，依次取得每个长度为 $m$ 的环状字符串，将此字符串作为模式串，调用 BF 算法或 KMP 算法进行匹配。只要匹配成功，即可中止循环；否则，若 $m$ 次循环中没有一次匹配成功，说明匹配失败。

> **算法4.5** 环状模式串的模式匹配
>
> 1. 设置一个标志性变量`flag`，用来标识是否匹配成功。初值为 0，表示未匹配。
>
> 2. 模式串的长度是 $m$，将存储模式串的字符串长度扩大为 $2m$，将模式串连续存储两次。
>
> 3. 循环 $m$ 次，重复执行以下操作：
>
>    （1）依次取得每个长度为 $m$ 的字符串。
>
>    （2）将此字符串作为模式串，调用 BF 算法或 KMP 算法进行模式匹配，将匹配结果赋给`flag`。若`flag`非 0，表示匹配成功，返回`flag`。
>
> 4. 若 $m$ 次循环执行完毕后未返回，说明匹配失败，返回 0。

```C{.line-numbers}
int Index_circular(SString S, SString T, int pos)
{
    int flag = 0; // 用来标识是否匹配成功
    
    SString T_doubled;
    Concat(T_doubled, T, T); // 将存储模式串的字符串长度扩大 2 倍
    
    SString temp;
    for (int i = 1; i <= T.length; i++)
    {
        SubString(temp, T_doubled, i, T.length); // 取得长度为 m 的字符串作为模式串
        flag = Index_KMP(S, temp, pos); // 模式匹配
        if (flag != 0) // 若匹配成功则直接返回
            return flag;
    }
    
    return 0;
}
```

# 第5章 树和二叉树

## 5.1 树和二叉树的定义

### 5.1.1 树的定义

**树**（tree）是 $n(n\geqslant 0)$ 个结点的有限集，它或为空树（$n=0$），或为非空树。对于非空树 $T$：

1. 有且仅有一个称之为根的结点；
2. 除根结点以外的其余结点可分为 $m(m>0)$ 个互不相交的有限集 $T_1,T_2,\cdots,T_m$，其中每个集合本身又是一棵树，并且称为根的**子树**（subtree）。

树的结构定义是一个递归的定义，即在树的定义中又用到树的定义。

例如，图 5.1 是一棵有 13 个结点的树。其中 A 是根，其余结点分成 3 个互不相交的子集：$T_1=\{B,E,F,K,L\}$，$T_2=\{C,G\}$，$T_3=\{D,H,I,J,M\}$。$T_1$、$T_2$ 和 $T_3$ 都是根 A 的子树，且本身也是一棵树。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.1-树的示例.6m71s194bgc0.png">
    <br>
    图5.1 树的示例
</div>

树还可以有其他的表示形式，如图 5.2 所示为图 5.1 中树的各种表示。其中（a）是以嵌套集合的形式表示的，对于图中的任何两个集合，或者不相交，或者一个包含另一个；（b）是以广义表的形式表示的，根作为由子树森林组成的表的名字写在表的左边；（c）是凹入表示法。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.2-树的其他表示法.2jvma9yyero0.png">
    <br>
    图5.2 树的其他表示法
</div>

### 5.1.2 树的基本术语

1. **结点**：树中的一个独立单元，包含一个数据元素及若干指向其子树的分支。
2. 结点的度：结点拥有的子树数称为结点的度。
3. 树的度：树的度是树内各结点度的最大值。
4. 叶子：度为 0 的结点称为**叶子**或**终端结点**。
5. 非终端结点：度不为 0 的结点称为**非终端结点**或**分支结点**。除根结点之外，非终端结点也称为**内部结点**。
6. 双亲和孩子：结点的子树的根称为该结点的**孩子**，该结点称为孩子的**双亲**。
7. 兄弟：同一个双亲的孩子之间互称**兄弟**。
8. **祖先**：从根到该结点所经分支上的所有结点。
9. 子孙：以某结点为根的子树中的任一结点都称为该结点的**子孙**。
10. 层次：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加 1。
11. 堂兄弟：双亲在同一层的结点互为**堂兄弟**。
12. 树的深度：树中结点的最大层次称为树的**深度**或**高度**。图 5.1 所示的树的深度为 4。
13. 有序树和无序树：如果将树中结点的各子树看成从左到右是有次序的（即不能互换），则称该树为**有序树**，否则称为**无序树**。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
14. **森林**：是 $m(m\geqslant 0)$ 棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。
    就逻辑结构而言，任何一棵树都是一个二元组 $Tree=(root,F)$，其中 $root$ 是数据元素，称作树的根结点；$F$ 是 $m(m\geqslant 0)$ 棵树的森林，$F=(T_1,T_2,\cdots,T_m)$，其中 $T_i=(r_i,F_i)$ 称作根 $root$ 的第 $i$ 棵子树。当 $m\not=0$ 时，在树根和其子树森林之间存在下列关系：

$$
RF=\{\text{<}root,r_i\text{>}|\,i=1,2,\cdots,m,\,m>0\}
$$

### 5.1.3 二叉树的定义

**二叉树**（binary tree）是 $n(n\geqslant 0)$ 个结点所构成的集合，它或为空树（$n=0$），或为非空树。对于非空树 $T$：

1. 有且仅有一个称之为根的结点；
2. 除根节点以外的其余结点分为两个互不相交的子集 $T_1$ 和 $T_2$，分别称为 $T$ 的**左子树**和**右子树**，且 $T_1$ 和 $T_2$ 本身又都是二叉树。

二叉树与树一样具有递归性质。二叉树与树的区别主要有以下两点：

1. 二叉树每个结点至多只有两棵子树（即二叉树中不存在度大于 2 的结点）。
2. 二叉树的子树有左右之分，其次序不能任意颠倒。

二叉树有 5 种基本形态，如图 5.3 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.3-二叉树的5种基本形态.7m51ftd89gg.png">
    <br>
    图5.3 二叉树的5种基本形态
</div>

## 5.2 案例引入

## 5.3 树和二叉树的抽象数据类型定义

树的抽象数据类型定义如下：
$$
\begin{aligned}
    & \texttt{ADT Tree \{}\\
    & \quad\texttt{数据对象\,$D$：$D$\,是具有相同特性的数据元素的集合}\\
    & \quad\texttt{数据关系\,$R$：若\,$D$\,为空集，则称为空树；若\,$D$\,仅含一个数据元素，则\,$R$\,为空集；}\\
    & \qquad\qquad\qquad\quad\texttt{否则\,$R=\{H\}$，$H$\,是如下二元关系：}\\
    & \qquad\qquad\qquad\quad\texttt{（1）在\,$D$\,中存在唯一的称为根的数据元素\,root，它在关系\,$H$\,下无前驱;}\\
    & \qquad\qquad\qquad\quad\texttt{（2）若\,$D-\{\text{root}\}\not=\varnothing$，则存在\,$D-\{\text{root}\}$\,的一个划分}\\
    & \qquad\qquad\qquad\qquad\quad\ \ \texttt{$D_1,D_2,\cdots,D_m(m>0)$，对任意\,$j\not=k(1\leqslant j,k\leqslant m)$\,有}\\
    & \qquad\qquad\qquad\qquad\quad\ \ \texttt{$D_j\cap D_k=\varnothing$，且对任意的\,$i(1\leqslant i\leqslant m)$，唯一存在数据元素}\\
    & \qquad\qquad\qquad\qquad\quad\ \ \texttt{$x_i\in D_i$，有\,$\textrm{<}\text{root},x_i\textrm{>}\in H$；}\\
    & \qquad\qquad\qquad\quad\texttt{（3）对应于\,$D-\{\text{root}$\}\,的划分，$H-\{\textrm{<}\text{root},x_1\textrm{>},\cdots,\textrm{<}\text{root},x_m\textrm{>}\}$}\\
    & \qquad\qquad\qquad\qquad\quad\ \ \texttt{有唯一的一个划分\,$H_1,H_2,\cdots,H_m(m>0)$，对任意\,$j\not=k(1\leqslant j,k\leqslant m)$有}\\
    & \qquad\qquad\qquad\qquad\quad\ \ \texttt{$H_j\cap H_k=\varnothing$，且对任意\,$i(1\leqslant i\leqslant m)$，$H_i$\,是\,$D_i$\,上的二元关系，}\\
    & \qquad\qquad\qquad\qquad\quad\ \ \texttt{$(D_i,\{H_i\})$\,是一棵符合本定义的树，称为根\,root\,的子树。}\\
    & \quad\texttt{基本操作\,$P$：}\\
    & \qquad\texttt{InitTree(\&T)}\\
    & \qquad\quad\texttt{操作结果：构造空树\,T}\\
    & \qquad\texttt{DestroyTree(\&T)}\\
    & \qquad\quad\texttt{初始条件：树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：销毁树\,T}\\
    & \qquad\texttt{CreateTree(\&T, definition)}\\
    & \qquad\quad\texttt{初始条件：definition\,给出树\,T\,的定义}\\
    & \qquad\quad\texttt{操作结果：按\,definition\,构造树\,T}\\
    & \qquad\texttt{ClearTree(\&T)}\\
    & \qquad\quad\texttt{初始条件：树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：将树\,T\,清为空树}\\
    & \qquad\texttt{TreeEmpty(T)}\\
    & \qquad\quad\texttt{初始条件：树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：若\,T\,为空树，则返回\,true，否则返回\,false}\\
    & \qquad\texttt{TreeDepth(T)}\\
    & \qquad\quad\texttt{初始条件：树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：返回\,T\,的深度}\\
    & \qquad\texttt{Root(T)}\\
    & \qquad\quad\texttt{初始条件：树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：返回\,T\,的根}\\
    & \qquad\texttt{Value(T, cur\_e)}\\
    & \qquad\quad\texttt{初始条件：树\,T\,存在，cur\_e\,是\,T\,中某个结点}\\
    & \qquad\quad\texttt{操作结果：返回\,cur\_e\,的值}\\
    & \qquad\texttt{Assign(T, cur\_e, value)}\\
    & \qquad\quad\texttt{初始条件：树\,T\,存在，cur\_e\,是\,T\,中某个结点}\\
    & \qquad\quad\texttt{操作结果：结点\,cur\_e\,赋值为\,value}\\
    & \qquad\texttt{Parent(T, cur\_e)}\\
    & \qquad\quad\texttt{初始条件：树\,T\,存在，cur\_e\,是\,T\,中某个结点}\\
    & \qquad\quad\texttt{操作结果：若\,cur\_e\,是\,T\,的非根结点，则返回它的双亲，否则返回“空”}\\
    & \qquad\texttt{LeftChild(T, cur\_e)}\\
    & \qquad\quad\texttt{初始条件：树\,T\,存在，cur\_e\,是\,T\,中某个结点}\\
    & \qquad\quad\texttt{操作结果：若\,cur\_e\,是\,T\,的非叶子结点，则返回它的最左孩子，否则返回“空”}\\
    & \qquad\texttt{RightSibling(T, cur\_e)}\\
    & \qquad\quad\texttt{初始条件：树\,T\,存在，cur\_e\,是\,T\,中某个结点}\\
    & \qquad\quad\texttt{操作结果：若\,cur\_e\,有右兄弟，则返回它的右兄弟，否则返回“空”}\\
    & \qquad\texttt{InsertChild(\&T, p, i, c)}\\
    & \qquad\quad\texttt{初始条件：树\,T\,存在，p\,指向\,T\,中某个结点，$1\leqslant i\leqslant \text{p\,所指结点的度}+1$，}\\
    & \qquad\qquad\qquad\qquad\texttt{非空树\,c\,与\,T\,不相交}\\
    & \qquad\quad\texttt{操作结果：插入\,c\,为\,T\,中\,p\,所指结点的第\,i\,棵子树}\\
    & \qquad\texttt{DeleteChild(\&T, p, i)}\\
    & \qquad\quad\texttt{初始条件：树\,T\,存在，p\,指向\,T\,中某个结点，$1\leqslant i\leqslant \text{p\,所指结点的度}$}\\
    & \qquad\quad\texttt{操作结果：删除\,T\,中\,p\,所指结点的第\,i\,棵子树}\\
    & \qquad\texttt{TraverseTree(T)}\\
    & \qquad\quad\texttt{初始条件：树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：按某种次序对\,T\,的每个结点访问一次}\\
    & \texttt{\} ADT Tree}
\end{aligned}
$$

二叉树的抽象数据类型定义如下：
$$
\begin{aligned}
    & \texttt{ADT BinaryTree \{}\\
    & \quad\texttt{数据对象\,$D$：$D$\,是具有相同特性的数据元素的集合}\\
    & \quad\texttt{数据关系\,$R$：若\,$D=\varnothing$，则\,$R=\varnothing$，称\,BinaryTree\,为空二叉树；}\\
    & \qquad\qquad\qquad\quad\texttt{若\,$D\not=\varnothing$，则\,$R=\{H\}$，$H$\,是如下二元关系：}\\
    & \qquad\qquad\qquad\quad\texttt{（1）在\,$D$\,中存在唯一的称为根的数据元素\,root，它在关系\,$H$\,下无前驱;}\\
    & \qquad\qquad\qquad\quad\texttt{（2）若$D-\{\text{root}\}\not=\varnothing$，则存在$D-\{\text{root}\}=\{D_\text{l},D_\text{r}\}$，且}\\
    & \qquad\qquad\qquad\qquad\quad\ \ \texttt{$D_\text{l}\cap D_\text{r}=\varnothing$；}\\
    & \qquad\qquad\qquad\quad\texttt{（3）若\,$D_\text{l}\not=\varnothing$，则\,$D_\text{l}$\,中存在唯一的元素\,$x_\text{l}$，$\textrm{<}\text{root},x_\text{l}\textrm{>}\in H$，且存在}\\
    & \qquad\qquad\qquad\qquad\quad\ \ \texttt{$D_\text{l}$\,上的关系\,$H_\text{l}\subset H$；若\,$D_\text{r}\not=\varnothing$，则\,$D_\text{r}$\,中存在唯一的元素\,$x_\text{r}$，}\\
    & \qquad\qquad\qquad\qquad\quad\ \ \texttt{$\textrm{<}\text{root},x_\text{r}\textrm{>}\in H$，且存在\,$D_\text{r}$\,上的关系\,$H_\text{r}\subset H$；}\\
    & \qquad\qquad\qquad\qquad\quad\ \ H=\{\text{<}\text{root},x_\text{l}\text{>},\text{<}\text{root},x_\text{r}\text{>},H_\text{l},H_\text{r}\}\texttt{；}\\
    & \qquad\qquad\qquad\quad\texttt{（4）$(D_\text{l},\{H_\text{l}\})$\,是一棵符合本定义的二叉树，称为根的左子树；}\\
    & \qquad\qquad\qquad\qquad\quad\ \ \texttt{$(D_\text{r},\{H_\text{r}\})$\,是一棵符合本定义的二叉树，称为根的右子树。}\\
    & \quad\texttt{基本操作\,$P$：}\\
    & \qquad\texttt{InitBiTree(\&T)}\\
    & \qquad\quad\texttt{操作结果：构造空二叉树\,T}\\
    & \qquad\texttt{DestroyBiTree(\&T)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：销毁二叉树\,T}\\
    & \qquad\texttt{CreateBiTree(\&T, definition)}\\
    & \qquad\quad\texttt{初始条件：definition\,给出二叉树\,T\,的定义}\\
    & \qquad\quad\texttt{操作结果：按\,definition\,构造二叉树\,T}\\
    & \qquad\texttt{ClearBiTree(\&T)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：将二叉树\,T\,清为空树}\\
    & \qquad\texttt{BiTreeEmpty(T)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：若T为空二叉树，则返回\,true，否则返回\,false}\\
    & \qquad\texttt{BiTreeDepth(T)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：返回\,T\,的深度}\\
    & \qquad\texttt{Root(T)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：返回\,T\,的根}\\
    & \qquad\texttt{Value(T, cur\_e)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在，cur\_e\,是\,T\,中某个结点}\\
    & \qquad\quad\texttt{操作结果：返回\,cur\_e\,的值}\\
    & \qquad\texttt{Assign(T, cur\_e, value)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在，cur\_e\,是\,T\,中某个结点}\\
    & \qquad\quad\texttt{操作结果：结点\,cur\_e\,赋值为\,value}\\
    & \qquad\texttt{Parent(T, cur\_e)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在，cur\_e\,是\,T\,中某个结点}\\
    & \qquad\quad\texttt{操作结果：若\,cur\_e\,是\,T\,的非根结点，则返回它的双亲，否则返回“空”}\\
    & \qquad\texttt{LeftChild(T, cur\_e)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在，cur\_e\,是\,T\,中某个结点}\\
    & \qquad\quad\texttt{操作结果：返回\,cur\_e\,的左孩子。若\,cur\_e\,无左孩子，则返回“空”}\\
    & \qquad\texttt{RightChild(T, cur\_e)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在，cur\_e\,是\,T\,中某个结点}\\
    & \qquad\quad\texttt{操作结果：返回\,cur\_e\,的右孩子。若\,cur\_e\,无右孩子，则返回“空”}\\
    & \qquad\texttt{LeftSibling(T, cur\_e)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在，cur\_e\,是\,T\,中某个结点}\\
    & \qquad\quad\texttt{操作结果：若\,cur\_e\,有左兄弟，则返回它的左兄弟，否则返回“空”}\\
    & \qquad\texttt{RightSibling(T, cur\_e)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在，cur\_e\,是\,T\,中某个结点}\\
    & \qquad\quad\texttt{操作结果：若\,cur\_e\,有右兄弟，则返回它的右兄弟，否则返回“空”}\\
    & \qquad\texttt{InsertChild(\&T, p, LR, c)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在，p\,指向\,T\,中某个结点，LR\,为\,0\,或\,1，非空树\,c\,与\,T\,不相交且右子树为空}\\
    & \qquad\quad\texttt{操作结果：根据\,LR\,为\,0\,或\,1，插入\,c\,为\,T\,中\,p\,所指结点的左或右子树，}\\
    & \qquad\qquad\qquad\qquad\ \texttt{p\,所指结点的原有左或右子树成为\,c\,的右子树}\\
    & \qquad\texttt{DeleteChild(\&T, p, LR)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在，p\,指向\,T\,中某个结点，LR\,为\,0\,或\,1}\\
    & \qquad\quad\texttt{操作结果：根据\,LR\,为\,0\,或\,1，删除\,T\,中\,p\,所指结点的左或右子树}\\
    & \qquad\texttt{PreOrderTraverse(T)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：先序遍历\,T，对每个结点访问一次}\\
    & \qquad\texttt{InOrderTraverse(T)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：中序遍历\,T，对每个结点访问一次}\\
    & \qquad\texttt{PostOrderTraverse(T)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：后序遍历\,T，对每个结点访问一次}\\
    & \qquad\texttt{LevelOrderTraverse(T)}\\
    & \qquad\quad\texttt{初始条件：二叉树\,T\,存在}\\
    & \qquad\quad\texttt{操作结果：层序遍历\,T，对每个结点访问一次}\\
    & \texttt{\} ADT BinaryTree}
\end{aligned}
$$

## 5.4 二叉树的性质和存储结构

### 5.4.1 二叉树的性质

> **性质1**  在二叉树的第 $i$ 层上至多有 $2^{i-1}$ 个结点（$i\geqslant 1$）。

**证明：** 利用归纳法，$i=1$ 时，只有一个根结点，$2^{i-1}=2^0=1$ 成立。
假设对所有的 $j(1\leqslant j<i)$ 命题成立，即第 $j$ 层上至多有 $2^{j-1}$ 个结点。下面证明 $j=i$ 时命题也成立。
由归纳假设：第 $i-1$ 层上至多有 $2^{i-2}$ 个结点。由于二叉树每个结点的度至多为 2，故在第 $i$ 层上的最大结点数为第 $i-1$ 层上的最大结点数的 2 倍，即 $2\times 2^{i-2}=2^{i-1}$。

> **性质2**  深度为 $k$ 的二叉树至多有 $2^k-1$ 个结点（$k\geqslant 1$）。

**证明：** 由性质 1 可得，深度为 $k$ 的二叉树的最大结点数为
$$
\sum_{i=1}^k 2^{i-1}=2^k-1
$$

> **性质3** 对任何一棵二叉树，如果其终端结点数为 $n_0$，度为 2 的结点数为 $n_2$，则 $n_0=n_2+1$。

**证明：** 设 $n_1$ 为二叉树中度为 1 的结点数。因为二叉树中所有结点的度均小于或等于 2，所以其结点总数为
$$
\tag{5-1} n=n_0+n_1+n_2
$$

除了根结点外，其余结点都有一个分支进入。设 $B$ 为分支总数，则
$$
n=B+1
$$

由于这些分支是由度为 1 或 2 的结点射出的，所以有
$$
B=n_1+2n_2
$$

于是得
$$
\tag{5-2} n=n_1+2n_2+1
$$

由式 $(5\text{-}1)$ 和式 $(5\text{-}2)$ 得
$$
n_0=n_2+1
$$

**满二叉树**：深度为 $k$ 且含有 $2^k-1$ 个结点的二叉树。图 5.4 所示是一棵深度为 4 的满二叉树。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.4-满二叉树.71bgg4ncxic0.png">
    <br>
    图5.4 满二叉树
</div>

满二叉树的特点是：每一层上的结点数都是最大结点数，即第 $i$ 层的结点数具有最大值 $2^{i-1}$。

可以对满二叉树的结点进行连续编号，约定编号从根结点起，自上而下，自左至右。

**完全二叉树**：深度为 $k$、有 $n$ 个结点的二叉树，当且仅当其每一个结点都与深度为 $k$ 的满二叉树中编号从 1 至 $n$ 的结点一一对应时，称之为完全二叉树。图 5.5 所示为一棵深度为 4 的完全二叉树。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.5-完全二叉树.5a8z451ulsk0.png">
    <br>
    图5.5 完全二叉树
</div>

完全二叉树的特点是：

1. 叶子结点只可能在层次最大的两层上出现。
2. 对任一结点，若其右分支下的子孙的最大层次为 $l$，则其左分支下的子孙的最大层次必为 $l$ 或 $l+1$。

> **性质4** 具有 $n$ 个结点的完全二叉树的深度为 $\lfloor \log_2n\rfloor+1$。

**证明：** 假设深度为 $k$，则根据性质 2 和完全二叉树的定义有
$$
2^{k-1}-1<n\leqslant 2^k-1\quad或\quad 2^{k-1}\leqslant n<2^k
$$

于是
$$
k-1 \leqslant \log_2n < k
$$

因为 $k$ 是整数，所以
$$
k=\lfloor\log_2n\rfloor+1
$$

> **性质5** 如果对一棵有 $n$ 个结点的完全二叉树的结点按层序编号，则对任一结点 $i(1\leqslant i\leqslant n)$，有
>
> 1. 如果 $i=1$，则结点 $i$ 是二叉树的根，无双亲；如果 $i>1$，则其双亲`PARENT(i)`是结点 $\Big\lfloor\dfrac{i}{2}\Big\rfloor$。
> 2. 如果 $2i>n$，则结点 $i$ 无左孩子，结点 $i$ 为叶子结点；否则其左孩子`LCHILD(i)`是结点 $2i$。
> 3. 如果 $2i+1>n$，则结点 $i$ 无右孩子；否则其右孩子`RCHILD(i)`是结点 $2i+1$。

###  5.4.2 二叉树的存储结构

#### 5.4.2.1 顺序存储结构

```C
//-----二叉树的顺序存储表示-----
#define MAXTSIZE 100 // 二叉树的最大结点数

typedef TElemType SqBiTree[MAXTSIZE];
```

顺序存储结构使用一组地址连续的存储单元来存储数据元素，为了能够在存储结构中反映出结点之间的逻辑关系，必须将二叉树中的结点依照一定的规律安排在这组单元中。

对于完全二叉树，只要从根起按层序存储即可，依次自上而下、自左至右存储结点元素，即将完全二叉树上编号为 $i$ 的结点元素存储在如上定义的一维数组中下标为 $i-1$ 的分量中。

对于一般二叉树，应将其每个结点与完全二叉树上的结点相对照，存储在一维数组的相应分量中。

顺序存储结构仅适用于完全二叉树，而一般二叉树不适合。在最坏的情况下，一个深度为 $k$ 且只有 $k$ 个结点的单支树却需要长度为 $2^k-1$ 的一维数组，这造成了存储空间的极大浪费。

#### 5.4.2.2 链式存储结构

由二叉树的定义得知，二叉树的结点由一个数据元素和分别指向其左、右子树的两个分支构成，如图 5.6(a) 所示。则表示二叉树的链表中的结点至少包含 3 个域：数据域和左、右指针域，如图 5.6(b) 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.6-二叉树的结点及其存储结构.l8aks5na5sg.png">
    <br>
    图5.6 二叉树的结点及其存储结构
</div>

为了便于找到结点的双亲，还可以在结点结构中增加一个指向其双亲结点的指针域，如图 5.6(c) 所示。

利用这两种结点结构所得二叉树的存储结构分别称为二叉链表和三叉链表，如图 5.7 所示。链表的头指针指向二叉树的根结点。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.7-二叉树的链表存储结构.15phrzbxcpls.png">
    <br>
    图5.7 二叉树的链表存储结构
</div>

```C{.line-numbers}
//-----二叉树的二叉链表存储表示-----
typedef struct BiTNode
{
    TElemType data; // 数据域
    struct BiTNode *lchild; // 左孩子指针
    struct BiTNode *rchild; // 右孩子指针
} BiTNode, *BiTree;
```

> **性质6** 在含有 $n$ 个结点的二叉链表中有 $n+1$ 个空指针域。

**证明：** 设二叉链表中叶子结点的个数为 $n_0$，度为 1 的结点个数为 $n_1$，度为 2 的结点个数为 $n_2$，则
$$
n=n_0+n_1+n_2
$$

设二叉链表中非空指针域的数量为 $B$，则
$$
B=n_1+2n_2
$$

二叉链表中指针域的个数为 $2n$，则空指针域的个数为
$$
\begin{aligned}
    n_{\text{NULL}}&=2n-B\\
    &=2(n_0+n_1+n_2)-(n_1+2n_2)\\
    &=2n_0+n_1\\
    &=n_0+n_1+n_2+1\\
    &=n+1
\end{aligned}
$$

## 5.5 遍历二叉树和线索二叉树

### 5.5.1 遍历二叉树

#### 5.5.1.1 遍历二叉树算法描述

遍历二叉树是指按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。遍历二叉树是二叉树最基本的操作，也是二叉树其他各种操作的基础。遍历的实质是对二叉树进行线性化的过程，即遍历的结果是将非线性结构的树中结点排成一个线性序列。

先序遍历二叉树的操作定义如下：若二叉树为空，则空操作；否则

1. 访问根节点；
2. 先序遍历左子树；
3. 先序遍历右子树。

中序遍历二叉树的操作定义如下：若二叉树为空，则空操作；否则

1. 中序遍历左子树；
2. 访问根节点；
3. 中序遍历右子树。

后序遍历二叉树的操作定义如下：若二叉树为空，则空操作；否则

1. 后序遍历左子树；
2. 后序遍历右子树；
3. 访问根节点。

> **算法5.1** 中序遍历二叉树的递归算法

```C++{.line-numbers}
// 中序遍历二叉树 T 的递归算法
void InOrderTraverse(BiTree T)
{
    if (T) // 若二叉树非空
    {
        InOrderTraverse(T->lchild); // 中序遍历左子树
        cout << T->data; // 访问根节点
        InOrderTraverse(T->rchild); // 中序遍历右子树
    }
}
```

3 种遍历算法的不同之处仅在于访问根结点和遍历左、右子树的先后关系。如果在算法中暂且去掉和递归无关的`cout`语句，则 3 个遍历算法完全相同。因此，从递归执行过程的角度来看，先序、中序和后序遍历是完全相同的。

可以利用栈将递归算法改写成非递归算法。例如，从中序遍历递归算法执行过程中递归工作栈的状态可见：

1. 工作记录中包含两项，其一是递归调用的语句编号，其二是指向根结点的指针。
2. 当栈顶记录中的指针非空时，应遍历左子树，即指向左子树根的指针进栈。
3. 若栈顶记录中的指针为空，则应退至上一层。若是从左子树返回，则应访问当前层中指针所指的根结点；若是从右子树返回，则表明当前层的遍历结束，应继续退栈。从另一个角度看，遍历右子树时不再需要保存当前层的根指针，直接修改栈顶记录中的指针即可。

> **算法5.2** 中序遍历的非递归算法
>
> 1. 初始化一个空栈`S`，指针`p`指向根结点。
> 2. 申请一个结点空间`q`，用来存放栈顶弹出的元素。
> 3. 当`p`非空或者栈`S`非空时，循环执行以下操作：
>    - 如果`p`非空，则将`p`进栈，`p`指向该结点的左孩子；
>    - 如果`p`为空，则弹出栈顶元素并访问，将`p`指向该结点的右孩子。

```C++{.line-numbers}
void InOrderTraverse(BiTree T)
{
    InitStack(S);
    BiTNode *p = T;
    BiTNode *q = new BiTNode;
    
    while (p || !StackEmpty(S)) // p 非空或栈 S 非空时，继续循环
    {
        if (p) // p 非空
        {
            Push(S, p); // 根指针进栈
            p = p->lchild; // 遍历左子树
        }
        else // p 为空
        {
            Pop(S, q); // 退栈
            cout << q->data; // 访问根结点
            p = q->rchild;
        }
    }
}
```

无论是递归还是非递归遍历二叉树，无论按哪一种次序进行遍历，对含 $n$ 个结点的二叉树，其时间复杂度均为 $O(n)$。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为 $n$，则空间复杂度也为 $O(n)$。

#### 5.5.1.2 根据遍历序列确定二叉树

若二叉树中各结点的值均不相同，任意一棵二叉树结点的先序序列、中序序列和后序序列都是唯一的。

由二叉树的先序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树。但是，由一棵二叉树的先序序列和后序序列不能唯一确定一棵二叉树，因为无法确定左右子树两部分。

#### 5.5.1.3 二叉树遍历算法的应用

> **算法5.3** 先序遍历的顺序建立二叉链表
>
> 为简化问题，设二叉树中结点的元素均为一个单字符。则算法步骤如下：
>
> 1. 扫描字符序列，读入字符`ch`。
> 2. 如果`ch`是结束字符（`'#'`），则表明该二叉树为空树，即`T`为`NULL`；否则执行以下操作：
>    （1）申请一个结点空间`T`；
>    （2）将`ch`赋给`T->data`；
>    （3）递归创建`T`的左子树；
>    （4）递归创建`T`的右子树。

```C++{.line-numbers}
// 按先序次序输入二叉树结点中的值，创建二叉链表表示的二叉树 T
void CreateBiTree(BiTree &T)
{
    char ch;
    cin >> ch;
    if (ch == '#')
        T = NULL;
    else
    {
        T = new BiTNode; // 生成根结点
        T->data = ch;
        CreateBiTree(T->lchild); // 递归创建左子树
        CreateBiTree(T->rchild); // 递归创建右子树
    }
}
```

> **算法5.4** 复制二叉树
>
> 如果是空树，递归结束，否则执行以下操作：
>
> 1. 申请一个新的结点空间，复制根结点；
> 2. 递归复制左子树；
> 3. 递归复制右子树。

```C++{.line-numbers}
// 复制一棵与 T 完全相同的二叉树
void Copy(BiTree T, BiTree &NewT)
{
    if (T == NULL) // 如果是空树，递归结束
    {
        NewT = NULL;
    }
    else
    {
        NewT = new BiTNode;
        NewT->data = T->data; // 复制根结点
        Copy(T->lchild, NewT->lchild); // 递归复制左子树
        Copy(T->rchild, NewT->rchild); // 递归复制右子树
    }
}
```

> **算法5.5** 计算二叉树的深度
>
> 如果是空树，递归结束，深度为 0，否则执行以下操作：
>
> 1. 递归计算左子树的深度，记为 $m$；
> 2. 递归计算右子树的深度，记为 $n$；
> 3. 如果 $m>n$，则二叉树的深度为 $m+1$，否则为 $n+1$。

```C{.line-numbers}
// 计算二叉树 T 的深度
int Depth(BiTree T)
{
    if (T == NULL) // 如果是空树，递归结束，深度为 0
        return 0;
    else
    {
        int m = Depth(T->lchild); // 递归计算左子树的深度
        int n = Depth(T->rchild); // 递归计算右子树的深度
        return m > n ? m + 1 : n + 1;
    }
}
```

> **算法5.6** 统计二叉树中结点的个数

```C{.line-numbers}
int NodeCount(BiTree T)
{
    if (T == NULL) // 如果是空树，则结点个数为 0
        return 0;
    else // 否则，结点个数 = 左子树的结点个数 + 右子树的结点个数 + 1
        return NodeCount(T->lchild) + NodeCount(T->rchild) + 1;
}
```

### 5.5.2 线索二叉树

#### 5.5.2.1 线索二叉树的基本概念

遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列，这实质上是对一个非线性结构进行线性化操作，使每个结点（除第一个和最后一个外）有且仅有一个直接前驱和直接后继。但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点在任一序列中的前驱和后继信息，这种信息只有在遍历的动态过程中才能得到。为此，引入线索二叉树来保存这些在动态过程中得到的有关前驱和后继的信息。

由于有 $n$ 个结点的二叉链表中必定存在 $n+1$ 个空指针域，因此可以充分利用这些空指针域来存放结点的前驱和后继信息。

规定：若结点有左子树，则其`lchild`域指示其左孩子，否则令`lchild`域指示其前驱；若结点有右子树，则其`rchild`域指示其右孩子，否则令`rchild`域指示其后继。为了避免混淆，需要改变结点结构，增加两个标志域，其结点形式如图 5.8 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.8-线索二叉树的结点形式.2fl4n7wy3izo.png">
    <br>
    图5.8 线索二叉树的结点形式
</div>

其中，`LTag`为 0 时，`lchild`域指示结点的左孩子；`LTag`为 1 时，`lchild`域指示结点的前驱。`RTag`为 0 时，`rchild`域指示结点的右孩子；`RTag`为 1 时，`rchild`域指示结点的后继。

二叉树的二叉线索类型定义如下：

```C{.line-numbers}
//-----二叉树的二叉线索存储表示-----
typedef struct BiThrNode
{
    TElemType data;
    struct BiThrNode *lchild;
    struct BiThrNode *rchild;
    int LTag;
    int RTag;
} BiThrNode, *BiThrTree;
```

以这种结点结构构成的二叉链表作为二叉树的存储结构叫做**线索链表**，其中指向结点前驱和后继的指针叫做**线索**。加上线索的二叉树叫做**线索二叉树**（Threaded Binary Tree）。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做**线索化**。

例如，图 5.9(a) 所示为中序线索二叉树，与其对应的中序线索链表如图 5.9(b) 所示，其中实现为指针，虚线为线索。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.9-线索二叉树及其存储结构.k3tpcm4499c.png">
    <br>
    图5.9 线索二叉树及其存储结构
</div>

为了方便起见，在二叉树的线索链表上也添加一个头结点，并令其`lchild`域的指针指向二叉树的根结点，其`rchild`域的指针指向遍历序列的最后一个结点。同时，令遍历序列中第一个结点的`lchild`域指针和最后一个结点`rchild`域的指针均指向头结点。这好比为二叉树建立了一个双向线索链表，既可以从第一个结点起沿后继进行遍历，也可以从最后一个结点起沿前驱进行遍历。

#### 5.5.2.2 构造线索二叉树

由于线索二叉树构造的实质是将二叉链表中的空指针改为指向前驱或后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化的过程即为在遍历的过程中修改空指针的过程。对二叉树按照不同的遍历次序进行线索化，可以得到不同的线索二叉树，包括先序线索二叉树、中序线索二叉树和后序线索二叉树。

为了记下遍历过程中访问结点的先后关系，附设一个指针`pre`始终指向刚刚访问过的结点，而指针`p`指向当前访问的结点，由此记录下遍历过程中访问结点的先后关系。

> **算法5.7** 以结点`p`为根的子树中序线索化
>
> 1. 如果`p`非空，左子树递归线索化。
> 2. 如果`p`的左孩子为空，则给`p`加上左线索，将`p->LTag`置为 1，让`p->lchild`指向`pre`；否则将`p->LTag`置为 0。
> 3. 如果`pre`的右孩子为空，则给`pre`加上右线索，将`pre->RTag`置为 1，让`pre->rchild`指向`p`；否则将`pre->RTag`置为 0。
> 4. 将`pre`指向`p`。
> 5. 右子树递归线索化。

```C{.line-numbers}
// pre 是全局变量，初始化时其右孩子指针为空，便于在树的最左点开始建线索
void InThreading(BiThrTree p)
{
    if (p)
    {
        InThreading(p->lchild); // 左子树递归线索化
        if (!p->lchild) // p 的左孩子为空
        {
            p->LTag = 1; // 给 p 加上左线索
            p->lchild = pre;
        }
        else
        {
            p->LTag = 0;
        }
        
        if (!pre->rchild) // pre 的右孩子为空
        {
            pre->RTag = 1; // 给 pre 加上右线索
            pre->rchild = p;
        }
        else
        {
            pre->RTag = 0;
        }
        
        pre = p;
        InThreading(p->rchild); // 右子树递归线索化
    }
}
```

> **算法5.8** 带头结点的二叉树中序线索化

```C++{.line-numbers}
// 中序遍历二叉树 T，并将其中序线索化，Thrt 指向头结点
void InOrderThreading(BiThrTree &Thrt, BiThrTree T)
{
    Thrt = new BiThrNode; // 建头结点
    Thrt->LTag = 0; // 头结点的左指针指向根结点
    Thrt->RTag = 1; // 头结点的右指针为右线索
    Thrt->rchild = Thrt; // 初始化时右指针指向自己
    if (!T)
        Thrt->lchild = Thrt; // 若树为空，则左指针也指向自己
    else
    {
        Thrt->lchild = T; // 头结点的左指针指向根结点
        pre = Thrt; // pre 初值指向头结点
        InThreading(T); // 调用算法5.7，对以 T 为根的二叉树进行中序线索化
        pre->rchild = Thrt; // 算法5.7结束后，pre为最右结点，pre的右线索指向头结点
        pre->RTag = 1;
        Thrt->rchild = pre; // 头结点的右线索指向最后一个结点
    }
}
```

#### 5.5.2.3 遍历线索二叉树

由于有了结点的前驱和后继信息，线索二叉树的遍历和在指定次序下查找结点的前驱和后继算法都变得简单。因此，若需经常查找结点在遍历序列中的前驱和后继，则采用线索链表作为存储结构。

下面分 3 种情况讨论在线索二叉树中如何查找结点的前驱和后继。

1. 在中序线索二叉树中查找
   （1）查找`p`指针所指结点的前驱
   - 若`p->LTag`为 1，则`p`的左链指示其前驱。
   - 若`p->LTag`为 0，说明`p`有左子树，结点的前驱是遍历左子树时最后访问的结点（左子树中最右下的结点）。

   （2）查找`p`指针所指结点的后继
   - 若`p->RTag`为 1，则`p`的右链指示其后继。
   - 若`p->RTag`为 0，说明`p`有右子树，结点的后继是遍历右子树时访问的第一个结点（右子树中最左下的结点）。
2. 在先序线索二叉树中查找
   （1）查找`p`指针所指结点的前驱
   - 若`p->LTag`为 1，则`p`的左链指示其前驱。
   - 若`p->LTag`为 0，说明`p`有左子树，此时`p`的前驱有两种情况：若`*p`是其双亲的左孩子，则其前驱为其双亲结点；否则应是其双亲的左子树上先序遍历最后访问到的结点。

   （2）查找`p`指针所指结点的后继
   - 若`p->RTag`为 1，则`p`的右链指示其后继。
   - 若`p->RTag`为 0，说明`p`有右子树，结点的后继是其左子树根（若存在）或右子树根。
3. 在后序线索二叉树中查找
   （1）查找`p`指针所指结点的前驱
   - 若`p->LTag`为 1，则`p`的左链指示其前驱。
   - 若`p->LTag`为 0，当`p->RTag`也为 0 时，则`p`的右链指示其前驱；若`p->LTag`为 0，而`p->RTag`为 1 时，则`p`的左链指示其前驱。

   （2）查找`p`指针所指结点的后继
   - 若`*p`是二叉树的根，则其后继为空。
   - 若`*p`是其双亲的右孩子，则其后继为双亲结点。
   - 若`*p`是其双亲的左孩子，且`*p`没有右兄弟，则其后继为双亲结点。
   - 若`*p`是其双亲的左孩子，且`*p`有右兄弟，则其后继为双亲的右子树上按后序遍历列出的第一个结点（即右子树中最左下的叶结点）。

由于有了结点的前驱和后继的信息，线索二叉树的遍历操作无需设栈，避免了频繁的进栈、出栈，因此在时间上和空间上都比遍历二叉树节省。如果遍历某种次序的线索二叉树，只要从该次序下的根结点出发，反复查找其在该次序下的后继，直到叶子结点。

> **算法5.9** 遍历中序线索二叉树
>
> 1. 指针`p`指向根结点。
> 2. `p`为非空树或遍历未结束时，循环执行以下操作：
>    （1）沿左孩子向下，到达最左下结点`*p`，它是中序的第一个结点。
>    （2）访问`*p`。
>    （3）沿右线索反复查找当前结点`*p`的后继结点并访问后继结点，直至右线索为 0 或者遍历结束。
>    （4）转向`p`的右子树。

```C{.line-numbers}
// T 指向头结点，头结点的左链 lchild 指向根结点
// 中序遍历线索二叉树 T 的非递归算法，对每个元素直接输出
void InOrderTraverse_Thr(BiThrTree T)
{
    BiThrNode *p = T->lchild; // p 指向根结点
    while (p != T)
    {
        while (p->LTag == 0) // 沿左孩子向下
            p = p->lchild;
        cout << p->data; // 访问其左子树为空的结点
        while (p->RTag == 1 && p->rchild != T) // 沿右线索访问后继结点
        {
            p = p->rchild;
            cout << p->data;
        }
        p = p->rchild; // 转向 p 的右子树
    }
}
```

遍历中序线索二叉树的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

## 5.6 树和森林

### 5.6.1 树的存储结构

#### 5.6.1.1 双亲表示法

这种表示法中，以一组连续的存储单元存储树的结点，每个结点除了数据域`data`外，还附设一个`parent`域用以指示其双亲结点的位置。

例如，图 5.10 为一棵树及其双亲表示的存储结构。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.10-树的双亲表示法示例.6f2ga4vc5yo0.png">
    <br>
    图5.10 树的双亲表示法示例
</div>

这种存储结构利用了每个结点只有唯一双亲的性质。在这种存储结构下，求结点的双亲十分方便，也容易求树的根，但求结点的孩子时需要遍历整个结构。

#### 5.6.1.2 孩子表示法

由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，每个指针指向一棵子树的根结点。此时链表中的结点可以有如图 5.11 所示的两种结点格式。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.11-孩子表示法的两种结点.4vfsjkrug7w0.png">
    <br>
    图5.11 孩子表示法的两种结点
</div>

若采用第一种结点格式，则多重链表中的结点是同构的，其中 $d$ 为树的度。由于树中很多结点的度小于 $d$，所以链表中有很多空链域，空间较浪费。在一棵有 $n$ 个结点、度为 $k$ 的树中，必有 $n(k-1)+1$ 个空链域。

若采用第二种结点格式，则多重链表中的结点是不同构的，其中 $d$ 为结点的度，`degree`域的值与 $d$ 相同。此时，虽能节约存储空间，但操作不方便。

另一种办法是，把每个结点的孩子结点排列起来，看成是一个线性表，且以单链表做存储结构，则 $n$ 个结点有 $n$ 个孩子链表。$n$ 个头指针又组成一个线性表，为了便于查找，可采用顺序存储结构。图 5.12 所示为图 5.10 中的树的孩子表示法。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.12-孩子链表.6vzg9ymdtgg0.png">
    <br>
    图5.12 孩子链表
</div>

与双亲表示法相反，孩子表示法便于那些涉及孩子的操作的实现。可以把双亲表示法和孩子表示法结合起来，将双亲表示与孩子链表合在一起，如图 5.13 所示。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.13-带双亲的孩子链表.7b51hd7owds0.png">
    <br>
    图5.13 带双亲的孩子链表
</div>

#### 5.6.1.3 孩子兄弟法

又称二叉树表示法，或二叉链表表示法，即以二叉链表做树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为`firstchild`域和`nextsibling`域，其结点形式如图 5.14 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.14-孩子兄弟表示法的结点.5ub3z68gir40.png">
    <br>
    图5.14 孩子兄弟表示法的结点
</div>

```C{.line-numbers}
// 树的二叉链表（孩子兄弟）存储表示
typedef struct CSNode
{
    ElemType data;
    struct CSNode *firstchild;
    struct CSNode *nextsibling;
} CSNode, *CSTree;
```

图 5.15 所示为图 5.10 中的树的孩子兄弟链表。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.15-孩子兄弟表示法示例.1x88lbixdrmo.png">
    <br>
    图5.15 孩子兄弟表示法示例
</div>

利用这种存储结构便于实现各种树的操作。首先易于实现找结点孩子等的操作。例如，若要访问结点`x`的第 $i$ 个孩子，则只要先从`firstchild`域找到第 1 个孩子结点，然后沿着孩子结点的`nextsibling`域连续走 $i-1$ 步，便可找到`x`的第 $i$ 个孩子。如果为每个结点增设一个`parent`域，则同样能方便地实现查找双亲的操作。

这种存储结构的优点是它和二叉树的二叉链表表示完全一样，便于将一般的树结构转换为二叉树进行处理，利用二叉树的算法来实现对树的操作。因此孩子兄弟表示法是应用较为普遍的一种树的存储表示方法。

### 5.6.2 森林与二叉树的转换

从树的二叉链表表示的定义可知，任何一棵与树对应的二叉树，其根结点的右子树必空。若把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟，则同样可导出森林和二叉树的对应关系，这个一一对应的关系说明森林或树与二叉树可以相互转换。

#### 5.6.2.1 森林转换成二叉树

如果 $F=\{T_1,T_2,\cdots,T_m\}$ 是森林，则可按如下规则转换成一棵二叉树 $B=(root,LB,RB)$：

1. 若 $F$ 为空，即 $m=0$，则 $B$ 为空树。
2. 若 $F$ 非空，则 $m\not=0$，则 $B$ 的根 $root$ 即为森林中第一棵树的根 $\operatorname{ROOT}(T_1)$，$B$ 的左子树 $LB$ 是从 $T_1$ 中根结点的子树森林 $F_1=\{T_{11},T_{12},\cdots,T_{1n}\}$ 转换而成的二叉树，其右子树 $RB$ 是从森林 $F'=\{T_2,T_3,\cdots,T_m\}$ 转换而成的二叉树。

#### 5.6.2.2 二叉树转换成森林

如果 $B=(root,LB,RB)$ 是一棵二叉树，则可按如下规则转换成森林 $F=\{T_1,T_2,\cdots,T_m\}$：

1. 若 $B$ 为空，则 $F$ 为空。
2. 若 $B$ 非空，则 $F$ 中第一棵树 $T_1$ 的根 $\operatorname{ROOT}(T_1)$ 即为二叉树 $B$ 的根 $root$，$T_1$ 中根结点的子树森林 $F_1$ 是由 $B$ 的左子树 $LB$ 转换而成的森林，$F$ 中除 $T_1$ 之外其余树组成的森林 $F'=\{T_2,T_3,\cdots,T_m\}$ 是由 $B$ 的右子树 $RB$ 转换而成的森林。

### 5.6.3 树和森林的遍历

#### 5.6.3.1 树的遍历

先根遍历树：先访问树的根结点，然后依次先根遍历根结点的每棵子树。

后根遍历树：先依次后根遍历每棵子树，然后访问根结点。

当以二叉链表做树的存储结构时，树的先根遍历和后根遍历可借用二叉树的先序遍历和中序遍历的算法实现。

#### 5.6.3.2 森林的遍历

先序遍历森林：

1. 访问森林中第一棵树的根结点。
2. 先序遍历第一棵树的根结点的子树森林。
3. 先序遍历除去第一棵树之后剩余的树构成的森林。

中序遍历森林：

1. 中序遍历森林中第一棵树的根结点的子树森林。
2. 访问第一棵树的根结点。
3. 中序遍历除去第一棵树之后剩余的树构成的森林。

当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，则森林的先序和中序遍历即为其对应的二叉树的先序和中序遍历。

## 5.7 哈夫曼树及其应用

### 5.7.1 哈夫曼树的基本概念

**哈夫曼树**又称**最优树**，是一类带权路径长度最短的树。

基本概念：

1. 路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。
2. 路径长度：路径上的分支数目称作路径长度。
3. 树的路径长度：从树根到每一结点的路径长度之和。
4. 权：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。
5. 结点的带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积。
6. 树的带权路径长度：树中所有叶子结点的带权路径长度之和，通常记作 $WPL=\displaystyle\sum_{k=1}^n w_kl_k$。
7. 哈夫曼树：假设有 $m$ 个权值 $\{w_1,w_2,\cdots,w_m\}$，可以构造一棵含 $m$ 个叶子结点的二叉树，每个叶子结点的权为 $w_i$，则其中带权路径长度 $WPL$ 最小的二叉树称作最优二叉树或哈夫曼树。

### 5.7.2 哈夫曼树的构造算法

哈夫曼树的构造过程：

1. 根据给定的 $n$ 个权值 $\{w_1,w_2,\cdots,w_m\}$，构造 $n$ 棵只有根结点的二叉树，这 $n$ 棵二叉树构成一个森林 $F$。
2. 在森林 $F$ 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。
3. 在森林 $F$ 中删除这两棵树，同时将新得到的二叉树加入 $F$ 中。
4. 重复 2 和 3，直到 $F$ 只含一棵树为止，这棵树便是哈夫曼树。

哈夫曼树是一种二叉树，而由于哈夫曼树中没有度为 1 的结点，则一棵有 $n$ 个叶子结点的哈夫曼树共有 $2n-1$ 个结点，可以存储在一个大小为 $2n-1$ 的一维数组中。每个结点的存储结构设计如图 5.16 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://cdn.jsdelivr.net/gh/zzx-JLU/images_for_markdown@main/数据结构/图5.16-哈夫曼树的结点结构.7718vqpugrk0.png">
    <br>
    图5.16 哈夫曼树的结点结构
</div>

```C{.line-numbers}
// 哈夫曼树的存储表示
typedef struct
{
    int weight; // 结点的权值
    int parent; // 结点的双亲的下标
    int lchild; // 结点的左孩子的下标
    int rchild; // 结点的右孩子的下标
} HTNode, *HuffmanTree;
```

哈夫曼树的各结点存储在由`HuffmanTree`定义的动态分配的数组中，为了实现方便，数组的 0 号单元不使用，从 1 号单元开始使用，所以数组的大小为 $2n$。将叶子结点集中存储在前面 1~n 号位置，而后面的 $n-1$ 个位置存储其余非叶子结点。

> **算法5.10** 构造哈夫曼树
>
> 1. 初始化：首先动态申请 $2n$ 个单元；然后循环 $2n-1$ 次，从 1 号单元开始，依次将 1 至 $2n-1$ 所有单元中的双亲、左孩子、右孩子的下标都初始化为 0；最后再循环 $n$ 次，输入前 $n$ 个单元中叶子结点的权值。
> 2. 创建树：循环 $n-1$ 次，通过 $n-1$ 次的选择、删除与合并来创建哈夫曼树。选择是从当前森林中选择双亲为 0 且权值最小的两个树根结点`s1`和`s2`；删除是指将结点`s1`和`s2`的双亲改为非 0；合并就是将`s1`和`s2`的权值之和作为一个新结点的权值依次存入到数组的第 $n+1$ 之后的单元中，同时记录这个新结点左孩子的下标为`s1`，右孩子的下标为`s2`。

```C++{.line-numbers}
void CreateHuffmanTree(HuffmanTree &HT, int n)
{
    if (n <= 1) return;
    
    // 初始化
    int m = 2 * n - 1;
    HT = new HTNode[m + 1]; // 申请 2n 个单元
    for (int i = 1; i <= m; i++)
    {
        HT[i].parent = 0;
        HT[i].lchild = 0;
        HT[i].rchild = 0;
    }
    for (int i = 1; i <= n; i++) // 输入前 n 个单元中叶子结点的权值
    {
        cin >> HT[i].weight;
    }
    
    // 创建树
    for (int i = n + 1; i <= m; i++)
    {
        // 在 HT 的前 i-1 个元素中选择双亲为 0 且权值最小的两个结点
        // 返回它们的序号 s1 和 s2
        Select(HT, i - 1, s1, s2);
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
}
```

### 5.7.3 哈夫曼编码

在数据通信、数据压缩问题中，需要将数据文件转换成由二进制字符 0、1 组成的二进制串，称之为编码。

等长编码比较简单，但并不是最优的编码方案，因为每个字符出现的频率不同。如果在编码时考虑字符出现的频率，使频率高的字符采用尽可能短的编码，频率低的字符采用稍长的编码，来构造一种不等长编码，则会获得更好的空间效率。

但对于不等长编码，如果设计得不合理，就会给解码带来困难。例如，如果字母 a、b、c、d 的编码分别为 0、01、010、111，则对于二进制串 “0010” 会有不同的译法，或是 “aba”，或是 “ac”。因此，若要设计不等长编码，必须满足一个条件：任何一个字符的编码都不是另一个字符的编码的前缀。

前缀编码：如果在一个编码方案中，任何一个编码都不是其他任何编码的前缀，则称编码是**前缀编码**。

前缀编码可以保证对压缩文件进行解码时不产生二义性，确保正确解码。

哈夫曼编码：对一棵具有 $n$ 个叶子的哈夫曼树，若对树中的每个左分支赋予 0，右分支赋予 1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串称为哈夫曼编码。

哈夫曼编码满足下面的两个性质。

> **性质1** 哈夫曼编码是前缀编码。

**证明：** 哈夫曼编码是根到叶子路径上的编码序列，由树的特点可知，若路径 A 是另一条路径 B 的最左部分，则 A 的终点一定不是叶子。而哈夫曼编码对应路径的终点一定为叶子，因此，任一哈夫曼编码都不会与任意其他哈夫曼编码的前缀部分完全重叠，因此哈夫曼编码是前缀编码。

> **性质2** 哈夫曼编码是最优前缀编码。

对于包括 $n$ 个字符的数据文件，分别以它们的出现次数为权值构造哈夫曼树，则利用该树对应的哈夫曼编码对文件进行编码，能使该文件压缩后对应的二进制文件的长度最短。

由于每个哈夫曼编码是变长编码，因此使用一个指针数组来存放每个字符编码串的首地址。

```C
// 哈夫曼编码表的存储表示
typedef char **HuffmanCode;
```

各字符的哈夫曼编码存储在由`HuffmanCode`定义的动态分配的数组`HC`中。为了实现方便，数组的 0 号单元不使用，从 1 号单元开始使用，所以数组`HC`的大小为 $n+1$，即编码表`HC`包括 $n+1$ 行。但因为每个字符编码的长度事先不能确定，所以不能预先为每个字符分配大小合适的存储空间。为了不浪费存储空间，动态分配一个长度为 $n$ 的一维数组`cd`，用来临时存放正在求解的第 $i(1\leqslant i\leqslant n)$ 个字符的编码，当第 $i$ 个字符的编码求解完毕后，根据数组`cd`的字符串长度分配`HC[i]`的空间，然后将数组`cd`中的编码复制到`HC[i]`中。

根据哈夫曼树求哈夫曼编码的主要思想是：依次以叶子为出发点，向上回溯至根结点为止，回溯时走左分支则生成代码 0，走右分支则生成代码 1。所以对于每个字符，得到的编码顺序是从右向左的，故将编码向数组`cd`存放的顺序也是从后向前的，即每个字符的第 1 个编码存放在`cd[n - 2]`中，第 2 个编码存放在`cd[n - 3]`中，以此类推，直到全部编码存放完毕。

> **算法5.11** 根据哈夫曼树求哈夫曼编码
>
> 1. 分配存储 $n$ 个字符编码的编码表空间`HC`，长度为 $n+1$；分配临时存储每个字符编码的动态数组空间`cd`，`cd[n - 1]`置为`'\0'`。
> 2. 逐个求解 $n$ 个字符的编码，循环 $n$ 次，执行以下操作：
>    （1）设置变量`start`用于记录编码在`cd`中存放的位置，`start`初始时指向编码结束符位置`n-1`。
>    （2）设置变量`c`用于记录从叶子结点向上回溯至根结点所经过的结点下标，`c`初始时为当前待编码字符的下标`i`。`f`用于记录`c`的双亲结点的下标。
>    （3）从叶子结点向上回溯至根结点，求得字符`i`的编码，当`f`没有到达根结点时，循环执行以下操作：
>    - `start`向前移动一个位置。
>    - 若结点`c`是`f`的左孩子，则生成代码 0，否则生成代码 1，生成的代码保存在`cd[start]`中。
>    - 继续向上回溯，改变`c`和`f`的值。
>
>    （4）根据数组`cd`的字符串长度，为第 $i$ 个字符编码分配空间`HC[i]`，然后将数组`cd`中的编码复制到`HC[i]`中。
> 3. 释放临时空间`cd`。

```C++{.line-numbers}
void CreateHuffmanCode(HuffmanTree HT, HuffmanCode &HC, int n)
{
    HC = new char*[n + 1]; // 分配存储 n 个字符编码的编码表空间
    char *cd = new char[n]; // 分配临时存放每个字符编码的动态数组空间
    cd[n - 1] = '\0'; // 编码结束符
    
    for (int i = 1; i <= n; i++)
    {
        int start = n - 1;
        int c = i; // c 指向当前待求编码的叶子结点
        int f = HT[i].parent; // f 指向 c 的双亲结点
        
        while (f != 0) // 从叶子结点开始向上回溯，直到根结点
        {
            start--;
            if (HT[f].lchild == c)
                cd[start] = '0'; // c 是 f 的左孩子，生成代码 0
            else
                cd[start] = '1'; // c 是 f 的右孩子，生成代码 1
            // 继续向上回溯
            c = f;
            f = HT[f].parent;
        }
        
        HC[i] = new char[n - start]; // 为第 i 个字符编码分配空间
        strcpy(HC[i], &cd[start]); // 将求得的编码从临时空间 cd 复制到 HC[i] 中
    }
    
    delete cd; // 释放临时空间
}
```

## 5.8 案例分析与实现

一般情况下，一个表达式由一个运算符和两个操作数构成，两个操作数之间有次序之分，并且操作数本身也可以是表达式，这个结构类似于二叉树，因此可以利用二叉树来表示表达式。

以二叉树表示表达式的递归定义如下：

1. 若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息。
2. 若表达式为 “第一操作数  运算符  第二操作数” 的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身又为表达式。

假设运算符均为双目运算符，则表达式对应的表达式树中叶子结点均为操作数，分支结点均为运算符。由于创建的表达式树需要准确地表达运算次序，因此在扫描表达式的过程中，当遇到运算符时不能直接创建结点，而应将其与前面的运算符进行优先级比较，根据比较结果再进行处理。

根据表达式树与表达式对应关系的递归定义，每两个操作数和一个运算符就可以建立一棵表达式二叉树，而该二叉树又可以作为另一个运算符结点的一棵子树。可以另外借助一个表达式树栈，来暂存已建立好的表达式树的根结点，以便其作为另一个运算符结点的子树而被引用。

为实现表达式树的创建算法，可以使用两个工作栈，一个称做`OPTR`， 用以暂存运算符；另一个称做`EXPT`， 用以暂存已建立好的表达式树的根结点。为了便于实现，假设每个表达式均以 “#” 开始，以 “#” 结束。

> **算法5.12** 表达式树的创建
>
> 1. 初始化`OPTR`栈和`EXPT`栈，将表达式起始符 “#” 压入`OPTR`栈。
> 2. 扫描表达式，读入第一个字符`ch`，如果表达式没有扫描完毕至 “#” 或`OPTR`的栈顶元素不为 “#” 时，则循环执行以下操作：
>    - 若`ch`不是运算符，则以`ch`为根创建一棵只有根结点的二叉树，且将该树根结点压入`EXPT`栈，读入下一个字符`ch`。
>    - 若`ch`是运算符，则根据`OPTR`的栈顶元素和`ch`的优先级比较结果，做不同的处理：
>      - 若是`ch`优先级更高，则`ch`压入`OPTR`栈，读入下一字符`ch`。
>      - 若是栈顶元素优先级更高，则弹出`OPTR`栈顶的运算符，从`EXPT`栈弹出两个表达式子树的根结点。以该运算符为根结点，以`EXPT`栈中弹出的第二个子树作为左子树，以`EXPT`栈中弹出的第一个子树作为右子树，创建一棵新二叉树，并将该树根结点压入`EXPT`栈。
>      - 若是等于，则`OPTR`的栈顶元素是 “(” 且`ch`是 “)”，这时弹出`OPTR`栈顶的 “(”，相当于括号匹配成功，然后读入下一字符`ch`。

```C++{.line-numbers}
void InitExpTree()
{
    InitStack(EXPT); // 初始化 EXPT 栈
    InitStack(OPTR); // 初始化 OPTR 栈
    Push(OPTR, '#'); // 将表达式起始符 '#' 压入 OPTR 栈
    
    char ch;
    cin >> ch;
    while (ch != '#' || GetTop(OPTR) != '#')
    {
        if (!In(ch)) // ch 不是运算符
        {
            CreateExpTree(T, NULL, NULL, ch); // 以 ch 为根创建一棵只有根结点的二叉树
            Push(EXPT, T); // 将二叉树根结点 T 压入 EXPT 栈
            cin >> ch; // 读入下一字符
        }
        else // ch 是运算符
        {
            switch (Precede(GetTop(OPTR), ch)) // 比较 OPTR 的栈顶元素和 ch 的优先级
            {
                case '<':
                    Push(OPTR, ch); // 当前字符压入 OPTR 栈
                    cin >> ch; // 读入下一字符
                    break;
                case '>':
                    Pop(OPTR, theta); // 弹出 OPTR 栈顶的运算符
                    Pop(EXPT, b); // 弹出第二个运算数
                    Pop(EXPT, a); // 弹出第一个运算数
                    // 以 theta 为根，a 为左子树，b 为右子树，创建一棵二叉树
                    CreateExpTree(T, a, b, theta);
                    Push(EXPT, T); // 将二叉树根结点 T 压入 EXPT 栈
                    break;
                case '=':
                    Pop(OPTR, x);
                    cin >> ch; // 读入下一字符
                    break;
            }
        }
    }
}
```

此算法从头到尾扫描表达式中每个字符，若表达式的字符串长度为 $n$，则此算法的时间复杂度为 $O(n)$。算法在运行时所占用的辅助空间主要取决于`OPTR`栈和`EXPT`栈的大小，显然，它们的空间大小之和不会超过 $n$，所以此算法的空间复杂度也同样为 $O(n)$。

> **算法5.13** 表达式树的求值
>
> 1. 设变量`lvalue`和`rvalue`分别用以记录表达式树中左子树和右子树的值，初值均为 0。
> 2. 如果当前结点为叶子（结点为操作数），则返回该结点的数值，否则（结点为运算符）执行如下操作：
>    （1）递归计算左子树的值，保存到`lvalue`中。
>    （2）递归计算右子树的值，保存到`rvalue`中。
>    （3）根据当前结点运算符的类型， 将`lvalue`和`rvalue`进行相应运算并返回。

```C{.line-numbers}
int EvaluateExpTree(BiTree T)
{
    int lvalue = 0;
    int rvalue = 0;
    
    if (T->lchild == NULL && T->rchild == NULL) // 结点为操作数
    {
        return T->data - '0'; // 返回结点的数值
    }
    else // 结点为运算符
    {
        lvalue = EvaluateExpTree(T->lchild); // 递归计算左子树的值
        rvalue = EvaluateExpTree(T->rchild); // 递归计算右子树的值
        return GetValue(T->data, lvalue, rvalue);
    }
}
```

对表达式树进行求值的过程实际上是一个后序遍历二叉树的过程，因此时间和空间复杂度均为 $O(n)$。

# 第6章 图

## 6.1 图的定义和基本术语

### 6.1.1 图的定义

**图**（Graph）由两个集合 $V$ 和 $E$ 组成，记为 $G=(V,E)$，其中 $V$ 是顶点的有穷非空集合，$E$ 是 $V$ 中顶点偶对的有穷集合，这些顶点偶对称为**边**。$V(G)$ 和 $E(G)$ 通常分别表示图 $G$ 的顶点集合和边集合。$E(G)$ 可以为空集，若 $E(G)$ 为空，则图 $G$ 只有顶点而没有边。

对于图 $G$，若边集 $E(G)$ 为有向边的集合，则称该图为有向图；若边集 $E(G)$ 为无向边的集合，则称该图为无向图。

在有向图中，顶点对 $\text{<}x,y\text{>}$ 是有序的，顶点对用一对尖括号括起来，它称为从顶点 $x$ 到顶点 $y$ 的一条**有向边**，$x$ 是有向边的始点，$y$ 是有向边的终点。因此，$\text{<}x,y\text{>}$ 与 $\text{<}y,x\text{>}$ 是不同的两条边。$\text{<}x,y\text{>}$ 也称作一条**弧**，则 $x$ 为弧尾，$y$ 为弧头。

在无向图中，顶点对 $(x,y)$ 是无序的，它称为与顶点 $x$ 和顶点 $y$ 相关联的一条边。这条边没有特定的方向，$(x,y)$ 与 $(y,x)$ 是同一条边。为了有别于有向边，无向边的顶点用一对圆括号括起来。

### 6.1.2 图的基本术语

用 $n$ 表示图中顶点数目，用 $e$ 表示边的数目。

假设有两个图 $G=(V,E)$ 和 $G'=(V',E')$，如果 $V'\subseteq V$ 且 $E'\subseteq E$，则称 $G'$ 为 $G$ 的**子图**。

对于无向图，若具有 $\dfrac{n(n-1)}{2}$ 条边，则称为**无向完全图**。

对于有向图，若具有 $n(n-1)$ 条弧，则称为**有向完全图**。

有很少条边或弧（如 $e<n\log_2n$）的图称为**稀疏图**，反之称为**稠密图**。

在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的**权**。带权的图通常称为**网**。

对于无向图 $G$，如果图的边 $(v,v')\in E$，则称顶点 $v$ 和 $v'$ 互为**邻接点**，即 $v$ 和 $v'$ **相邻接**。边 $(v,v')$ **依附于**顶点 $v$ 和 $v'$，或者说边 $(v,v')$ 与顶点 $v$ 和 $v'$ **相关联**。

顶点 $v$ 的**度**是指和 $v$ 相关联的边的数目，记为 $\operatorname{TD}(v)$。对于有向图，顶点 $v$ 的度分为入度和出度。**入度**是以顶点 $v$ 为头的弧的数目，记为 $\operatorname{ID}(v)$；**出度**是以顶点 $v$ 为尾的弧的数目，记为 $\operatorname{OD}(v)$。顶点 $v$ 的度为 $\operatorname{TD}(v)=\operatorname{ID}(v)+\operatorname{OD}(v)$。

一般地，如果顶点 $v_i$ 的度记为 $\operatorname{TD}(v_i)$，那么一个有 $n$ 个顶点、$e$ 条边的图，满足如下关系：
$$
e=\dfrac{1}{2}\sum_{i=1}^n \operatorname{TD}(v_i)
$$

在无向图 $G$ 中，从顶点 $v$ 到顶点 $v'$ 的**路径**是一个顶点序列 $(v=v_{i,0},v_{i,1},\cdots,v_{i,m}=v')$，其中 $(v_{i,j-1},v_{i,j})\in E,1\leqslant j\leqslant m$。如果 $G$ 是有向图，则路径也是有向的，顶点序列应满足 $\text{<}v_{i,j-1},v_{i,j}\text{>}\in E,1\leqslant j\leqslant m$。

**路径长度**是一条路径上经过的边或弧的数目。

第一个顶点和最后一个顶点相同的路径称为**回路**或**环**。

序列中顶点不重复出现的路径称为**简单路径**。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为**简单回路**或**简单环**。

在无向图 $G$ 中，如果从顶点 $v$ 到顶点 $v'$ 有路径，则称 $v$ 和 $v'$ 是**连通**的。如果对于图中任意两个顶点 $v_i,v_j\in V$，$v_i$ 和 $v_j$ 都是连通的，则称 $G$ 是**连通图**。**连通分量**是指无向图中的极大连通子图。

在有向图 $G$ 中，如果对于每一对顶点 $v_i,v_j\in V$，从 $v_i$ 到 $v_j$ 和从 $v_j$ 到 $v_i$ 都存在路径，则称 $G$ 是**强连通图**。有向图中的极大强连通子图称作有向图的**强连通分量**。

一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的 $n-1$ 条边，这样的连通子图称为连通图的**生成树**。

一棵有 $n$ 个顶点的生成树有且仅有 $n-1$ 条边。如果一个图有 $n$ 个顶点和小于 $n-1$ 条边，则是非连通图；如果它多于 $n-1$ 条边，则一定有环。但是，有 $n-1$ 条边的图不一定是生成树。

有一个顶点的入度为 0，其余顶点的读入均为 1 的有向图称为**有向树**。一个有向图的**生成森林**是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。

## 6.2 案例引入

## 6.3 图的类型定义

$$
\begin{aligned}
    & \texttt{ADT Graph \{}\\
    & \quad\texttt{数据对象：}V\,\texttt{是具有相同特性的数据元素的集合，称为顶点集}\\
    & \quad\texttt{数据关系：}\\
    & \qquad R=\{VR\}\\
    & \qquad VR=\{\text{<}v,w\text{>}|\,v,w\in V\,且\,P(v,w)\}\\
    & \qquad\texttt{其中\,$\textrm{<}v,w\textrm{>}$\,表示从\,$v$\,到\,$w$\,的弧，谓词\,$P(v,w)\,$定义了弧\,$\textrm{<}v,w\textrm{>}$\,的意义或信息}\\
    & \quad\texttt{基本操作：}\\
    & \qquad\texttt{CreateGraph(\&G,V,VR)}\\
    & \qquad\quad\texttt{初始条件：V\,是图的顶点集，VR\,是图中弧的集合}\\
    & \qquad\quad\texttt{操作结果：按\,V\,和\,VR\,的定义构造图\,G}\\
    & \qquad \texttt{DestroyGraph(\&G)}\\
    & \qquad\quad\texttt{初始条件：图\,G\,存在}\\
    & \qquad\quad\texttt{操作结果：销毁图\,G}\\
    & \qquad \texttt{LocateVex(G,u)}\\
    & \qquad\quad\texttt{初始条件：图\,G\,存在，u\,和\,G\,中顶点有相同特征}\\
    & \qquad\quad\texttt{操作结果：若\,G\,中存在顶点\,u，则返回该顶点在图中的位置，否则返回其他信息}\\
    & \qquad\texttt{GetVex(G,v)}\\
    & \qquad\quad\texttt{初始条件：图\,G\,存在，v\,是\,G\,中某个顶点}\\
    & \qquad\quad\texttt{操作结果：返回\,v\,的值}\\
    & \qquad\texttt{PutVex(\&G,v,value)}\\
    & \qquad\quad\texttt{初始条件：图\,G\,存在，v\,是\,G\,中某个顶点}\\
    & \qquad\quad\texttt{操作结果：对\,v\,赋值\,value}\\
    & \qquad\texttt{FirstAdjVex(G,v)}\\
    & \qquad\quad\texttt{初始条件：图\,G\,存在，v\,是\,G\,中某个顶点}\\
    & \qquad\quad\texttt{操作结果：返回\,v\,的第一个邻接顶点。}\\
    & \qquad\qquad\qquad\qquad\texttt{若\,v\,在\,G\,中没有邻接顶点，则返回\,null}\\
    & \qquad\texttt{NextAdjVex(G,v,w)}\\
    & \qquad\quad\texttt{初始条件：图\,G\,存在，v\,是\,G\,中某个顶点，w\,是\,v\,的邻接顶点}\\
    & \qquad\quad\texttt{操作结果：返回\,v\,的相对于\,w\,的下一个邻接顶点。}\\
    & \qquad\qquad\qquad\qquad\texttt{若\,w\,是\,v\,的最后一个邻接顶点，则返回\,null}\\
    & \qquad\texttt{InsertVex(\&G,v)}\\
    & \qquad\quad\texttt{初始条件：图\,G\,存在，v\,和\,G\,中顶点有相同特征}\\
    & \qquad\quad\texttt{操作结果：在图\,G\,中添加新顶点\,v}\\
    & \qquad\texttt{DeleteVex(\&G,v)}\\
    & \qquad\quad\texttt{初始条件：图\,G\,存在，v\,是\,G\,中某个顶点}\\
    & \qquad\quad\texttt{操作结果：删除\,G\,中顶点\,v\,及其相关的弧}\\
    & \qquad\texttt{InsertArc(\&G,v,w)}\\
    & \qquad\quad\texttt{初始条件：图\,G\,存在，v\,和\,w\,是\,G\,中两个顶点}\\
    & \qquad\quad\texttt{操作结果：在\,G\,中添加弧\,<v,w>。若\,G\,是无向图，则还添加对称弧\,<w,v>}\\
    & \qquad\texttt{DeleteArc(\&G,v,w)}\\
    & \qquad\quad\texttt{初始条件：图\,G\,存在，v\,和\,w\,是\,G\,中两个顶点}\\
    & \qquad\quad\texttt{操作结果：在\,G\,中删除弧\,<v,w>。若\,G\,是无向图，则还删除对称弧\,<w,v>}\\
    & \qquad\texttt{DFSTraverse(G)}\\
    & \qquad\quad\texttt{初始条件：图\,G\,存在}\\
    & \qquad\quad\texttt{操作结果：对图进行深度优先遍历，在遍历过程中对每个顶点访问一次}\\
    & \qquad\texttt{BFSTraverse(G)}\\
    & \qquad\quad\texttt{初始条件：图\,G\,存在}\\
    & \qquad\quad\texttt{操作结果：对图进行广度优先遍历，在遍历过程中对每个顶点访问一次}\\
    & \texttt{\} ADT Graph}
\end{aligned}
$$

## 6.4 图的存储结构

### 6.4.1 邻接矩阵

**邻接矩阵**（Adjacency Matrix）是表示顶点之间相邻关系的矩阵。设 $G(V,E)$ 是具有 $n$ 个顶点的图，则 $G$ 的邻接矩阵是具有如下性质的 $n$ 阶方阵。
$$
A[i][j]=\begin{cases}
    1 & 若\text{<}v_i,v_j\text{>}\in E\,或\,(v_i,v_j)\in E\\
    0 & 反之
\end{cases}
$$

若 $G$ 是网，则邻接矩阵可以定义为
$$
A[i][j]=\begin{cases}
    w_{i,j} & 若\text{<}v_i,v_j\text{>}\in E\,或\,(v_i,v_j)\in E\\
    \infty & 反之
\end{cases}
$$

其中，$w_{i,j}$ 表示边上的权值，$\infty$ 表示计算机允许的、大于所有边上权值的数。

用邻接矩阵表示法表示图，除了一个用于存储邻接矩阵的二维数组外，还需要用一个一维数组来存储顶点信息。其形式说明如下：

```C{.line-numbers}
// 图的邻接矩阵存储表示
#define MaxInt 32767 // 表示极大值
#define MVNum 100 // 最大顶点数

typedef char VerTexType; // 假设顶点的数据类型为字符型
typedef int ArcType; // 假设边的权值类型为整型

typedef struct
{
    VerTexType vexs[MVNum]; // 顶点表
    ArcType arcs[MVNum][MVNum]; // 邻接矩阵
    int vexnum; // 顶点数
    int arcnum; // 边数
} AMGraph;
```

> **算法6.1** 采用邻接矩阵表示法创建无向网
>
> 1. 输入总顶点数和总边数。
> 2. 依次输入点的信息存入顶点表中。
> 3. 初始化邻接矩阵，使每个权值初始化为极大值。
> 4. 构造邻接矩阵。依次输入每条边依附的顶点及其权值，确定两个顶点在图中的位置之后，为相应边赋予相应的权值，同时为其对称边赋予相同的权值。

```C++{.line-numbers}
Status CreateUDN(AMGraph &G)
{
    cin >> G.vexnum >> G.arcnum; // 输入总顶点数和总边数
    for (int i = 0; i < G.vexnum; i++)
    {
        cin >> G.vexs[i]; // 依次输入点的信息
    }
    
    for (int i = 0; i < G.vexnum; i++)
    {
        for (int j = 0; j < G.vexnum; j++)
        {
            G.arcs[i][j] = MaxInt; // 初始化邻接矩阵
        }
    }
    
    for (int k = 0; k < G.arcnum; k++) // 构造邻接矩阵
    {
        // 输入一条边依附的顶点及权值
        cin >> v1 >> v2 >> w;
        // 确定 v1 和 v2 在 G 中的位置
        int i = LocateVex(G, v1);
        int j = LocateVex(G, v2);
        // 设置边的权值
        G.arcs[i][j] = w;
        // 设置对称边的权值
        G.arcs[j][i] = G.arcs[i][j];
    }
    return OK;
}
```

该算法的时间复杂度是 $O(n^2)$。

若要建立无向图，只需对上述算法做两处小的改动：一是初始化邻接矩阵时，将边的权值均初始化为 0；二是构造邻接矩阵时，将权值 $w$ 改为常量值 1 即可。

邻接矩阵表示法的优点：

1. 便于判断两个顶点之间是否有边。
2. 便于计算各个顶点的度。对于无向图，邻接矩阵第 $i$ 行元素之和就是顶点 $i$ 的度；对于有向图，第 $i$ 行元素之和就是顶点 $i$ 的出度，第 $i$ 列元素之和就是顶点 $i$ 的入度。

缺点：

1. 不便于增加和删除顶点。
2. 不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为 $O(n^2)$。
3. 空间复杂度高。如果是有向图，$n$ 个顶点需要 $n^2$ 个单元存储边。如果是无向图，因其邻接矩阵是对称的，所以对规模较大的邻接矩阵可以采用压缩存储的方法，仅存储下三角（或上三角）的元素，这样需要 $\dfrac{n(n-1)}{2}$ 个单元即可。但无论以何种方式存储，邻接矩阵表示法的空间复杂度均为 $O(n^2)$，这对于稀疏图而言尤其浪费空间。

### 6.4.2 邻接表

**邻接表**（Adjacency List）是图的一种链式存储结构。在邻接表中，对图中每个顶点 $v_i$ 建立一个单链表，把与 $v_i$ 相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成：表头结点表和边表。

表头结点表：由所有表头结点以顺序结构的形式存储，以便可以随机访问任一顶点的链表。表头结点包括数据域和链域两部分，其中，数据域用于存储顶点 $v_i$ 的名称或其他有关信息，链域用于指向链表中第一个结点（即与顶点 $v_i$ 邻接的第一个顶点）。

边表：由表示图中顶点间关系的 $2n$ 个边链表组成。边链表中边结点包括邻接点域、数据域和链域三部分。其中，邻接点域指示与顶点 $v_i$ 邻接的点在图中的位置；数据域存储和边相关的信息，如权值等；链域指示与顶点 $v_i$ 邻接的下一条边的结点。

在无向图的邻接表中，第 $i$ 个链表中的结点数恰为顶点 $v_i$ 的度；而在有向图中，第 $i$ 个链表中的结点个数指示顶点 $v_i$ 的出度，为求入度必须遍历整个邻接表，在所有链表中，其邻接点域的值为 $i$ 的结点的个数是顶点 $v_i$ 的入度。

为了便于确定顶点的入度，可以建立一个有向图的逆邻接表，即对每个顶点 $v_i$ 建立一个链接所有进入 $v_i$ 的边的表。

```C{.line-numbers}
// 图的邻接表存储表示
#define MVNum 100 // 最大顶点数

typedef struct ArcNode // 边结点
{
    int adjvex; // 该边所指向的顶点的位置
    OtherInfo info; // 和边相关的信息
    struct ArcNode *nextarc; // 指向下一条边的指针
} ArcNode;

typedef struct VNode // 顶点信息
{
    VerTexType data;
    ArcNode *firstarc; // 指向第一条依附该顶点的边的指针
} VNode, AdjList[MVNum];

typedef struct // 邻接表
{
    AdjList vertices;
    int vexnum; // 顶点数
    int arcnum; // 边数
} ALGraph;
```

> **算法6.2** 采用邻接表表示法创建无向图
>
> 1. 输入总顶点数和总边数。
> 2. 依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为`NULL`。
> 3. 创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号 $i$ 和 $j$ 后，将此边结点分别插入 $v_i$ 和 $v_j$ 对应的两个边链表的头部。

```C++{.line-numbers}
Status CreateUDG(ALGraph &G)
{
    cin >> G.vexnum >> G.arcnum; // 输入总顶点数和总边数
    
    for (int i = 0; i < G.vexnum; i++) // 输入各点，构造表头结点表
    {
        cin >> G.vertices[i].data; // 输入顶点值
        G.vertices[i].firstarc = NULL; // 初始化表头结点的指针域为 NULL
    }
    
    for (int k = 0; k < G.arcnum; k++) // 输入各边，构造邻接表
    {
        // 输入一条边依附的两个顶点
        cin >> v1 >> v2;
        // 确定 v1 和 v2 在 G 中的位置
        int i = LocateVex(G, v1);
        int j = LocateVex(G, v2);
        // 生成一个新的边结点
        ArcNode *p1 = new ArcNode;
        p1->adjvex = j;
        // 将新结点插入顶点 vi 的边表头部
        p1->nextarc = G.vertices[i].firstarc;
        G.vertices[i].firstarc = p1;
        // 生成对称的边结点
        ArcNode *p2 = new ArcNode;
        p2->adjvex = i;
        // 将对称结点插入顶点 vj 的边表头部
        p2->nextarc = G.vertices[j].firstarc;
        G.vertices[j].firstarc = p2;
    }
    return OK;
}
```

该算法的时间复杂度是 $O(n+e)$。

建立有向图的邻接表于此类似，只是更加简单，每读入一个顶点对序号 $\text{<}i,j\text{>}$，仅需生成一个邻接点序号为 $j$ 的边表结点，并将其插入到 $v_i$ 的边链表头部即可。若要创建网的邻接表，可以将边的权值存储在`info`域中。

注意：一个图的邻接矩阵表示是唯一的，但其邻接表表示不唯一。这是因为邻接表表示中，各边表结点的链接次序取决于建立邻接表的算法，以及边的输入次序。

邻接表表示法的优点：

1. 便于增加和删除顶点。
2. 便于统计边的数目。按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为 $O(n+e)$。
3. 空间效率高。对于一个具有 $n$ 个顶点 $e$ 条边的图 $G$，若 $G$ 是无向图，则在其邻接表表示中有 $n$ 个顶点表结点和 $2e$ 个边表结点；若 $G$ 是有向图，则在其邻接表表示或逆邻接表表示中均有 $n$ 个顶点表结点和 $e$ 个边表结点。因此，邻接表或逆邻接表表示的空间复杂度为 $O(n+e)$，适合表示稀疏图。对于稠密图，考虑到邻接表中要附加链域，因此常采用邻接矩阵表示法。

缺点：

1. 不便于判断顶点之间是否有边。要判定 $v_i$ 和 $v_j$ 之间是否有边，就需要扫描第 $i$ 个边表，最坏情况下要耗费 $O(n)$ 时间。
2. 不便于计算有向图各个顶点的度。对于无向图，在邻接表表示中顶点 $v_i$ 的度是第 $i$ 个边表中的结点个数。在有向图的邻接表中，第 $i$ 个边表上的结点个数是顶点 $v_i$ 的出度，但求 $v_i$ 的入度较困难，需遍历各顶点的边表。若有向图采用逆邻接表表示，则与邻接表表示相反，求顶点的入度容易，而求顶点的出度较难。

### 6.4.3 十字链表

**十字链表**（Orthogonal List）是有向图的另一种链式存储结构，可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种链表。在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点，结点结构如图 6.1 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://raw.githubusercontent.com/zzx-JLU/images_for_markdown/main/数据结构/图6.1-十字链表的结点结构.png">
    <br>
    图6.1 十字链表的结点结构
</div>

在弧结点中有 5 个域：尾域（tailvax）指示弧尾顶点，头域（headvex）指示弧头顶点，hlink 指向弧头相同的下一条弧，tlink 指向弧尾相同的下一条弧，info 域指向该弧的相关信息。弧头相同的弧在同一链表上，弧尾相同的弧也在同一链表上，它们的头结点即为顶点结点。

顶点结点由 3 个域组成：data 域存储与顶点相关的信息，如顶点的名称等；firstin 和 firstout 为两个指针域，分别指向以该顶点为弧头或弧尾的第一个弧结点。

十字链表示例如图 6.2 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://raw.githubusercontent.com/zzx-JLU/images_for_markdown/main/数据结构/图6.2-有向图的十字链表.png">
    <br>
    图6.2 有向图的十字链表
</div>

有向图的十字链表存储表示的形式说明如下所示：

```C{.line-numbers}
#define MAX_VERTEX_NUM 20

// 弧结点
typedef struct ArcBox
{
    int tailvex; // 弧尾顶点
    int headvex; // 弧头顶点
    struct ArcBox *hlink; // 弧头相同的弧的链域
    struct ArcBox *tlink; // 弧尾相同的弧的链域
    InfoType *info; // 弧的相关信息
} ArcBox;

// 顶点结点
typedef struct VexNode
{
    VertexType data; // 顶点信息
    ArcBox *firstin; // 第一条入弧
    ArcBox *firstout; // 第一条出弧
} VexNode;

// 十字链表
typedef struct
{
    VexNode xlist[MAX_VERTEX_NUM]; // 顶点数组
    int vexnum; // 顶点数
    int arcnum; // 弧数
} OLGraph;
```

只要输入 $n$ 个顶点和 $e$ 条弧的信息，便可建立该有向图的十字链表，建立十字链表的时间复杂度与建立邻接链表相同，为 $O(n+e)$。

在十字链表中既容易找到以 $v_i$ 为尾的弧，也容易找到以 $v_i$ 为头的弧，因而容易求得顶点的入度和出度。

### 6.4.4 邻接多重表

**邻接多重表**（Adjacency Multilist）是无向图的另一种链式存储结构。邻接多重表的结构与十字链表类似，如图 6.3 所示。

<div align="center" style="margin-bottom: 10px">
    <img src="https://raw.githubusercontent.com/zzx-JLU/images_for_markdown/main/数据结构/图6.3-邻接多重表的结点结构.png">
    <br>
    图6.3 邻接多重表的结点结构
</div>

在邻接多重表中，每条边用一个结点表示，边结点由如图 6.3(a) 所示的 6 个域组成。其中，mark 为标志域，可以用来标记该条边是否被搜索过；ivex 和 jvex 为该边依附的两个顶点；ilink 指向下一条依附于顶点 ivex 的边；jlink 指向下一条依附于顶点 jvex 的边；info 为指向和边相关的各种信息的指针域。

每个顶点也用一个结点表示，它由如图 6.3(b) 所示的 2 个域组成。其中，data 域存储顶点信息，firstedge 域指向第一条依附于该顶点的边。

在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，则每个边结点同时链接在两个链表中。

对无向图而言，其邻接多重表和邻接表的差别，仅仅在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。

邻接多重表的类型说明如下：

```C{.line-numbers}
#define MAX_VERTEX_NUM 20

typedef enum
{
    unvisited,
    visited
} VisitIf;

// 边结点
typedef struct EBox
{
    VisitIf mark; // 访问标记
    int ivex;
    int jvex;
    struct EBox *ilink;
    struct EBox *jlink;
    InfoType *info; // 边信息指针
} EBox;

// 顶点结点
typedef struct VexBox
{
    VertexType data; // 顶点信息
    EBox *firstedge; // 指向第一条依附该顶点的边
} VexBox;

// 邻接多重表
typedef struct
{
    VexBox adjmulist[MAX_VERTEX_NUM]; // 顶点数组
    int vaxnum; // 顶点数
    int edgenum; // 边数
} AMLGraph;
```

## 6.5 图的遍历

### 6.5.1 深度优先搜索

深度优先搜索（Depth First Search，DFS）类似于树的先序遍历，是树的先序遍历的推广。

对于一个连通图，深度优先搜索的过程如下：

1. 从图中某个顶点 $v$ 出发，访问 $v$。
2. 找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问过的顶点没有未被访问的邻接点为止。
3. 返回前一个访问过的且仍有为被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。
4. 重复步骤 2 和 3，直至图中所有顶点都被访问过，搜索结束。

将深度优先搜索的访问和回溯过程表示成一棵树，称为**深度优先生成树**。

为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组`visited`，其初值为`false`，一旦某个顶点被访问，则其相应的分量置为`true`。

> **算法6.3** 深度优先搜索遍历连通图
>
> 1. 从图中某个顶点`v`出发，访问`v`，并置`visited[v]`为`true`。
> 2. 依次检查`v`的所有邻接点`w`，如果`visited[w]`为`false`，再从`w`出发进行递归遍历，直到图中所有顶点都被访问过。

```C++{.line-numbers}
bool visited[MVNum]; // 访问标志数组，其初值为 false

void DFS(Graph G, int v)
{
    cout << v; // 访问结点 v
    visited[v] = true;
    
    // 依次检查 v 的所有邻接点 w，FirstAdjVex(G, v) 表示 v 的第一个邻接点
    // NextAdjVex(G, v, w) 表示 v 相对于 w 的下一个邻接点
    for (int w = FirstAdjVex(G, v), w >= 0; w = NextAdjVex(G, v, w))
    {
        if (!visited[w])
            DFS(G, w);
    }
}
```

若是非连通图，上述遍历过程执行之后，图中一定还有顶点未被访问，需要从图中另选一个未被访问的顶点作为起始点，重复上述深度优先搜索过程，直到图中所有顶点均被访问过为止。

> **算法6.4** 深度优先搜索遍历非连通图

```C++{.line-numbers}
void DFSTraverse(Graph G)
{
    // 访问标志数组初始化
    for (int v = 0; v < G.vexnum; v++)
        visited[v] = false;
    
    // 循环调用算法 6.3
    for (int v = 0; v < G.vexnum; v++)
    {
        if (!visited[v]) // 对尚未访问的顶点调用 DFS
            DFS(G, v);
    }
}
```

对于算法 6.4，每调用一次算法 6.3 将遍历一个连通分量，有多少次调用，就说明图中有多少个连通分量。

在算法 6.3 中，对于查找邻接点的操作`FirstAdjVex(G, v)`及`NextAdjVex(G, v, w)`并没有具体展开。如果图的存储结构不同，这两个操作的实现方法不同，时间耗费也不同。下面的算法 6.5、算法 6.6 分别用邻接矩阵和邻接表具体实现了算法 6.3 的功能。

> **算法6.5** 采用邻接矩阵表示图的深度优先搜索

```C++{.line-numbers}
void DFS_AM(AMGrapg G, int v)
{
    cout << v;
    visited[v] = true;
    
    for (int w = 0; w < G.vexnum; w++) // 依次检查邻接矩阵中 v 所在的行
    {
        // G.arcs[v][w] != 0 表示 w 是 v 的邻接点，如果 w 未访问，则递归调用 DFS
        if (G.arcs[v][w] != 0 && !visited[w])
            DFS_AM(G, w);
    }
}
```

> **算法6.6** 采用邻接表表示图的深度优先搜索

```C++{.line-numbers}
void DFS_AL(ALGraph G, int v)
{
    cout << v;
    visited[v] = true;

    ArcNode *p = G.vertices[v].firstarc; // p 指向 v 的边链表的第一个边结点
    while(p != NULL)
    {
        ArcNode *w = p->adjvex; // w 是 v 的邻接点
        if (!visited[w]) // 如果 w 未访问，则递归调用 DFS
            DFS_AL(G, w);
        p = p->nextarc;
    }
}
```

在遍历图时，对图中每个顶点至多调用一次`DFS`函数，因此，遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间取决于所采用的存储结构。当用邻接矩阵表示图时，查找每个顶点的邻接点的时间复杂度为 $O(n^2)$，其中 $n$ 为图中顶点数。而当以邻接表做图的存储结构时，查找邻接点的时间复杂度为 $O(e)$，其中 $e$ 为图中边数，因此深度优先搜索的时间复杂度为 $O(n+e)$。

### 6.5.2 广度有限搜索

广度优先搜索（Breadth First Search，BFS）类似于树的按层次遍历的过程。

广度有限搜索的过程如下：

1. 从图中某个顶点 $v$ 出发，访问 $v$。
2. 依次访问 $v$ 的各个未曾访问过的邻接点。
3. 分别从这些邻接点出发依次访问它们的邻接点，并使 “先被访问的顶点的邻接点” 先于 “后被访问的顶点的邻接点” 被访问。重复步骤 3，直至图中所有已被访问的顶点的邻接点都被访问到。

> **算法6.7** 广度优先搜索遍历连通图
>
> 1. 从图中某个顶点`v`出发，访问`v`，并置`visited[v]`为`true`，然后将`v`入队。
> 2. 只要队列不空，则重复下述操作：
>   （1）队头顶点`u`出队。
>   （2）依次检查`u`的所有邻接点`w`，如果`visited[w]`为`false`，则访问`w`，并置`visited[w]`为`true`，然后将`w`入队。

```C++{.line-numbers}
void BFS(Graph G, int v)
{
    cout << v; // 访问顶点 v
    visited[v] = true;
    
    InitQueue(Q); // 队列初始化
    EnQueue(Q, v); // v 入队
    
    while (!QueueEmpty(Q)) // 队列非空
    {
        DeQueue(Q, u); // 队头元素出队并置为 u
        // 依次检查 u 的所有邻接点 w
        for (int w = FirstAdjVex(G, u); w >= 0; w = NextAdjVex(G, u, w))
        {
            if (!visited[w])
            {
                count << w;
                visited[w] = true;
                EnQueue(Q, w);
            }
        }
    }
}
```

若是非连通图，上述遍历过程执行之后，图中一定还有顶点未被访问，需要从图中另选一个未被访问的顶点作为起始点，重复上述广度优先搜索过程，直到图中所有顶点均被访问过为止。

每个顶点至多进一次队列。遍历图的过程实质上是通过边找邻接点的过程，因此广度优先搜索遍历图的时间复杂度和深度优先搜索遍历相同，即当用邻接矩阵存储时，时间复杂度为 $O(n^2)$；用邻接表存储时，时间复杂度为$O(n+e)$。两种遍历方法的不同之处仅仅在于对顶点访问的顺序不同。

## 6.6 图的应用

### 6.6.1 最小生成树

在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该联通网的**最小代价生成树**（Minimum Cost Spanning Tree），简称**最小生成树**。

> **最小生成树的 MST 性质**：假设 $N=(V,E)$ 是一个连通网，$U$ 是顶点集 $V$ 的一个非空子集，若 $(u,v)$ 是一条具有最小权值的边，其中 $u\in U,v\in V-U$，则必存在一棵包含边 $(u,v)$ 的最小生成树。

**证明：** 使用反证法。假设网 $N$ 的任何一棵最小生成树都不包含 $(u,v)$，设 $T$ 是连通网上的一棵最小生成树，当将边 $(u,v)$ 加入到 $T$ 中时，由生成树的定义，$T$ 中必存在一条包含 $(u,v)$ 的回路。另一方面，由于 $T$ 是生成树，则在 $T$ 上必存在另一条边 $(u',v')$，其中 $u'\in U,v'\in V-U$，且 $u$ 和 $u'$ 之间、$v$ 和 $v'$ 之间均有路径相通。删去边 $(u',v')$，便可消除上述回路，同时得到另一棵生成树 $T'$。因为 $(u,v)$ 的权值不高于 $(u',v')$，则 $T'$ 的权值也不高于 $T$，$T'$ 是包含 $(u,v)$ 的一棵最小生成树，与假设矛盾。

#### 6.6.1.1 普里姆（Prim）算法

假设 $N=(V,E)$ 是连通网，$TE$ 是 $N$ 上最小生成树中边的集合，则普里姆算法的构造过程为：

1. 初始化：$U=\{u_0\}(u_0\in V),TE=\{\}$。
2. 在所有 $u\in U,v\in V-U$ 的边 $(u,v)\in E$ 中找一条权值最小的边 $(u_0,v_0)$ 并入集合 $TE$，同时 $v_0$ 并入 $U$。如果选择权值最小的边时，存在多条同样权值的边可选，此时任选其一即可。
3. 重复步骤 2，直至 $U=V$ 为止。

图 6.4 所示为一个连通网从 $v_1$ 开始构造最小生成树的例子。可以看出，普里姆算法逐步增加 $U$ 中的顶点，可称为 **“加点法”**。

<div align="center" style="margin-bottom: 10px">
    <img src="https://raw.githubusercontent.com/zzx-JLU/images_for_markdown/main/数据结构/图6.4-普里姆算法构造最小生成树的例子.png">
    <br>
    图6.4 普里姆算法构造最小生成树的例子
</div>

假设一个无向网 $G$ 以邻接矩阵形式存储，从顶点 $u$ 出发构造 $G$ 的最小生成树 $T$，要求输出 $T$ 的各条边。为实现这个算法需附设一个辅助数组`closedge`，以记录从 $U$ 到 $V-U$ 具有最小权值的边。对每个顶点 $v_i\in V-U$，在辅助数组中存在一个相应分量`closedge[i - 1]`，它包括两个域：`lowcost`和`adjvex`，其中`lowcost`存储最小边上的权，`adjvex`存储最小边在 $U$ 中的那个顶点。

> **算法6.8** 普里姆算法
>
> 1. 首先将初始顶点 $u$ 加入 $U$ 中，对其余的每个顶点 $v_j$，将`closedge[j]`均初始化为到 $u$ 的边信息。
> 2. 循环 $n-1$ 次，做如下处理：
>   （1）从各组边`closedge`中选出最小边`closedge[k]`，输出此边。
>   （2）将 $k$ 加入 $U$ 中。
>   （3）更新剩余的每组最小边信息`closedge[j]`。对于 $V-U$ 中的边，新增了一条从 $k$ 到 $j$ 的边，如果新边的权值比`closedge[j].lowcost`小，则将`closedge[j].lowcost`更新为新边的权值。

```C++{.line-numbers}
// 辅助数组的定义，用来记录从顶点集 U 到 V-U 的权值最小的边
struct
{
    VerTexType adjvex; // 最小边在 U 中的那个顶点
    ArcType lowcost; // 最小边上的权值
} closedge[MVNum];

// 无向网 G 以邻接矩阵形式存储，从顶点 u 出发构造 G 的最小生成树 T，输出 T 的各条边
void MiniSpanTree_Prim(AMGrapg G, VerTexType u)
{
    int k = LocateVex(G, u); // k 为顶点 u 的下标
    // 初始化 closedge
    for (int j = 0; j < G.vexnum; j++)
    {
        if (j != k)
        {
            closedge[j].adjvex = u;
            closedge[j].lowcost = G.arcs[k][j];
        }
    }
    closedge[k].lowcost = 0;

    for (int i = 1; i < G.vexnum; i++)
    {
        k = Min(closedge); // 最小边的下标
        u0 = closedge[k].adjvex; // 最小边在 U 中的顶点
        v0 = G.vexs[k]; // 最小边的另一个顶点
        cout << u0 << v0;

        closedge[k].lowcost = 0; // 将 k 并入 U

        // 更新 closedge
        for (int j = 0; j < G.vexnum; j++)
        {
            if (G.arcs[k][j] < closedge[j].lowcost)
            {
                closedge[j].adjvex = G.vexs[k];
                closedge[j].clocost = G.arcs[k][j];
            }
        }
    }
}
```

假设网中有 $n$ 个顶点，则第一个进行初始化的循环语句的频度为 $n$，第二个循环语句的频度为 $n-1$。其中第二个循环中有两个内循环：其一是在`closedge[v].lowcost`中求最小值，其频度为 $n-1$；其二是重新选择具有最小权值的边，其频度为 $n$。由此，普里姆算法的时间复杂度为 $O(n^2)$，与网中的边数无关，因此适用于求稠密网的最小生成树。

#### 6.6.1.2 克鲁斯卡尔（Kruskal）算法

克鲁斯卡尔算法的构造过程：

1. 假设连通网 $N=(V,E)$，将 $N$ 中的边按权值从小到大的顺序排列。
2. 初始状态为只有 $n$ 个顶点而无边的非连通图 $T=(V,\{\})$，图中每个顶点自成一个连通分量。
3. 在 $E$ 中选择权值最小的边，若该边依附的顶点落在 $T$ 中不同的连通分量上（即不形成回路），则将此边加入到 $T$ 中，否则舍去此边而选择下一条权值最小的边。
4. 重复 3，直至 $T$ 中所有顶点都在统一连通分量上为止。

克鲁斯卡尔算法逐步增加生成树的边，与普里姆算法相比，可称为“加边法”。每次选择最小边时，可能有多条同样权值的边可选，可以任选其一。

克鲁斯卡尔算法的实现需要引入以下的辅助数据结构：

1. 结构体数组`Edge`：存储边的信息，包括边的两个顶点和权值。
2. 数组`Vexset`：标识各个顶点所属的连通分量。对每个顶点 $v_i\in V$，在辅助数组中存在一个相应元素`Vexset[i]`表示该顶点所在的连通分量。初始时`Vexset[i] = i`，表示各顶点自成一个连通分量。

> **算法6.9** 克鲁斯卡尔算法
>
> 1. 将数组`Edge`中的元素按权值从小到大排序。
> 2. 依次查看数组`Edge`中的边，循环执行以下操作：
> （1）依次从排好序的数组`Edge`中选出一条边 $(v_1,v_2)$；
> （2）在`Vexset`中分别查找 $v_1$ 和 $v_2$ 所在的连通分量 $vs_1$ 和 $vs_2$，进行判断：
>    - 如果 $vs_1$ 和 $vs_2$ 不等，表明所选的两个顶点分属不同的连通分量，输出此边，并合并 $vs_1$ 和 $vs_2$ 两个连通分量；
>    - 如果 $vs_1$ 和 $vs_2$ 相等，表明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。

```C++{.line-numbers}
// 辅助数组 Edge 的定义
struct
{
    VerTexType Head; // 边的始点
    VerTexType Tail; // 边的终点
    ArcType lowcost; // 边上的权值
} Edge[arcnum];

// 辅助数组 Vexset 的定义
int Vexset[MVNum];

// 无向网 G 以邻接矩阵形式存储，构造 G 的最小生成树 T，输出 T 的各条边
void MiniSpanTree_Kruskal(AMGraph G)
{
    Sort(Edge); // 将数组 Edge 中的元素按权值从小到大排序

    // 辅助数组 Vexset 初始化，表示各顶点自成一个连通分量
    for (int i = 0; i < G.vexnum; i++)
    {
        Vexset[i] = i;
    }

    // 依次查看数组 Edge 中的边
    for (int i = 0; i < G.arcnum; i++)
    {
        int v1 = LocateVex(G, Edge[i].Head); // v1 为边的始点的下标
        int v2 = LocateVex(G, Edge[i].Tail); // v2 为边的终点的下标
        int vs1 = Vexset[v1]; // 获取边 Edge[i] 的始点所在的连通分量
        int vs2 = Vexset[v2]; // 获取边 Edge[i] 的终点所在的连通分量

        if (vs1 != vs2) // 边的两个顶点分属不同的连通分量
        {
            cout << Edge[i].Head << Edge[i].Tail; // 输出此边
            // 合并 vs1 和 vs2 两个分量
            for (int j = 0; j < G.vexnum; j++)
            {
                if (Vexset[j] == vs2)
                {
                    Vexset[j] = vs1; // 集合编号为 vs2 的都改为 vs1
                }
            }
        }
    }
}
```

假设使用堆排序对辅助数组`Edge`进行排序，对于包含 $e$ 条边的网，排序时间是 $O(e\log_2 e)$。在 for 循环中最耗时的操作是合并两个不同的连通分量，只要采取合适的数据结构，可以证明其执行时间为 $O(\log_2 e)$，因此整个 for 循环的执行时间是 $O(e\log_2 e)$。由此，克鲁斯卡尔算法的时间复杂度为 $O(e\log_2 e)$。与普里姆算法相比，克鲁斯卡尔算法更适合于求稀疏网的最小生成树。

### 6.6.2 最短路径

在带权有向网中，称路径上的第一个顶点为**源点**（source），最后一个顶点为**终点**（destination）。

#### 6.6.2.1 从某个源点到其余各顶点的最短路径

给定带权有向图 $G$ 和源点 $v_0$，求从 $v_0$ 到 $G$ 中其余各顶点的最短路径。

迪杰斯特拉（Dijkstra）算法的求解过程：对于网 $N=(V,E)$，将 $N$ 中的顶点分成两组，$S$ 为已求出最短路径的终点集合（初始时只包含源点 $v_0$），$V-S$ 为尚未求出最短路径的顶点集合（初始时为 $V-\{v_0\}$）。算法将按各顶点与 $v_0$ 间最短路径长度递增的次序，逐个将集合 $V-S$ 中的顶点加入到集合 $S$ 中去。在这个过程中，总保持从 $v_0$ 到集合 $S$ 中各顶点的路径长度始终不大于到集合 $V-S$ 中各顶点的路径长度。

这种求解方法能确保是正确的。因为，假设 $S$ 为已求得最短路径的终点的集合，则下一条最短路径（设其终点为 $x$）或者是边 $(v_0,x)$，或者是中间只经过 $S$ 中的顶点而最后到达顶点 $x$ 的路径。

**证明：** 使用反证法。假设此路径上有一个顶点不在 $S$ 中，则说明存在一条终点不在 $S$ 而长度比此路径更短的路径。但这是不可能的，因为算法是按路径长度递增的顺序来产生最短路径的，长度比此路径短的所有路径均已产生，它们的终点必定在 $S$ 中，因此假设不成立。所以，最新的最短路径一定只经过 $S$ 中的顶点而最后到达顶点 $x$。

假设用带权的邻接矩阵`arcs`来表示带权有向网 $G$，`G.arcs[i][j]`表示弧 $\text{<}v_i,v_j\text{>}$ 上的权值。若 $\text{<}v_i,v_j\text{>}$ 不存在，则置`G.arcs[i][j]`为 $\infin$。

算法的实现要引入以下的辅助数据结构：

1. 一维数组`S`：元素`S[i]`记录从源点 $v_0$ 到终点 $v_i$ 是否已经确定最短路径长度，`true`表示确定，`false`表示尚未确定。
2. 一维数组`Path`：元素`Path[i]`记录从源点 $v_0$ 到终点 $v_i$ 的当前最短路径上 $v_i$ 的直接前驱顶点序号。其初值为：如果从 $v_0$ 到 $v_i$ 有弧，则`Path[i]`为 $v_0$，否则为 -1。
3. 一维数组`D`：元素`D[i]`记录从源点 $v_0$ 到终点 $v_i$ 的当前最短路径长度。其初值为：如果从 $v_0$ 到 $v_i$ 有弧，则`D[i]`为弧上的权值，否则为 $\infin$。

长度最短的一条最短路径 $(v_0,v_k)$ 满足以下条件：
$$
\operatorname{D}[k]=\min\{\operatorname{D}[i]\,|\,v_i\in V-S\}
$$

求得顶点 $v_k$ 的最短路径后，将其加入到顶点集 $S$ 中。

每当加入一个新的顶点到顶点集 $S$，对 $V-S$ 剩余的各个顶点而言，多了一个中转顶点，从而多了一个中转路径，所以要对 $V-S$ 中剩余的各个顶点的最短路径长度进行更新。原来 $v_0$ 到 $v_i$ 的最短路径长度为`D[i]`，加进 $v_k$ 后，以 $v_k$ 作为中间顶点的中转路径长度为`D[k] + G.arcs[k][i]`，若`D[k] + G.arcs[k][i] < D[i]`，则用`D[k] + G.arcs[k][i]`取代`D[i]`。

更新后，再选择数组`D`中值最小的顶点加入到顶点集 $S$ 中，如此进行下去，直到图中所有顶点都加入到 $S$ 中为止。

> **算法6.10** 迪杰斯特拉算法
>
> 1. 初始化：
>    （1）将源点 $v_0$ 加到 $S$ 中，即`S[v0] = true`；
>    （2）将 $v0$ 到各个终点的最短路径长度初始化为权值，即`D[i] = G.arcs[v0][vi]`（$v_i\in V-S$）；
>    （3）如果 $v_0$ 和 $v_i$ 之间有弧，则将 $v_i$ 的前驱置为 $v_0$，即`Path[i] = v0`，否则`Path[i] = -1`。
> 2. 循环 $n-1$ 次，执行以下操作：
>    （1）选择下一条最短路径的终点 $v_k$，使得 $\operatorname{D}[k]=\min\{\operatorname{D}[i]\,|\,v_i\in V-S\}$；
>    （2）将 $v_k$ 加到 $S$ 中，即`S[vk] = true`；
>    （3）根据条件更新从 $v_0$ 出发到集合 $V-S$ 上任一顶点的最短路径的长度。若`D[k] + G.arcs[k][i] < D[i]`成立，则更新`D[i] = D[k] + G.arcs[k][i]`，同时更改 $v_i$ 的前驱为 $v_k$，即`Path[i] = k`。

```C{.line-numbers}
void Dijkstra(AMGraph G, int v0)
{
    int n = G.vexnum; // n 为 G 中顶点的个数
    // n 个顶点依次初始化
    for (int i = 0; i < n; i++)
    {
        S[v] = false;
    }
}
```
